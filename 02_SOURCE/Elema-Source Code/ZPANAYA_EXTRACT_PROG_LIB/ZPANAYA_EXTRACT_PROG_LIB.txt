*-------------------------------------------------------------------*
* Panaya code extraction tool                                       *
* Author: Panaya Ltd (www.panaya.com)                               *
*-------------------------------------------------------------------*
* Copyright (c) 2013      Panaya Ltd. All rights reserved.          *
*                                                                   *
* Warning: This computer program is  protected by copyright law and *
* international treaties. Unauthorized reproduction or distribution *
* of the program, or any  portion of it, may result in severe civil *
* and criminal  penalties, and  will be  prosecuted  to the maximum *
* extent possible under the law.                                    *
*-------------------------------------------------------------------*
* THIS COMPUTER PROGRAM IS PROVIDED TO YOU STRICTLY ON AN "AS IS"   *
* BASIS. ALL CONDITIONS, REPRESENTATIONS AND WARRANTIES, WHETHER    *
* EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT      *
* LIMITATION, ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR  *
* A PARTICULAR PURPOSE, OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS   *
* IN RELATION TO THIS COMPUTER PROGRAM, ARE HEREBY DISCLAIMED TO    *
* THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW BY PANAYA          *
* (INCLUDING ITS AFFILIATES, DIRECTORS, OFFICERS, EMPLOYEES, AGENTS,*
* CONTRACTORS, SUCCESSORS OR ASSIGNEES) AND ITS LICENSORS. WITHOUT  *
* DEROGATING FROM THE AFORESAID, PANAYA AND ITS LICENSORS MAKE NO   *
* REPRESENTATION, WARRANTY, OR GUARANTY AS TO THE RELIABILITY,      *
* QUALITY, SUITABILITY, AVAILABILITY, ACCURACY OR COMPLETENESS OF   *
* THIS COMPUTER PROGRAM. PANAYA (INCLUDING ITS AFFILIATES,          *
* DIRECTORS, OFFICERS, EMPLOYEES, AGENTS, CONTRACTORS, SUCCESSORS   *
* OR ASSIGNEES) AND ITS LICENSORS DO NOT REPRESENT OR WARRANT THAT  *
* (A) THE USE OF THIS COMPUTER PROGRAM WILL BE TIMELY,              *
* UNINTERRUPTED OR ERROR-FREE OR OPERATE IN COMBINATION WITH ANY    *
* OTHER HARDWARE, SOFTWARE, SYSTEM OR DATA, (B) THIS COMPUTER       *
* PROGRAM WILL MEET YOUR REQUIREMENTS OR EXPECTATIONS, (C) ERRORS   *
* OR DEFECTS WILL BE CORRECTED, OR (D) THIS COMPUTER PROGRAM IS     *
* FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS.                      *
*-------------------------------------------------------------------*
* This version of the program is valid for SAP ERP 6.0              *
*-------------------------------------------------------------------*
REPORT ZPANAYA_EXTRACT_PROG_LIB.
*                                            ========
CONSTANTS: REL_SPECIFIC_VER(15) TYPE C VALUE '10_2005',
HEADER_MINI_VERSION(4) TYPE C VALUE
'0'.
*                                            ========
CONSTANTS: NUM_OBJECT_TYPES       TYPE I VALUE 48.
TYPE-POOLS: ABAP.
DATA: UNICODELG           LIKE X030L-UNICODELG.
DATA: GV_ENDLINE       TYPE ABAP_CHAR1.
TYPES: T_FUNCTION_SOURCE TYPE RSSOURCE.
TYPES: BEGIN OF SM_RSDRI_S_RANGE_RFC,
CHANM    TYPE CHAR30,
SIGN     TYPE C,
COMPOP   TYPE CHAR2,
LOW(60)  TYPE C,
HIGH(60) TYPE C,
END OF SM_RSDRI_S_RANGE_RFC.

DATA: G_WEB_DATA TYPE TABLE OF SWNCAGGWEBDEST.

DATA: G_WEB_BLACKLIST TYPE RANGE OF CHAR250_D.

DATA: G_PROXY_HEADERS TYPE STANDARD TABLE OF SPROXHDR.
*--------- Panaya Extract Version -----------========---------------*
CONSTANTS: GENERAL_PART_VER(15)  TYPE C VALUE '2.40'.
*--------------------------------------------========---------------*

CLASS CL_IXML DEFINITION LOAD.

* Includes
INCLUDE <ICON>.

* Type-pools
TYPE-POOLS: ABAP, SLIS, VRM.

* Constants definition
*                                             =======
CONSTANTS: XML_VERSION(10)       TYPE C VALUE '1.12',
*                                             =======
EXTRACT_USER_DATA      TYPE C VALUE 'X',
SHOW_LOGIN_NAME        TYPE C VALUE 'X',
SHOW_SERVERS_NAME      TYPE C VALUE 'X',
GET_AGR_USERS          TYPE C VALUE 'X',
EXTRACT_UPL_DATA       TYPE C VALUE 'X',
GET_ONLY_CUST_UPL      TYPE C VALUE ' ',
EXTRACT_SOLAR_DATA     TYPE C VALUE 'X',
IA_DATA_ONLY           TYPE C VALUE ' ',
NO_WEB_USAGE           TYPE C VALUE ' ',
EXTRACT_PROXY_DATA     TYPE C VALUE 'X',
EXTRACT_PROXY_CALLERS  TYPE C VALUE 'X',
EXTRACT_IDOCS_USAGE    TYPE C VALUE 'X',
MAX_IDOC_USAGE_PAIRS   TYPE I VALUE 1000,
MAX_IDOC_USAGE_TIME    TYPE SY-UZEIT VALUE '004500',
TESTING_DATA_ONLY      TYPE C VALUE ' '.
DATA:      NO_SUET_DATA           TYPE C VALUE ' '.
CONSTANTS: EXTRACT_DEBUG           TYPE C VALUE ' ',
ROOT_ELEMENT_NAME(30)  TYPE C VALUE 'ROOT_ELEMENT',
BUFFER_MAX_SIZE        TYPE I VALUE 10000000,
AGR_USERS_ROW_COUNT    TYPE I VALUE 10000,
CDATA_END_REPLACE(15)  TYPE C VALUE '&xml_cdata_end&',
SKIP_EMPTY_TAGS        TYPE C VALUE 'X',
ENCODING(10)           TYPE C VALUE 'UTF-8',
ALLOWED_CHARS(58)      TYPE C VALUE
'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_^$~!##%&-{}()@`''.\/:',
ADD_ABAP_QUERIES       TYPE C VALUE SPACE,
ADD_GEN_PROGRAMS       TYPE C VALUE SPACE,
ORIGIN_SOURCE          TYPE I VALUE 1,
ORIGIN_TARGET          TYPE I VALUE 2,
MAX_MAINS              TYPE I VALUE 500,
SAPRL_46C              TYPE SAPRL VALUE '46C',
WARN_TABLE_SIZE        TYPE I VALUE 100000,
UPL_MONTH_NUMBER       TYPE I VALUE 12,
EHP7_RELEASE           TYPE SAPRELEASE VALUE '617',
MAX_SELECT_OPTIONS     TYPE I VALUE 1000,
MAX_SEL_OPT_LARGE_DATA TYPE I VALUE 500,
MONTHS_BACK_USAGE      TYPE I VALUE 3,

*          Is account on trial
IS_ON_TRIAL            TYPE C VALUE ' ',

*          Test mode definiton - do not change
PANAYA_TEST_MODE TYPE C VALUE SPACE,

*          Extract full usage data - ST03N. To turn on the extraction
*          of the full usage data set the SPACE to 'X' as follows:
EXTRACT_FULL_USAGE TYPE C VALUE SPACE,
*          EXTRACT_FULL_USAGE TYPE C VALUE 'X',

*          Extract workflow data. To turn on the extraction of the
*          workflow data set the SPACE to 'X' as follows:
EXTRACT_WORKFLOW_DATA TYPE C VALUE SPACE,
*          EXTRACT_WORKFLOW_DATA TYPE C VALUE 'X',

*          Require SOLMAN RFC. To turn of the error
*          please set the 'X' to SPACE as follows:
REQUIRE_SOLMAN_RFC TYPE C VALUE 'X',
*          require_solman_rfc type c value space,

*          Show error for not Production RFC. To turn of the error
*          please set the SPACE to 'X' as follows:
DONT_SHOW_ERROR_ON_RFC TYPE C VALUE 'X'.
*          DONT_SHOW_ERROR_ON_RFC TYPE C VALUE SPACE.


TABLES: TFDIR, FUNCT, TFTIT, PROGDIR, SSCRFIELDS.
* Types definition
TYPES: BEGIN OF T_UNIFIED_SOURCE,
LINE(255) TYPE C,
END OF T_UNIFIED_SOURCE,
TT_UNIFIED_SOURCE TYPE TABLE OF T_UNIFIED_SOURCE,
T_PROGRAM_TYPE  TYPE TABLE OF TRDIR,

BEGIN OF FUNCTION_TYPE,
FUNCNAME LIKE TFDIR-FUNCNAME,
END OF FUNCTION_TYPE,
BEGIN OF INFOTYPE_TYPE,
TCODE(46)  TYPE C,
PROG       TYPE PROGRAM_ID,
MODULE TYPE UFPS_POSID,
TYPE,
END OF INFOTYPE_TYPE,

T_FUNCTION_TYPE  TYPE TABLE OF FUNCTION_TYPE,
T_INFOTYPE_TYPE  TYPE TABLE OF INFOTYPE_TYPE,

BEGIN OF XML_LINE_TYPE,
DATA(256) TYPE X,
END OF XML_LINE_TYPE,
XML_TAB_TYPE TYPE TABLE OF XML_LINE_TYPE,

XML_DOCUMENT TYPE REF TO IF_IXML_DOCUMENT,
XML_ELEMENT  TYPE REF TO IF_IXML_ELEMENT,

BEGIN OF HANDLES_TYPE,
NODE_REF TYPE XML_ELEMENT,
WA       TYPE REF TO DATA,
END OF HANDLES_TYPE,
HANDLES_TAB_TYPE TYPE TABLE OF HANDLES_TYPE,

BEGIN OF DDTYPES_TYPE,
TYPEKIND LIKE DDTYPES-TYPEKIND,
TYPENAME LIKE DDTYPES-TYPENAME,
END OF DDTYPES_TYPE,

BEGIN OF DATA_ELEMENT_TYPE,
ROLLNAME LIKE DFIES-ROLLNAME,
INTTYPE  LIKE DFIES-ROLLNAME,
INTLEN   LIKE DFIES-INTLEN,
DECIMALS LIKE DFIES-DECIMALS,
END OF DATA_ELEMENT_TYPE,
DATA_ELEMENT_TAB_TYPE TYPE TABLE OF DATA_ELEMENT_TYPE,

BEGIN OF ETL_MESSAGE_TYPE,
ORDER(5) TYPE N,
DATE LIKE SY-DATUM,
TIME LIKE SY-UZEIT,
MESSAGE(512) TYPE C,
END OF ETL_MESSAGE_TYPE,

BEGIN OF ETL_TIME_STATS_TYPE,
STEP(512) TYPE C,
STARTDATE TYPE AS4DATE,
STARTTIME TYPE AS4TIME,
ENDDATE TYPE AS4DATE,
ENDTIME TYPE AS4TIME,
END OF ETL_TIME_STATS_TYPE,

BEGIN OF MODIFIED_OBJECT,
OBJ_TYPE LIKE TADIR-OBJECT,
OBJ_NAME LIKE TADIR-OBJ_NAME,
END OF MODIFIED_OBJECT.

TYPES: BEGIN OF OUTREC,
PERIOD  TYPE CHAR6,
TCODE   TYPE CHAR255, "SAPWLPFNRM-REPORT,
JOBNAME TYPE SY-CPROG,
TYPE    TYPE CHAR1,
*           user    TYPE SAPWLUTACC,
USAGE   TYPE NUM10,
END OF OUTREC.

TYPES: BEGIN OF PROG_TYPE,
PROG LIKE TADIR-OBJ_NAME,
END OF PROG_TYPE,
PROG_TAB_TYPE TYPE TABLE OF PROG_TYPE.

TYPES: BEGIN OF VANILLA_PROG_TYPE,
PROG LIKE TADIR-OBJ_NAME,
ORIGIN TYPE I,
END OF VANILLA_PROG_TYPE,
VANILLA_PROG_TAB_TYPE TYPE TABLE OF VANILLA_PROG_TYPE.

* The MSXXLIST structure as it is in 46C
TYPES: BEGIN OF MSXXLIST_46_TYPE,
NAME(20) TYPE C,
HOST(20) TYPE C,
SERV(20) TYPE C,
MSGTYPES TYPE MSTYPES,
HOSTADR  TYPE MSHOSTADR,
SERVNO    TYPE MSSERVNO,
END OF MSXXLIST_46_TYPE,
MSXXLIST_46_TAB_TYPE TYPE TABLE OF MSXXLIST_46_TYPE.

TYPES: BEGIN OF SUBROUTINE_TYPE,
SUBROUTINE TYPE STRING,
END OF SUBROUTINE_TYPE,
SUBROUTINE_TAB_TYPE TYPE TABLE OF SUBROUTINE_TYPE.

TYPES:
BEGIN OF UPL_DATA,
*    SMD_LSID(8)  type C, "System ID
SM_CCLPN(40) TYPE C, "Program Name
SM_CCLOT(4)  TYPE C, "Object Type
SM_CCLON(40) TYPE C, "Object Name
SM_CCLNS(10) TYPE C, "Namespace
SM_CCLTP(4)  TYPE C, "Processing type
SM_CCLNP(60) TYPE C, "Processing block
CALMONTH(6)  TYPE N, "Month in the year
SM_CCLPE(8)  TYPE F,
MONTH_USED   TYPE I,
METHOD_INC(40)   TYPE C,
END OF UPL_DATA,
UPL_DATA_TAB TYPE TABLE OF UPL_DATA.
TYPES: BEGIN OF T_BTE_UE,
EVENT	TYPE TBE01-EVENT,
TEXT1 TYPE TBE01T-TEXT1,
STDFB TYPE STDFU_BF,
END OF T_BTE_UE.

DATA: BEGIN OF LT_PROG_EXP.
INCLUDE STRUCTURE TRDIR.
DATA:   ADDED_BY_SMODILOG TYPE C,
END OF LT_PROG_EXP.

TYPES: LT_PROG_TYPE LIKE LT_PROG_EXP OCCURS 0.

DATA: BEGIN OF STRUCTURE_FIELDS_TEMP.
INCLUDE STRUCTURE DFIES.
DATA:    ADMINFIELD TYPE ADMINFIELD,
END OF STRUCTURE_FIELDS_TEMP.

DATA: BEGIN OF TABLE_TYPE_TEMP.
INCLUDE STRUCTURE DD40L.
DATA:    INTTYPE TYPE INTTYPE,
INTLEN  TYPE INTLEN,
END OF TABLE_TYPE_TEMP.

TYPES: STRUCTURE_FIELDS_TYPE LIKE STRUCTURE_FIELDS_TEMP,
STRUCTURE_FIELDS_TAB_TYPE TYPE TABLE OF STRUCTURE_FIELDS_TYPE,
TABLE_TYPE_TYPE LIKE TABLE_TYPE_TEMP,
TABLE_TYPE_TAB_TYPE TYPE TABLE OF TABLE_TYPE_TYPE.

* solman types
* Systems / SAP systems / SAP systems clients
TYPES: BEGIN OF SMSY_SYSTEM,
SYSTEMNAME  TYPE  CHAR8,"smsy_name
KONZS  TYPE KONZS,
VERSION  TYPE CHAR10,"smsy_version,
SYSTEMTYPE  TYPE CHAR10,"smsy_systype,
LSYSTEMNAME  TYPE CHAR80,"smsy_lname,
DESCR  TYPE CHAR80,"smsy_sysdescr,
FLGSAP  TYPE FLAG,"smsy_flg_sap,
ARCHITECTURE  TYPE CHAR15,"smsy_arch,
URL  TYPE URL,
LCR_NAME   TYPE CHAR80,"smsy_lcrsysname,
PRODVERS  TYPE CHAR20,"smsyprodvers,
INSTANCE  TYPE CHAR20,"smsyinstance,
PLANNED  TYPE CHAR1,"smsy_flg_planned,
PRODUCTIVE  TYPE CHAR1,"smsy_flg_produc,
SYDATUM  TYPE SYDATUM,
SYUZEIT  TYPE SYUZEIT,
SYUNAME  TYPE SYUNAME,
TRCODE  TYPE TCODE,
GENERATOR  TYPE CHAR10,"smsy_flag,
AKT_VERSION  TYPE CHAR10,"smsy_version,
ENTITY_KEY  TYPE CHAR32,"smsy_entity_guid,
SLDHOST  TYPE CHAR64,"sld_hostname,
SLDPORT  TYPE NUMC5,"sld_portnumber,
SLDNAMESPACE  TYPE CHAR40,"smsy_sld_nspace,
SLD_NAME  TYPE CHAR255,"sldname,
NO_ABAP_INCLUDED TYPE  CHAR1,"smsy_yesno,
BU_PARTNER TYPE  CHAR10,"aicustomer,
END OF SMSY_SYSTEM,
SMSY_SYSTEM_T TYPE STANDARD TABLE OF SMSY_SYSTEM.
TYPES: BEGIN OF SMSY_SYSTEM_SAP,
SYSTEMNAME TYPE  CHAR8,"smsy_name
KONZS TYPE KONZS,
VERSION TYPE CHAR10,"smsy_version,
SYSTEMTYPE TYPE CHAR10,"smsy_systype,
ARCHITECTURE TYPE CHAR15,"smsy_arch,
SYSNR TYPE CHAR2,"systnr,
MESSSERVER TYPE CHAR255,"messserver,
INST_NUMBER TYPE CHAR10,"smsy_inst_nr,
DBSYS TYPE SYDBSYS,
SYDATUM TYPE SYDATUM,
SYUZEIT TYPE SYUZEIT,
SYUNAME TYPE SYUNAME,
TRCODE  TYPE TCODE,
GENERATOR TYPE CHAR10,"smsy_flag,
AKT_VERSION TYPE CHAR10,"smsy_version,
TMSDOMNAM TYPE TMSDOMNAM,
DISPATCHER TYPE CHAR255,"smsy_dispatcher,
PORTNR TYPE NUMC5,"smsy_portnr,
TEMP_INACTIVE TYPE  CHAR1,"smsy_flg_inactiv,
SLDHOST  TYPE CHAR64,"sld_hostname,
SLDPORT  TYPE NUMC5,"sld_portnumber,
SLDNAMESPACE  TYPE CHAR40,"smsy_sld_nspace,
SLD_NAME  TYPE CHAR255,"sldname,
TMS_VIRTUAL TYPE CHAR1,"smsy_flg_virtual,
LICENSE_EXP TYPE DATUM,"smsy_lic_date,
PROTOCOL TYPE CHAR10,"smsy_http_prot,
NO_ABAP_INCLUDED TYPE FLAG,"smsy_yesno,
MSG_SERVER_ID TYPE CUSTKEY_T,
END OF SMSY_SYSTEM_SAP,
SMSY_SYSTEM_SAP_T TYPE STANDARD TABLE OF SMSY_SYSTEM_SAP.
TYPES: BEGIN OF SMSY_SYST_CLIENT,
SYSTEMNAME TYPE  CHAR8,"smsy_name
KONZS TYPE KONZS,
MANDT TYPE CHAR3,"smsy_mandt,
VERSION TYPE CHAR10,"smsy_version,
SYSTEMTYPE TYPE CHAR10,"smsy_systype,
MTEXT TYPE MTEXT_D,
ORT01 TYPE ORT01,
MWAER TYPE MWAER,
ADRNR TYPE CHAR10,
CCCATEGORY TYPE CCCATEGORY,
CCCORACTIV TYPE CCCORACTIV,
CCNOCLIIND TYPE CCNOCLIIND,
CCCOPYLOCK TYPE CCCOPYLOCK,
CCNOCASCAD TYPE CCNOCASCAD,
CCSOFTLOCK TYPE CCSOFTLOCK,
CCORIGCONT TYPE CCORIGCONT,
CCIMAILDIS TYPE CCIMAILDIS,
CCTEMPLOCK TYPE CCTEMPLOCK,
CHANGEUSER TYPE AS4USER,
CHANGEDATE TYPE AS4DATE,
LOGSYS TYPE LOGSYS,
SYDATUM TYPE SYDATUM,
SYUZEIT TYPE SYUZEIT,
SYUNAME TYPE SYUNAME,
TRCODE  TYPE TCODE,
GENERATOR TYPE CHAR10,"smsy_flag,
AKT_VERSION TYPE CHAR10,"smsy_version,
BU_PARTNER TYPE BU_PARTNER,
END OF SMSY_SYST_CLIENT,
SMSY_SYST_CLIENT_T TYPE STANDARD TABLE OF SMSY_SYST_CLIENT.
TYPES: BEGIN OF SMSY_SYS_RELINST,
SYSTEMNAME TYPE  CHAR8,"smsy_name
KONZS TYPE KONZS,
VERSION TYPE CHAR10,"smsy_version,
PRODUCT TYPE CHAR20,"smsyproduct,
INSTANCE TYPE CHAR20,"smsyinstance,
FLG_RELEVANT TYPE CHAR1,"smsy_flg_relevant_inst,
SYDATUM TYPE SYDATUM,
SYUZEIT TYPE SYUZEIT,
SYUNAME TYPE SYUNAME,
TRCODE  TYPE TCODE,
GENERATOR TYPE CHAR10,"smsy_flag,
AKT_VERSION TYPE CHAR10,"smsy_version,
ENTITY_KEY TYPE CHAR32,"smsy_entity_guid,
SYSTEM_ID TYPE CHAR8,"smsy_subsys_name,
SYSTEMTYPE TYPE CHAR8,"smsy_systype,
ADAPTIVEFLAG TYPE CHAR1,"smsy_adaptive,
REFINSTANCE TYPE CHAR20,"smsyinstance,
END OF SMSY_SYS_RELINST,
SMSY_SYS_RELINST_T TYPE STANDARD TABLE OF SMSY_SYS_RELINST.
* System products instances
TYPES: BEGIN OF SMSY_MAIN_INST,
PRODUCT TYPE CHAR20,"smsyproduct,
INSTANCE TYPE CHAR20,"smsyinstance,
TEXT TYPE CHAR30,"smsyinststxt,
IMPL_RELEVANT TYPE CHAR1,"smsy_impl_rel,
MONIT_RELEVANT TYPE CHAR1,"smsy_monit_rel,
DB_INSTANCE TYPE CHAR1,"smsy_isdbinstance,
TECH_INST TYPE CHAR1,"smsy_techinst,
LUSER TYPE SYUNAME,
LDATE TYPE SYDATUM,
LTIME TYPE SYUZEIT,
PROD_ABAB_INST TYPE FLAG,"smsy_yesno,
END OF SMSY_MAIN_INST,
SMSY_MAIN_INST_T TYPE STANDARD TABLE OF SMSY_MAIN_INST.
TYPES: BEGIN OF SMSY_MAIN_INST_SYST,
SYSTEMNAME TYPE  CHAR8,"smsy_name
PRODUCT TYPE CHAR20,"smsyproduct,
INSTANCE TYPE CHAR20,"smsyinstance,
TEXT TYPE CHAR30,"smsyinststxt,
IMPL_RELEVANT TYPE CHAR1,"smsy_impl_rel,
MONIT_RELEVANT TYPE CHAR1,"smsy_monit_rel,
DB_INSTANCE TYPE CHAR1,"smsy_isdbinstance,
TECH_INST TYPE CHAR1,"smsy_techinst,
LUSER TYPE SYUNAME,
LDATE TYPE SYDATUM,
LTIME TYPE SYUZEIT,
PROD_ABAB_INST TYPE FLAG,"smsy_yesno,
END OF SMSY_MAIN_INST_SYST,
SMSY_MAIN_INST_SYST_T TYPE STANDARD TABLE OF
SMSY_MAIN_INST_SYST .
* Components
TYPES: BEGIN OF SMSYPROCOM,
SYSNAM TYPE CHAR20,
COMPONENT TYPE CHAR30,
RELEASE TYPE CHAR10,
PATCHLEVEL TYPE CHAR10,
PATCH TYPE CHAR20,
COMP_TYPE TYPE CHAR1,
DESC_TEXT TYPE CHAR80 ,
LEAD_COMP TYPE FLAG ,
END OF  SMSYPROCOM,
SMSYPROCOM_T TYPE STANDARD TABLE OF SMSYPROCOM.
* Patches for systems
TYPES : BEGIN OF TY_SYST_PAT03,
PATCH TYPE PATCH,
SHORT_TEXT TYPE PATCHTXT,
STATUS TYPE PATCHSTAT,
DELIV_DATE TYPE PATDELDATE,
DELIV_TIME TYPE PATDELTIME,
RESPONSIBL TYPE PATCH_USER,
IMPLE_DATE TYPE PATIMPDATE,
IMPLE_TIME TYPE PATIMPTIME,
L_IMPL_REL TYPE SYSAPRL,
CONFLICTS TYPE  PAT_CONFL,
CONFIRMED TYPE  CONFIRMED,
BACKUP TYPE TRKORR,
FROM_REL TYPE SYSAPRL,
TO_REL TYPE SYSAPRL,
OS TYPE SYOPSYS,
DB TYPE SYDBSYS,
PATCH_TYPE TYPE PATCH_TYPE,
ANCESTOR TYPE PAT_ANCEST,
STRICT_SEQ TYPE PAT_STRICT,
NO_GEN TYPE PAT_NOGEN,
SPAMFIX TYPE  PAT_SPAMFX,
ADDON_ID TYPE ADDONID,
ADDON_REL TYPE  ADDONRL,
IGN_CONFLI TYPE IGN_CONFLI,
AP_ANCEST TYPE AP_ANCEST,
EPSFILSIZ TYPE  PATFILSIZ,
HI_ANCEST TYPE  PAT_HIAN,
COMP_REL TYPE PAT_COREL,
COMPONENT TYPE  PAT_COMP,
END OF TY_SYST_PAT03,
TY_SYST_PAT03_T TYPE STANDARD TABLE OF TY_SYST_PAT03.

TYPES : BEGIN OF TY_SYST_PAT03_OUT,
SYSTEMNAME TYPE  CHAR8,"SMSY_NAME,
PATCH TYPE PATCH,
SHORT_TEXT TYPE  PATCHTXT,
STATUS TYPE  PATCHSTAT,
DELIV_DATE TYPE  PATDELDATE,
DELIV_TIME TYPE  PATDELTIME,
RESPONSIBL TYPE  PATCH_USER,
IMPLE_DATE TYPE  PATIMPDATE,
IMPLE_TIME TYPE  PATIMPTIME,
L_IMPL_REL TYPE  SYSAPRL,
CONFLICTS TYPE  PAT_CONFL,
CONFIRMED TYPE  CONFIRMED,
BACKUP TYPE  TRKORR,
FROM_REL TYPE  SYSAPRL,
TO_REL TYPE  SYSAPRL,
OS TYPE  SYOPSYS,
DB TYPE  SYDBSYS,
PATCH_TYPE TYPE  PATCH_TYPE,
ANCESTOR TYPE  PAT_ANCEST,
STRICT_SEQ TYPE  PAT_STRICT,
NO_GEN TYPE  PAT_NOGEN,
SPAMFIX TYPE  PAT_SPAMFX,
ADDON_ID TYPE  ADDONID,
ADDON_REL TYPE  ADDONRL,
IGN_CONFLI TYPE  IGN_CONFLI,
AP_ANCEST TYPE AP_ANCEST,
EPSFILSIZ TYPE  PATFILSIZ,
HI_ANCEST TYPE  PAT_HIAN,
COMP_REL TYPE  PAT_COREL,
COMPONENT TYPE  PAT_COMP,
END OF TY_SYST_PAT03_OUT,
TY_SYST_PAT03_OUT_T TYPE STANDARD TABLE OF TY_SYST_PAT03_OUT.

* OSS
TYPES : BEGIN OF AISYSNR_BUFFER_STRUCTURE,
SID TYPE CHAR3,"aisid,
INSNR TYPE CHAR10,"smsy_inst_nr,
SYNAM TYPE TEXT40,"aisynam,
SYTYP TYPE CHAR13,"aib0sdsytyp,
PRODVERS TYPE CHAR20,"smsyprodvers,
DELETED TYPE FLAG,
MESSAGESERVER TYPE  CHAR20,"smsy_hostname,
END OF AISYSNR_BUFFER_STRUCTURE.
TYPES : BEGIN OF AISYSNR_BUFFER,
SYSNR TYPE CHAR18,"aib0sdsysnr,
KONZS TYPE CHAR10,"obsolete
SID TYPE CHAR3,"aisid,
INSNR TYPE CHAR10,"smsy_inst_nr,
SYNAM TYPE TEXT40,"aisynam,
SYTYP TYPE CHAR13,"aib0sdsytyp,
PRODVERS TYPE CHAR20,"smsyprodvers,
DELETED TYPE FLAG,
MESSAGESERVER TYPE  CHAR20,"smsy_hostname,
END OF AISYSNR_BUFFER,
AISYSNR_BUFFER_T TYPE STANDARD TABLE OF AISYSNR_BUFFER.
* Products / Product version per system
TYPES : BEGIN OF SMSY_SYST_PRODVR,
SYSTEMNAME TYPE CHAR8,"SMSY_NAME,
PRODVERS TYPE CHAR20,"SMSYPRODVERS,
KONZS TYPE KONZS,
VERSION TYPE CHAR10,"SMSY_VERSION,
SYDATUM TYPE SYDATUM,
SYUZEIT TYPE SYUZEIT,
SYUNAME TYPE SYUNAME,
TRCODE  TYPE TCODE,
GENERATOR TYPE CHAR10,"SMSY_FLAG,
AKT_VERSION TYPE CHAR10,"SMSY_VERSION,
INSTANCE TYPE CHAR20,"SMSYINSTANCE,
FLG_USED TYPE CHAR1,"SMSY_FLG_ACTIVE,
MANUAL_SET TYPE CHAR1,"SMSY_PV_MANUAL_SET,
END OF SMSY_SYST_PRODVR,
SMSY_SYST_PRODVR_T TYPE STANDARD TABLE OF SMSY_SYST_PRODVR.
TYPES: BEGIN OF SMSY_PRODUCT,
PRODUCT TYPE CHAR20,"smsyproduct,
PRODUCTTXT TYPE CHAR30,"smsy_prodstxt,
NON_SAP_PRODUCT TYPE CHAR1,"smsy_yesno,
INVISIBLE TYPE CHAR1,"smsy_yesno,
LUSER TYPE SYUNAME,
LDATE TYPE SYDATUM,
LTIME TYPE SYUZEIT,
FL_ADDON TYPE CHAR1,"aisolar_bormflpaddon,
MANUFACTURER TYPE CHAR32,"smsy_manufacturer,
END OF SMSY_PRODUCT,
SMSY_PRODUCT_T TYPE STANDARD TABLE OF SMSY_PRODUCT.
TYPES: BEGIN OF SMSY_PROD_VERS,
PRODUCTVERSION  TYPE CHAR20,"smsyprodvers,
PRODUCT TYPE CHAR20,"smsyproduct,
PREPRODVERS TYPE CHAR20,"smsyprodvers,
PRODVERSTXT TYPE CHAR30,"smsy_prodvrsstxt,
FL_ADDON  TYPE CHAR1,"aisolar_bormflpvaddon,
END OF SMSY_PROD_VERS,
SMSY_PROD_VERS_T TYPE STANDARD TABLE OF SMSY_PROD_VERS.
TYPES: BEGIN OF SM_SYSTEM_PRODUCTS,
SYSTEMNAME TYPE CHAR8,"SMSY_NAME
PRODUCT    TYPE CHAR20,"SMSYPRODUCT
PRODUCTTXT TYPE CHAR30,"SMSY_PRODSTXT
PRODVERS   TYPE CHAR20,"SMSYPRODVERS
PRODVERSTXT TYPE CHAR30,"SMSY_PRODVRSSTXT
END OF SM_SYSTEM_PRODUCTS,
SM_SYSTEM_PRODUCTS_T TYPE STANDARD TABLE OF SM_SYSTEM_PRODUCTS.
TYPES: BEGIN OF SM_PROJECT_TYPE,
PROJECT_ID TYPE CHAR10,
CLASS TYPE CHAR6,
BEGIN_DATE LIKE SY-DATUM,
END_DATE LIKE SY-DATUM,
GUID TYPE HIER_GUID,
END OF SM_PROJECT_TYPE.
TYPES: BEGIN OF SM_PROJECT_TREE,
TREE_ID TYPE CHAR32,
EXTENSION TYPE CHAR15,
NODE_ID  TYPE CHAR32,
EXT_KEY  TYPE CHAR12,
END OF SM_PROJECT_TREE.
TYPES: BEGIN OF SM_PROJECT_TREE_NODE,
NODE_ID TYPE CHAR32,"HIER_GUID
NODE_TYPE TYPE CHAR4,"HIER_NODET
NODE_LEVEL TYPE NUMC4,"SEU_LEVEL
PARENT_ID TYPE CHAR32,"HIER_GUID
TREE_ID TYPE CHAR32,"HIER_GUID
REFNODE_ID TYPE CHAR32,"HIER_GUID
END OF SM_PROJECT_TREE_NODE.
TYPES: BEGIN OF SM_AGS_TBOM_HEAD,
GUID TYPE CHAR32, "AGS_TBOM_GUID
DESCRIPTION TYPE CHAR255, "AGS_TBOM_DESCRIPTION
DYNAMIC	TYPE CHAR1, "AGS_TBOM_TYPE_DYNAMIC
E2ETRACE TYPE CHAR1, "AGS_TBOM_TYPE_E2ETRACE
STATIC TYPE CHAR1, "AGS_TBOM_TYPE_STATIC
STATUS TYPE CHAR1, "AGS_TBOM_STATUS
ORIG_SYS TYPE CHAR8, "SYSYSID
ORIG_CLIENT TYPE CHAR3, "TRCLIENT
CREATEDBY TYPE CHAR12, "HIER_FUSER
CREATEDATE TYPE SYDATUM, "HIER_FDATE
CREATETIME TYPE SYUZEIT, "HIER_FTIME
UPDATEDBY TYPE CHAR12, "HIER_LUSER
UPDATEDATE TYPE SYDATUM, "HIER_LDATE
UPDATETIME TYPE SYUZEIT, "HIER_LTIME
END OF SM_AGS_TBOM_HEAD,
SM_AGS_TBOM_HEAD_TAB TYPE TABLE OF SM_AGS_TBOM_HEAD.

TYPES: BEGIN OF SM_AGS_TBOM_BASE,
GUID TYPE CHAR32,  "AGS_TBOM_GUID
AS4POS TYPE DDPOSITION,
PGMID TYPE CHAR4,  "PGMID
OBJECT TYPE CHAR4, "TROBJTYPE
OBJ_NAME TYPE CHAR120, "TROBJ_NAME
OBJ_SOURCE	TYPE CHAR1, "FLAG
OBJ_CLASS_TYPE TYPE CHAR4, "AGS_TBOM_ITEM_CLASS_TYPE
OBJ_CLASS_VALUE TYPE CHAR8, "AGS_TBOM_ITEM_CLASS_VALUE
DEVCLASS TYPE CHAR30, "DEVCLASS
DLVUNIT TYPE CHAR30, "DLVUNIT
PARENT_PGMID TYPE CHAR4,"PGMID
PARENT_OBJECT TYPE CHAR4,"TROBJTYPE
PARENT_OBJ_NAME TYPE CHAR120,"TROBJ_NAME
SUB_OBJ_NAME(130) TYPE C,"AGS_TROBJNAME
TAB_HAS_KEY TYPE CHAR1,"AGS_TBOM_TAB_HAS
END OF SM_AGS_TBOM_BASE,
SM_AGS_TBOM_BASE_TAB TYPE TABLE OF SM_AGS_TBOM_BASE,

BEGIN OF SM_DFURLS,
NODE_ID  TYPE CHAR32,"HIER_GUID
URL_TYPE	TYPE CHAR20,"URLTYPE
URL  TYPE CHAR255,"AGR_URL
PRED_ID  TYPE CHAR32,"HIER_GUID
END OF SM_DFURLS.

TYPES: BEGIN OF UVERS_HIST_REC_TYPE,
FINDATE    TYPE SYDATUM,
FINTIME    TYPE SYUZEIT,
COMPONENT  TYPE CHAR30, "DLVUNIT
NEWRELEASE TYPE CHAR10, "SAPRELEASE
STARTDATE  TYPE SYDATUM,
STARTTIME  TYPE SYUZEIT,
ENDDATE    TYPE SYDATUM,
ENDTIME    TYPE SYUZEIT,
PUTSTATUS  TYPE CHAR1, "PUTSTATUS
PUTTYPE    TYPE CHAR1, "PUTTYPE
PUTMASTER  TYPE CHAR10,                           "PUTMODE10

OLDRELEASE TYPE CHAR10, "SAPRELEASE
MODEA01    TYPE CHAR1,                            "PUTMODE01

MODEB01    TYPE CHAR1,                            "PUTMODE01

MODEA10    TYPE CHAR10,                           "PUTMODE10
END OF UVERS_HIST_REC_TYPE.

* BW extraction data types
TYPES: BEGIN OF TY_PROCESSLOG,
TYPE         TYPE CHAR10,"rspc_type,
EVENT_START  TYPE BTCEVENTID,
EVENTP_START TYPE BTCEVTPARM,
VARIANTE     TYPE CHAR30,"rspcprocesslog-variante,
BATCHDATE    TYPE SYDATS,"rspcprocesslog-batchdate,
BATCHTIME    TYPE SYTIME,"rspcprocesslog-batchtime,
INSTANCE     TYPE CHAR30,"rspcprocesslog-instance,
END OF TY_PROCESSLOG.

TYPES: BEGIN OF TY_RSLDPIO,
LOGDPID    TYPE CHAR30, "rsldpio-logdpid,
LOGSYS     TYPE LOGSYS, "rsldpio-logsys,
OLTPSOURCE TYPE CHAR30, "rsldpio-oltpsource,
END OF TY_RSLDPIO.

TYPES: BEGIN OF TY_RSISOSMAP,
ISOURCE    TYPE CHAR30, "rsisosmap-isource,
OLTPSOURCE TYPE CHAR30, "rsisosmap-oltpsource,
END OF TY_RSISOSMAP.

TYPES: BEGIN OF TY_RSTRAN,
TRANID     TYPE CHAR32,    "rstran-tranid,
SOURCETYPE TYPE CHAR4,     "rstran-sourcetype,
SOURCENAME TYPE SOBJ_NAME, "rstran-sourcename,
TARGETTYPE TYPE CHAR4,     "rstran-targettype,
TARGETNAME TYPE SOBJ_NAME, "rstran-targetname,
END OF TY_RSTRAN.

TYPES: BEGIN OF TY_RSUPDINFO,
UPDID    TYPE CHAR25, "rsupdid,
INFOCUBE TYPE CHAR30, "rsupdinfo-infocube,
ISOURCE  TYPE CHAR30, "rsupdinfo-isource,
END OF TY_RSUPDINFO.

TYPES: BEGIN OF TY_RSOLTPSOURCE,
OLTPSOURCE TYPE CHAR30, "rsoltpsource-oltpsource,
END OF TY_RSOLTPSOURCE.

TYPES: BEGIN OF TY_RSDS,
DATASOURCE TYPE CHAR30, "rsds-datasource,
END OF TY_RSDS.

TYPES: BEGIN OF TY_RSDCUBE,
INFOAREA TYPE CHAR30,    "rsdcube-infoarea,
INFOCUBE TYPE CHAR30,    "rsdcube-infocube,
TSTPNM   TYPE XUBNAME,   "rsdcube-tstpnm,
TIMESTMP TYPE CHAR15,    "rstimestmp,"rsdcube-timestmp,
END OF TY_RSDCUBE.

TYPES: BEGIN OF TY_RSDCUBE_TXT,
LANGU    TYPE LANGU,
INFOCUBE TYPE CHAR30,  "rsdcubet-infocube,
TXTLG    TYPE TEXT60,
END OF TY_RSDCUBE_TXT.

TYPES: BEGIN OF TY_RSDIOBJ,
IOBJNM   TYPE CHAR30,  "rsdiobj-iobjnm,
TSTPNM   TYPE XUBNAME,
TIMESTMP TYPE CHAR15,  "rstimestmp,
END OF TY_RSDIOBJ.

TYPES: BEGIN OF TY_RSDIOBJ_TXT,
LANGU  TYPE LANGU,
IOBJNM TYPE CHAR30,
TXTLG  TYPE TEXT60,
END OF TY_RSDIOBJ_TXT.

TYPES: BEGIN OF TY_RSDODSO,
ODSOBJECT TYPE CHAR30, "rsdodso-odsobject,
ODSOTYPE  TYPE CHAR1,  "rsdodso-odsotype,
INFOAREA  TYPE CHAR30, "rsdodso-infoarea,
TSTPNM    TYPE XUBNAME,
TIMESTMP  TYPE CHAR15, "rstimestmp,
END OF TY_RSDODSO.

TYPES: BEGIN OF TY_RSDODSO_TXT,
ODSOBJECT TYPE CHAR30, "rsdodsot-odsobject,
LANGU     TYPE LANGU,
TXTLG     TYPE TEXT60,
END OF TY_RSDODSO_TXT.

TYPES: BEGIN OF TY_RSPCCHAINATTR,
CHAIN_ID       TYPE CHAR25,    "rspcchainattr-chain_id,
APPLNM         TYPE CHAR30,    "rspcchainattr-applnm,
OBJNM_OWNED_BY TYPE SOBJ_NAME, "rspcchainattr-objnm_owned_by,
END OF TY_RSPCCHAINATTR.

TYPES: BEGIN OF TY_RSPCCHAINT,
LANGU     TYPE  SPRAS,
CHAIN_ID  TYPE  CHAR25,
TXTLG     TYPE  TEXT60,
END OF TY_RSPCCHAINT.

TYPES: BEGIN OF TY_RSBKDTP,
DTP      TYPE CHAR30, "rsbkdtp-dtp,
SRC      TYPE CHAR45, "rsbkdtp-src,
SRCTP    TYPE CHAR6,  "rsbkdtp-srctp,
SRCTLOGO TYPE CHAR4,  "rsbkdtp-srctlogo,
TGT      TYPE CHAR45, "rsbkdtp-tgt,
TGTTP    TYPE CHAR6,  "rsbkdtp-tgttp,
TGTTLOGO TYPE CHAR4,  " rsbkdtp-src,
END OF TY_RSBKDTP.

TYPES: BEGIN OF TY_RSBKDTP_TXT,
LANGU TYPE LANGU,
DTP   TYPE CHAR30,     "rsbkdtpt-dtp,
TXTLG TYPE TEXT60,     "rsbkdtpt-txtlg,
END OF TY_RSBKDTP_TXT.

TYPES: BEGIN OF TY_AREA,
INFOAREA     TYPE CHAR30,   "rsdarea-infoarea,
OWNER        TYPE XUBNAME,  "rsdarea-owner,
INFOAREA_P   TYPE CHAR30,   "rsdarea-infoarea_p ,
INFOAREA_C   TYPE CHAR30,   "rsdarea-infoarea_c,
INFOAREA_N   TYPE CHAR30,   "rsdarea-infoarea_n,
TSTPNM       TYPE XUBNAME,  "rsdarea-tstpnm,
TIMESTMP     TYPE CHAR15,
END OF TY_AREA.

TYPES: BEGIN OF TY_AREA_TXT,
LANGU    TYPE LANGU,
INFOAREA TYPE CHAR30,      "rsdareat-infoarea,
TXTLG    TYPE TEXT60,      "rsdareat-txtlg,
END OF TY_AREA_TXT.

TYPES: BEGIN OF TY_RSPCCHAIN,
CHAIN_ID        TYPE  CHAR25,
OBJVERS         TYPE  CHAR1,
TYPE            TYPE  CHAR10,
VARIANTE        TYPE  CHAR30,
LNR             TYPE  CHAR10,
EVENT_START     TYPE  CHAR32,
EVENTP_START    TYPE  CHAR64,
EVENTNO_START   TYPE  CHAR2,
BACKLINK_START  TYPE  CHAR1,
EVENT_GREEN     TYPE  CHAR32,
EVENTP_GREEN    TYPE  CHAR64,
BACKLINK_GREEN  TYPE  CHAR1,
EVENT_RED       TYPE  CHAR32,
EVENTP_RED      TYPE  CHAR64,
BACKLINK_RED    TYPE  CHAR1,
GREEN_EQ_RED    TYPE  CHAR1,
WAIT            TYPE  CHAR10,
MAIL_AT_RED     TYPE  CHAR30,
MAIL_AT_GREEN   TYPE  CHAR30,
END OF TY_RSPCCHAIN.

TYPES: BEGIN OF TY_RSPCCHAIN_OUT,
CHAIN_ID        TYPE  CHAR25,
OBJVERS         TYPE  CHAR1,
TYPE            TYPE  CHAR10,
VARIANTE        TYPE  CHAR30,
LNR             TYPE  CHAR10,
EVENT_START     TYPE  CHAR32,
EVENTP_START    TYPE  CHAR64,
EVENTNO_START   TYPE  CHAR2,
BACKLINK_START  TYPE  CHAR1,
EVENT_GREEN     TYPE  CHAR32,
EVENTP_GREEN    TYPE  CHAR64,
BACKLINK_GREEN  TYPE  CHAR1,
EVENT_RED       TYPE  CHAR32,
EVENTP_RED      TYPE  CHAR64,
BACKLINK_RED    TYPE  CHAR1,
GREEN_EQ_RED    TYPE  CHAR1,
WAIT            TYPE  CHAR10,
MAIL_AT_RED     TYPE  CHAR30,
MAIL_AT_GREEN   TYPE  CHAR30,
FIRST_USED_DATE TYPE  CHAR8,
FIRST_USED_TIME TYPE  CHAR6,
LAST_USED_DATE  TYPE  CHAR8,
LAST_USED_TIME  TYPE  CHAR6,
COUNT(10)        TYPE  N,
END OF TY_RSPCCHAIN_OUT.

TYPES: BEGIN OF TY_TDEVC,
DEVCLASS         TYPE   DEVCLASS,                 "  CHAR 30
INTSYS           TYPE   INTSYS_OLD,               "  CHAR 10
CONSYS           TYPE   CONSYS_OLD,               "  CHAR 10
CTEXT            TYPE   AS4TEXTOLD,               "  CHAR  60
KORRFLAG         TYPE   KORRFLAG,                 "  CHAR 1
AS4USER          TYPE   AUTHOR3,                  "  CHAR 12
PDEVCLASS        TYPE   DEVLAYER,                 "  CHAR 4
DLVUNIT          TYPE   DLVUNIT,                  "  CHAR 30
COMPONENT        TYPE   UFFCTR,                   "  CHAR 20
NAMESPACE        TYPE   NAMESPACE,                "  CHAR 10
TPCLASS          TYPE   TPCLASS,                  "  CHAR 1
SHIPMENT         TYPE   SHIPMENT,                 "  CHAR 8
PARENTCL         TYPE   PARENTCL,                 "  CHAR 30
APPLICAT         TYPE   TRDEVCAPPL,               "  CHAR 2
ERRSEVRTY        TYPE   ERRSEVRTY,                "  CHAR 4
PERMINHER        TYPE   PERMINHER,                "  CHAR 1
INTFPREFX        TYPE   INTFPREFX,                "  CHAR 6
PACKTYPE         TYPE   PACKTYPE,                 "  CHAR 1
RESTRICTED       TYPE   PACKRESTR,                "  CHAR 1
MAINPACK         TYPE   MAINPACK,                 "  CHAR 1
CREATED_BY       TYPE   CNAM,                     "  CHAR 12
CREATED_ON       TYPE   RDIR_CDATE,               "  DATS 8
CHANGED_BY       TYPE   UNAM,                     "  CHAR 12
CHANGED_ON       TYPE   RDIR_UDATE,               "  DATS 8
SRV_CHECK        TYPE   CHAR1,                    "  CHAR 1
CLI_CHECK        TYPE   CHAR1,                    "  CHAR 1
EXT_ALIAS        TYPE   CHAR6,                    "  CHAR 6
PROJECT_GUID     TYPE   CHAR32,
"PAK_PROJECT_GUID,   "  RAW 16
PROJECT_PASSDOWN TYPE   CHAR1,                    "  CHAR  1
END OF TY_TDEVC.

TYPES: BEGIN OF TY_ABAPTXT255,
LINE TYPE TEXT255,
END OF TY_ABAPTXT255.

TYPES: BEGIN OF TY_RSDCHABAS,
CHABASNM  TYPE CHAR30, "rsdchabas-chabasnm,
INFOAREA  TYPE CHAR30, "rsdchabas-infoarea,
APPLNM    TYPE CHAR30, "rsdchabas-applnm,
END OF TY_RSDCHABAS.

TYPES: TT_OPTIONS   TYPE TABLE OF RFC_DB_OPT,
TT_FIELDS    TYPE TABLE OF RFC_DB_FLD,
TT_ANY_TABLE TYPE TABLE OF TAB512.

* Usage record type
TYPES: BEGIN OF TY_RECORD,
PERIOD     TYPE CHAR6,
TYPE       TYPE CHAR1,
TCODE      TYPE CHAR255, "SAPWLPFNRM-REPORT,
USER       TYPE SAPWLUTACC,
REMOT_DEST TYPE SAPWLRFCS-REMOT_DEST,
JOBNAME    TYPE SY-CPROG,
USAGE      TYPE P,
END OF TY_RECORD,

TT_RECORD TYPE TABLE OF TY_RECORD.

* Usage callers record for proxies/idocs
TYPES: BEGIN OF TY_USAGE_CALLER,
CALLER(100) TYPE C,
COUNT TYPE I,
LAST_USED TYPE DATUM,
END OF TY_USAGE_CALLER,

TT_USAGE_CALLER TYPE TABLE OF TY_USAGE_CALLER.

*---------------------------------------------------------------------*
*  Global Data definition
*---------------------------------------------------------------------*
TABLES: TDEVC, TRDIR, TADIR.

DATA: ACTIVE_INDUSTRY_SOLUTION(30) TYPE C VALUE SPACE.

DATA: G_SAPWORKDIR        TYPE SDOK_CHTRD,
G_FILESIZE          TYPE I,
G_IREF_ROOT_ELEM    TYPE REF TO IF_IXML_ELEMENT,
G_IREF_PIXML        TYPE REF TO IF_IXML,
G_IREF_PDOCUMENT    TYPE REF TO IF_IXML_DOCUMENT,
G_IREF_PSTREAMFACTORY TYPE REF TO IF_IXML_STREAM_FACTORY,
GT_CONVERTED_DATA   TYPE XML_TAB_TYPE,
G_FILE_APPEND_MODE  TYPE CHAR01 VALUE SPACE,
G_OSTREAM           TYPE REF TO IF_IXML_OSTREAM,
G_BUFFER_ITAB       TYPE XML_TAB_TYPE,
G_STRX              TYPE XSTRING,
GV_TABIX            TYPE SY-TABIX,
G_PROGS_ADDED_BY_SMODILOG TYPE PROG_TAB_TYPE WITH HEADER LINE,
G_VANILLA_PROGRAMS  TYPE VANILLA_PROG_TAB_TYPE WITH HEADER LINE,
NEW_LINE            TYPE STRING,
CURR_OBJECT_TYPE    TYPE I,
PERCENTAGE          TYPE P DECIMALS 2,
OBJ_PERC            TYPE P DECIMALS 2,
SAPWORKDIR          TYPE SDOK_CHTRD,
NEW_SAPWORKDIR      TYPE SDOK_CHTRD,
FILENAME            LIKE RLGRAP-FILENAME,
NAMESPACES          TYPE TABLE OF TRNSPACET,
NAMESPACE           LIKE LINE OF NAMESPACES,
STAT_EXCLUDE        TYPE TABLE OF SY-UCOMM,
ERROR(20)           TYPE C,
PAC_SIZE            TYPE I.

DATA: SEL_FILENAME      TYPE STRING,
PATH              TYPE STRING,
FULLPATH(128)     TYPE C,
INITIAL_DIRECTORY TYPE STRING,
DEFAULT_EXTENSION TYPE STRING,
DEFAULT_FILENAME  TYPE STRING,
FILE_FILTER       TYPE STRING,
USER_ACTION       TYPE I,
NO_USAGE.

* Development Class Objects list
DATA: GT_TADIR        TYPE TABLE OF TADIR,
GS_TADIR        LIKE LINE OF GT_TADIR,
GS_OBJECTLIST   TYPE RSEUI_SET,
GT_OBJ_FUNC     TYPE TABLE OF RSEUI_SET,
GT_OBJ_PROG     TYPE TABLE OF RSEUI_SET,
GT_OBJ_TYPEPOOL TYPE TABLE OF RSEUI_SET,
GT_OBJ_TRNS     TYPE TABLE OF RSEUI_SET,
GT_OBJ_LGDB     TYPE TABLE OF RSEUI_SET,
GT_OBJ_MESG     TYPE TABLE OF RSEUI_SET,
GT_OBJ_TABL     TYPE TABLE OF RSEUI_SET,
GT_OBJ_VIEW     TYPE TABLE OF RSEUI_SET,
GT_OBJ_DELM     TYPE TABLE OF RSEUI_SET,
GT_OBJ_CTAB     TYPE TABLE OF RSEUI_SET,
GT_OBJ_TTYP     TYPE TABLE OF RSEUI_SET,
GT_OBJ_DOMN     TYPE TABLE OF RSEUI_SET,
GT_OBJ_TYPE     TYPE TABLE OF RSEUI_SET,
GT_OBJ_CLAS     TYPE TABLE OF RSEUI_SET,
GT_OBJ_APPL     TYPE TABLE OF RSEUI_SET,
GT_OBJ_UEXT     TYPE TABLE OF RSEUI_SET,
GT_OBJ_SSFO     TYPE TABLE OF RSEUI_SET,
GT_OBJ_FORM     TYPE TABLE OF RSEUI_SET,
GT_OBJ_OSOA_D   TYPE TABLE OF RSEUI_SET,
GT_OBJ_SHI3     TYPE TABLE OF RSEUI_SET,
GT_OBJ_SXCI     TYPE TABLE OF RSEUI_SET,
GT_OBJ_WEBI     TYPE TABLE OF RSEUI_SET,
GT_ETL_MESSAGE  TYPE TABLE OF ETL_MESSAGE_TYPE WITH HEADER LINE,
GT_ETL_JOBLOG   TYPE TABLE OF ETL_MESSAGE_TYPE WITH HEADER LINE,
*     Messages from selection screen are saved in GT_SCR_MESSAGE and
*     appended to GT_ETL_MESSAGE because in START-OF-SELECTION we clean
*     up GT_ETL_MESSAGE and we want to keep the messages added in
*     AT SELECTION-SCREEN events.
GT_SCR_MESSAGE  TYPE TABLE OF ETL_MESSAGE_TYPE WITH HEADER LINE,
GT_ETL_TIME_STAT TYPE TABLE OF ETL_TIME_STATS_TYPE WITH HEADER
LINE,
GT_MODIF        TYPE TABLE OF SMODILOG WITH HEADER LINE,
MODIFIED_OBJECTS TYPE TABLE OF MODIFIED_OBJECT WITH HEADER LINE,
ABAP_QUERY_PROGS TYPE TABLE OF RSEUI_SET WITH HEADER LINE,
L_FILENAME      TYPE STRING,
FILE_EXISTS(1)   TYPE C,
LEN              TYPE I,
FILE_LEN         TYPE I,
STARTTIME        TYPE AS4TIME,
RFC_SYSID        TYPE SYSYSID,
RFC_SAPRL        TYPE SYSAPRL,
SM_SYSID         TYPE SYSYSID,
SM_SAPRL         TYPE SYSAPRL,
SERVERS          TYPE TABLE OF MSXXLIST,
TEMP_FILENAME    TYPE RLGRAP-FILENAME,
TEMP_FORE_FILENAME TYPE STRING,
TEMP_BACK_FILENAME  LIKE RLGRAP-FILENAME,
SUCC_MESS        TYPE STRING,
LAST_CHAR        TYPE C,
ERROR_MSG        TYPE STRING,
GT_RFCS          TYPE STANDARD TABLE OF RFCDISPLAY.

DATA: LT_TDEVC   TYPE TABLE OF TDEVC,
LS_TDEVC   TYPE TDEVC,
LT_TDEVCT  TYPE TABLE OF TDEVCT,
L_STARTTIME LIKE SY-UZEIT.

DATA: ANSWER(1)  TYPE C,
QUESTION   TYPE STRING,
RFC_DATA LIKE RFCSI,
RFC_MANDT LIKE RFCDISPLAY-RFCCLIENT,
SYSTEM_SEPERATOR TYPE C,
GC_SM_RFC LIKE RFCDES-RFCDEST,
GV_BW_RFC LIKE RFCDES-RFCDEST VALUE 'PANAYA_BW',
GV_LOGSYS TYPE LOGSYS.

DATA: GT_BTE_UE TYPE TABLE OF T_BTE_UE.

DATA: G_EXTRACT_UPL.

DATA: G_IS_EHP7 TYPE FLAG VALUE SPACE.

DATA: GT_NEXT_ORDER(5)       TYPE N VALUE 0.
DATA: GT_NEXT_ORDER_JOBLOG(5)       TYPE N VALUE 0.

RANGES: CUSTOMER_OBJECTS FOR DD03L-PRECFIELD,
CUST_NAMESPACE_RNG FOR TADIR-OBJ_NAME,
G_APP_STRUC FOR TADIR-OBJ_NAME,
G_INC_STRUC FOR TADIR-OBJ_NAME,
G_VIEW_WITH_AST FOR TADIR-OBJ_NAME,
EXCL_NAMESPACES FOR TDEVC-NAMESPACE,
THIRD_PARTY_NS FOR TDEVC-NAMESPACE,
G_CUST_PROGS FOR TRDIR-NAME,
G_TABNAME_INDEX FOR DD02L-TABNAME.

*---------------------------------------------------------------------*
*   Selection Screen
*---------------------------------------------------------------------*
* Objects
SELECTION-SCREEN BEGIN OF BLOCK B1 WITH FRAME TITLE TIT1.

* XML File type
SELECTION-SCREEN BEGIN OF BLOCK B2 WITH FRAME TITLE TITL2.

* Local file
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(12) TIT_FILE.
SELECTION-SCREEN POSITION 27.
PARAMETERS  P_FILEN(128) TYPE C.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  R_FORE  RADIOBUTTON GROUP RAD2  USER-COMMAND FTYP
DEFAULT 'X'.
SELECTION-SCREEN COMMENT 4(21) TIT_FORE.
SELECTION-SCREEN POSITION 27.
PARAMETERS  P_FORE(128) TYPE C  MODIF ID LCL.
SELECTION-SCREEN END OF LINE.
* Server file
SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  R_BACK  RADIOBUTTON GROUP RAD2.

SELECTION-SCREEN COMMENT 4(21) TIT_BACK.
SELECTION-SCREEN POSITION 27.
PARAMETERS  P_BACK  LIKE RLGRAP-FILENAME  MODIF ID SRV.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK B2.

* RFC destination
SELECTION-SCREEN BEGIN OF BLOCK B3 WITH FRAME TITLE TITL3.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 1(50) TEXT1 .
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(40) TEXT2 .
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(15) TEXT0 FOR FIELD P_RFCDES.
PARAMETERS: P_RFCDES LIKE RFCDES-RFCDEST DEFAULT 'PANAYA_PRD'
*OBLIGATORY
.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN END OF BLOCK B3.

* System's Roles
SELECTION-SCREEN BEGIN OF BLOCK B7 WITH FRAME TITLE TITL7.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(22) TEXT7 FOR FIELD P_ROLE MODIF ID TRL.
PARAMETERS: P_ROLE(18) AS LISTBOX VISIBLE LENGTH 18 OBLIGATORY
MODIF ID TRL.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(22) TEXT8 FOR FIELD P_TRROLE MODIF ID TRL.
PARAMETERS: P_TRROLE(18) AS LISTBOX VISIBLE LENGTH 18 OBLIGATORY
MODIF ID TRL.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN END OF BLOCK B7.

* SolMan RFC destination
SELECTION-SCREEN BEGIN OF BLOCK B5 WITH FRAME TITLE TITL5.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(51) TEXT3 .
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(15) TEXT4 FOR FIELD P_SM_RFC.
PARAMETERS: P_SM_RFC LIKE RFCDES-RFCDEST DEFAULT GC_SM_RFC OBLIGATORY.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN END OF BLOCK B5.

* BW RFC destination
SELECTION-SCREEN BEGIN OF BLOCK B6 WITH FRAME TITLE TITL6.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(51) TEXT5 .
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(15) TEXT6 FOR FIELD P_BW_RFC.
PARAMETERS: P_BW_RFC LIKE RFCDES-RFCDEST DEFAULT GV_BW_RFC.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN END OF BLOCK B6.

* Usage only
SELECTION-SCREEN BEGIN OF BLOCK B4 WITH FRAME TITLE TITL4.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS: USAGEONL AS CHECKBOX DEFAULT ' '.
SELECTION-SCREEN COMMENT 4(12) TIT_US.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN END OF BLOCK B4.

SELECT-OPTIONS: DEVCLASS FOR TDEVC-DEVCLASS.
PARAMETERS: VANILLA AS CHECKBOX DEFAULT ''.
PARAMETERS: FIRSTBLK AS CHECKBOX DEFAULT ''.
PARAMETERS: POPUP_OK AS CHECKBOX DEFAULT 'X'.

SELECTION-SCREEN END   OF BLOCK B1.

*---------------------------------------------------------------------*
*   LOAD-OF-PROGRAM
*---------------------------------------------------------------------*
LOAD-OF-PROGRAM.
DATA : LT_RFCDES TYPE STANDARD TABLE OF RFCDES,
LS_RFCDES LIKE LINE OF LT_RFCDES,
LV_VALID  TYPE FLAG.

* Get SM connection
SELECT *
FROM RFCDES BYPASSING BUFFER
INTO CORRESPONDING FIELDS OF TABLE LT_RFCDES
WHERE
RFCTYPE = '3' AND
RFCDEST = 'PANAYA_SM'.

* Set first valid connection as default
LOOP AT LT_RFCDES INTO LS_RFCDES.
PERFORM CHECK_SM_RFC_DEST
USING LS_RFCDES-RFCDEST
ABAP_TRUE" Validate
CHANGING LV_VALID.

IF NOT LV_VALID IS INITIAL.
GC_SM_RFC = LS_RFCDES-RFCDEST.
EXIT.
ENDIF.
ENDLOOP.

* Check BW Tables Availability
PERFORM CHECK_BW_RFC_DEST  USING GV_BW_RFC
ABAP_TRUE" Validate
CHANGING LV_VALID.
IF LV_VALID IS INITIAL.
CLEAR GV_BW_RFC.
ENDIF.
*---------------------------------------------------------------------*
*   AT SELECTION-SCREEN
*---------------------------------------------------------------------*
AT SELECTION-SCREEN.

* Check if the ETL version matches the current system version
PERFORM CHECK_ETL_VERSION.

* Check if the current client is not '000'
IF SY-MANDT = '000'.
MESSAGE E208(00) WITH
'The program cannot be executed in client 000.'.
ENDIF.

* Check that the user has authorizations to read sources
PERFORM TEST_AUTH_READ_SOURCE USING 'SAPLS38E'
'NONE'
''.

* Prepare the popup screen texts.
PERFORM CREATE_POPUP_TEXT CHANGING QUESTION.
IF SY-UCOMM = 'SJOB' .

CALL FUNCTION 'POPUP_TO_CONFIRM'
EXPORTING
*       TITLEBAR                    = ' '
TEXT_QUESTION               = QUESTION
DISPLAY_CANCEL_BUTTON       = ' '
IMPORTING
ANSWER                      = ANSWER.

IF ANSWER = '2'.
*      clearing this field couses the program to cancel the
*      "execute in backround" action
CLEAR SSCRFIELDS-UCOMM.
ENDIF.

ENDIF.

* Check that this is not ehp7 system and the user tried to run it in
* foreground
IF NOT G_IS_EHP7 IS INITIAL AND NOT R_FORE IS INITIAL.
*   First of all deactivate the exectute in background option
APPEND 'SJOB' TO STAT_EXCLUDE.
CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
EXPORTING
P_STATUS  = SY-PFKEY
TABLES
P_EXCLUDE = STAT_EXCLUDE.

MESSAGE E208(00) WITH
'In EHP7 system, please run the ETL only in background mode'.
ENDIF.

* Local file checks
* -----------------
IF NOT R_FORE IS INITIAL AND SY-UCOMM NE 'FTYP'
AND SY-BATCH IS INITIAL.
IF P_FORE IS INITIAL.
MESSAGE E003(HRPAYIEPAYROLL).
ELSE.

PERFORM BUILD_LOCAL_FILE_NAME USING P_FILEN
CHANGING  P_FORE
FULLPATH.

PERFORM CHECK_FILENAME USING FULLPATH.

L_FILENAME = FULLPATH.

CLEAR FILE_EXISTS.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_EXIST
EXPORTING
FILE   = L_FILENAME
RECEIVING
RESULT = FILE_EXISTS
EXCEPTIONS
OTHERS = 4.

IF SY-SUBRC = 0.
IF FILE_EXISTS = 'X' AND PANAYA_TEST_MODE IS INITIAL.
MESSAGE W000(26) WITH
'File already exists and will be overridden'.
ENDIF.
ELSE.
MESSAGE E503(0U) WITH P_FORE.
ENDIF.
ENDIF.
ENDIF.

* Server file checks
* ------------------
IF NOT R_BACK IS INITIAL AND SY-UCOMM NE 'FTYP'.
*       AND SY-UCOMM NE SPACE.

*     Save the value of the screen field.
PATH = P_BACK.
*     Create the full file name.
CONCATENATE P_BACK FILENAME INTO FULLPATH.
PERFORM CHECK_FILENAME USING FULLPATH.


*     Check if the file already exists
OPEN DATASET FULLPATH FOR INPUT IN BINARY MODE.
IF SY-SUBRC = 8.
*       The file doesn't exist, Open the file for writing
OPEN DATASET FULLPATH FOR OUTPUT IN BINARY MODE.
IF NOT SY-SUBRC IS INITIAL.
CLOSE DATASET P_BACK.
MESSAGE E502(0U) WITH FULLPATH.
ENDIF.
CLOSE DATASET FULLPATH.

*       Delete the file after opening it
DELETE DATASET FULLPATH.

ELSE.
CLOSE DATASET FULLPATH.
MESSAGE W000(26) WITH
'File already exists and will be overridden'.
ENDIF.

IF SY-UCOMM = 'ONLI' AND SY-BATCH IS INITIAL AND
PANAYA_TEST_MODE IS INITIAL.
MESSAGE E000(26) WITH
'Please select background execution mode (F9)'.
ENDIF.
ENDIF.

* activate 'Execute in background' only what foreground mode is active
IF R_FORE = 'X'.
APPEND 'SJOB' TO STAT_EXCLUDE.
ELSEIF R_BACK = 'X'.
CLEAR STAT_EXCLUDE.
ENDIF.
CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
EXPORTING
P_STATUS  = SY-PFKEY
TABLES
P_EXCLUDE = STAT_EXCLUDE.

AT SELECTION-SCREEN ON P_FORE.
IF NOT R_FORE IS INITIAL AND SY-UCOMM NE 'FTYP'
AND SY-BATCH IS INITIAL.
PERFORM GET_LAST_CHAR USING P_FORE
CHANGING LAST_CHAR.

IF LAST_CHAR NE '\'.
ERROR_MSG = 'Directory must end with \'.
MESSAGE E208(00) WITH ERROR_MSG.
ENDIF.
IF P_FORE = '\'.
ERROR_MSG = 'Directory name must be entered'.
MESSAGE E208(00) WITH ERROR_MSG.
ENDIF.

ENDIF.

AT SELECTION-SCREEN ON P_BACK.
IF NOT R_BACK IS INITIAL AND SY-UCOMM NE 'FTYP'.
PERFORM GET_LAST_CHAR USING P_BACK
CHANGING LAST_CHAR.
IF NOT P_BACK IS INITIAL AND LAST_CHAR NE '/' AND LAST_CHAR NE '\'.
ERROR_MSG = 'Directory must end with \ or /'.
MESSAGE E208(00) WITH ERROR_MSG.
ENDIF.
ENDIF.

AT SELECTION-SCREEN ON P_RFCDES.
CLEAR :  GV_LOGSYS.
IF NOT P_RFCDES IS INITIAL.
*   Check RFC destination
PERFORM CHECK_RFC_DEST_EXISTANCE.
ELSE.
RFC_SYSID = SY-SYSID.
CALL FUNCTION 'PARTNER_LOGICAL_SYSTEM_GET'
IMPORTING
P_LOGSYS                       = GV_LOGSYS
EXCEPTIONS
OWN_LOGICAL_SYSTEM_NOT_DEFINED = 1
OTHERS                         = 2.
IF SY-SUBRC <> 0.
ENDIF.
CALL FUNCTION 'RFC_SYSTEM_INFO'
IMPORTING
RFCSI_EXPORT = RFC_DATA.
RFC_SYSID = RFC_DATA-RFCSYSID.
RFC_SAPRL = RFC_DATA-RFCSAPRL.
ENDIF.

AT SELECTION-SCREEN ON P_SM_RFC.
DATA : LV_FLAG TYPE FLAG.
* Check SM rfc destination
PERFORM CHECK_SM_RFC_DEST
USING P_SM_RFC
ABAP_FALSE" Message
CHANGING LV_FLAG.

AT SELECTION-SCREEN ON P_BW_RFC.
DATA : LV_FLAG TYPE FLAG.

GV_BW_RFC = P_BW_RFC.
* Check BW rfc destination
PERFORM CHECK_BW_RFC_DEST
USING GV_BW_RFC
ABAP_FALSE" Message
CHANGING LV_FLAG.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_FORE.
*------------------------------------------------
* Select local folder.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>DIRECTORY_BROWSE
EXPORTING
*      WINDOW_TITLE    =
INITIAL_FOLDER  = INITIAL_DIRECTORY
CHANGING
SELECTED_FOLDER = PATH
EXCEPTIONS
CNTL_ERROR      = 1
ERROR_NO_GUI    = 2
OTHERS          = 3
.

CALL METHOD CL_GUI_CFW=>FLUSH
EXCEPTIONS
CNTL_SYSTEM_ERROR = 1
CNTL_ERROR        = 2
OTHERS            = 3.

CHECK NOT PATH IS INITIAL.
* Create full file name including path.
PERFORM BUILD_LOCAL_FILE_NAME USING P_FILEN
CHANGING PATH
FULLPATH.

LEN = STRLEN( FULLPATH ).

* Check filename is not too long
IF LEN > 128.
MESSAGE I000(CONV) WITH 'The chosen file name too long.'
' Maximum length of the filename is 128 chars'.
ELSE.
INITIAL_DIRECTORY = PATH.
P_FORE = PATH.
ENDIF.

AT SELECTION-SCREEN OUTPUT.
*--------------------------
* In case of EHP7, set background to be turned on by default.
* In other cases - set foreground to be turned on by default
* ( only on the first time the screen is shown ).
IF G_IS_EHP7 = 'X'.
R_FORE = ' '.
R_BACK = 'X'.
ENDIF.

* Lock not relevant fields
LOOP AT SCREEN.

IF R_FORE IS INITIAL
AND SCREEN-NAME = 'P_FORE'.
SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '1'.
SCREEN-INVISIBLE = '1'.
MODIFY SCREEN.
ENDIF.
IF R_BACK IS INITIAL
AND SCREEN-NAME = 'P_BACK'.
SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '1'.
SCREEN-INVISIBLE = '1'.
MODIFY SCREEN.
ENDIF.
IF SCREEN-NAME = 'P_FILEN'.
SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '1'.
MODIFY SCREEN.
ENDIF.
IF SCREEN-NAME+0(8) = 'DEVCLASS'
OR SCREEN-NAME+0(10) = '%_DEVCLASS'
OR SCREEN-NAME = 'VANILLA'
OR SCREEN-NAME = 'FIRSTBLK'
OR SCREEN-NAME = 'POPUP_OK'.

SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '0'.
SCREEN-INVISIBLE = '1'.
SCREEN-ACTIVE = 0.
MODIFY SCREEN.
ENDIF.
IF SCREEN-NAME = 'P_SM_RFC'.
IF REQUIRE_SOLMAN_RFC = ''.
SCREEN-REQUIRED = '0'.
MODIFY SCREEN.
ENDIF.
ENDIF.

IF ( NOT IS_ON_TRIAL = 'X' ).
IF SCREEN-GROUP1 = 'TRL'.
SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '0'.
SCREEN-INVISIBLE = '1'.
SCREEN-ACTIVE = 0.
MODIFY SCREEN.
ENDIF.
ENDIF.
ENDLOOP.

*---------------------------------------------------------------------*
*   INITIALIZATION
*---------------------------------------------------------------------*
INITIALIZATION.

DATA: NAME  TYPE VRM_ID,
LIST  TYPE VRM_VALUES,
VALUE LIKE LINE OF LIST.

PERFORM IS_EHP7_SYSTEM CHANGING G_IS_EHP7.
*--------------
TIT1 = 'Panaya code extract tool'.
*  obj_name = 'Repository objects'.
TITL2 = 'Execution mode'.
TITL3 = 'Target system for Authorization Roles and Usage extraction'.
TITL4 = 'Execution mode'.
TITL5 = 'Solution Manager target system for Systems extraction'.
TITL6 = 'BW target system for BW extraction'.
TITL7 = 'Systems'' Roles in the Landscape'.
TIT_US = 'Usage only'.
TIT_FORE = 'Foreground Directory'.
TIT_BACK = 'Background Directory'.
TIT_FILE = 'File Name'.
TEXT0 = 'RFC destination'.
CONCATENATE ICON_MESSAGE_INFORMATION
'Please note that the RFC destination must'
INTO TEXT1 SEPARATED BY SPACE.                "#EC NOTEXT

*  TEXT1 = 'Please note that the RFC destination should'.
TEXT2 = 'always point to your Production system.'.
TEXT3 = 'RFC destination to Solution Manager system'.
TEXT4 = 'RFC Destination'.                                "#EC NOTEXT
TEXT5 = 'RFC Destination to BW system'.
TEXT6 = 'RFC Destination'.
TEXT7 = 'Current System''s Role'.
TEXT8 = 'Target System''s Role'.
CONCATENATE 'ETL_' SY-SYSID '_' SY-DATUM '_' SY-UZEIT '.xml'
INTO FILENAME.

FILE_FILTER = 'XML'.
DEFAULT_EXTENSION = 'XML'.
DEFAULT_FILENAME = FILENAME.
INITIAL_DIRECTORY = SAPWORKDIR.

PERFORM GET_SAPWORKDIR.

P_FILEN = FILENAME.
P_FORE = SAPWORKDIR.

* Set the default background filename
CALL FUNCTION 'FILE_GET_NAME_USING_PATH'
EXPORTING
LOGICAL_PATH               = 'TMP'
FILE_NAME                  = FILENAME
IMPORTING
FILE_NAME_WITH_PATH        = P_BACK
EXCEPTIONS
PATH_NOT_FOUND             = 1
MISSING_PARAMETER          = 2
OPERATING_SYSTEM_NOT_FOUND = 3
FILE_SYSTEM_NOT_FOUND      = 4
OTHERS                     = 5.

IF SY-SUBRC IS INITIAL.
*   Putting only the directory in the screen field, withou the filename.
*   If the directory is not empty.
IF ( P_BACK NE FILENAME ).
LEN = STRLEN( P_BACK ).
FILE_LEN = STRLEN( FILENAME ).
LEN = LEN - FILE_LEN.
P_BACK = P_BACK(LEN).

*     Get the relevant system seperator.
LEN = LEN - 1.
SYSTEM_SEPERATOR = P_BACK+LEN(1).
ELSE.
CLEAR P_BACK.
ENDIF.
ELSE.
CLEAR P_BACK.
ENDIF.

IF G_IS_EHP7 IS INITIAL.
* Deactivate 'Execute in background'
APPEND 'SJOB' TO STAT_EXCLUDE.
CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
EXPORTING
P_STATUS  = SY-PFKEY
TABLES
P_EXCLUDE = STAT_EXCLUDE.
ENDIF.

OBJ_PERC = 100 / NUM_OBJECT_TYPES.

SET TITLEBAR 'UE' OF PROGRAM 'SAPLS_SEARCH'
WITH 'Panaya code extract tool'.

* Fill in the System's Role's value list
IF ( IS_ON_TRIAL = 'X' ).
VALUE-KEY = 'DEV'.
VALUE-TEXT = 'Development'.
APPEND VALUE TO LIST.
VALUE-KEY = 'TST'.
VALUE-TEXT = 'Testing/QA'.
APPEND VALUE TO LIST.
VALUE-KEY = 'PRD'.
VALUE-TEXT = 'Production'.
APPEND VALUE TO LIST.
VALUE-KEY = 'SANDBOX'.
VALUE-TEXT = 'Sandbox'.
APPEND VALUE TO LIST.
VALUE-KEY = 'EDUCATION'.
VALUE-TEXT = 'Education/Training'.
APPEND VALUE TO LIST.
VALUE-KEY = 'PRD_COPY'.
VALUE-TEXT = 'Copy of Production'.
APPEND VALUE TO LIST.
VALUE-KEY = 'OTHER'.
VALUE-TEXT = 'Unspecified'.
APPEND VALUE TO LIST.

NAME = 'P_ROLE'.
CALL FUNCTION 'VRM_SET_VALUES'
EXPORTING
ID     = NAME
VALUES = LIST.

NAME = 'P_TRROLE'.
CALL FUNCTION 'VRM_SET_VALUES'
EXPORTING
ID     = NAME
VALUES = LIST.
ENDIF.

* Initialize the known third party namespaces.
PERFORM INIT_THIRD_PARTY_RANGE.

CLEAR CUSTOMER_OBJECTS.
CUSTOMER_OBJECTS-SIGN   = 'I'.
CUSTOMER_OBJECTS-OPTION = 'CP'.
CUSTOMER_OBJECTS-LOW    = 'Z*'. APPEND CUSTOMER_OBJECTS.
CUSTOMER_OBJECTS-LOW    = 'Y*'. APPEND CUSTOMER_OBJECTS.
CUSTOMER_OBJECTS-LOW    = '/1BCDWB/IQ*'. APPEND CUSTOMER_OBJECTS.
CUSTOMER_OBJECTS-LOW    = '/1BCDWB/LIQ*'. APPEND CUSTOMER_OBJECTS.

CLEAR CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-SIGN = 'I'.
CUST_NAMESPACE_RNG-OPTION = 'CP'.
CUST_NAMESPACE_RNG-LOW = 'Z*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'Y*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'LZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'LY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPLZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPLY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'DBZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'DBY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPMZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPMY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'MZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'MY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPDBZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPDBY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'FZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'FY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPFZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPFY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'DZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'DY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPDZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPDY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'MSTZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'MSTY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'UZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'UY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPUZ*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'SAPUY*'. APPEND CUST_NAMESPACE_RNG.
CUST_NAMESPACE_RNG-LOW = 'MP9*'. APPEND CUST_NAMESPACE_RNG.

CLEAR EXCL_NAMESPACES.
EXCL_NAMESPACES-SIGN = 'I'.
EXCL_NAMESPACES-OPTION = 'EQ'.
EXCL_NAMESPACES-LOW = '/VIRSA/'.
APPEND EXCL_NAMESPACES.
EXCL_NAMESPACES-LOW = '/ICORP/'.
APPEND EXCL_NAMESPACES.
EXCL_NAMESPACES-LOW = '/1SAP1/'.
APPEND EXCL_NAMESPACES.


* Find non-SAP namespaces
SELECT * FROM TRNSPACET
INTO TABLE NAMESPACES
WHERE ( SAPFLAG = SPACE
AND     CHANGEUSER <> 'SAP' )
OR    ( NAMESPACE IN THIRD_PARTY_NS ) .

IF SY-SUBRC IS INITIAL.
LOOP AT NAMESPACES INTO NAMESPACE.
CONCATENATE NAMESPACE-NAMESPACE '*' INTO CUSTOMER_OBJECTS-LOW.
APPEND CUSTOMER_OBJECTS.
ENDLOOP.
ENDIF.

*---------------------------------------------------------------------*
*   START-OF-SELECTION
*---------------------------------------------------------------------*
START-OF-SELECTION.
*------------------

IF SY-BATCH IS INITIAL.
*  Confirm whith the user the extraction from the wanted systems.
CALL FUNCTION 'POPUP_TO_CONFIRM'
EXPORTING
*      TITLEBAR                    = ' '
*      DIAGNOSE_OBJECT             = ' '
TEXT_QUESTION               = QUESTION
DISPLAY_CANCEL_BUTTON       = ' '
IMPORTING
ANSWER                      = ANSWER.

*   If chose to continue
CHECK ANSWER = '1'.
ENDIF.

* Set the temporary file names
PERFORM SET_TEMP_FILENAMES.

* Generate the full file name.
IF R_FORE IS INITIAL.
PERFORM CORRECT_SERVER_PATH CHANGING P_BACK.
CONCATENATE P_BACK P_FILEN INTO P_BACK.
ELSE.
PERFORM BUILD_LOCAL_FILE_NAME USING P_FILEN
CHANGING P_FORE
P_FORE.
ENDIF.

IF P_RFCDES IS INITIAL.
P_RFCDES = 'NONE'.
ENDIF.
IF NOT TESTING_DATA_ONLY IS INITIAL.
NO_SUET_DATA = 'X'.
ENDIF.

* Start the run
CONCATENATE 'Started running ETL version '
REL_SPECIFIC_VER
GENERAL_PART_VER
INTO SUCC_MESS
SEPARATED BY SPACE.
MESSAGE S000(CONV) WITH SUCC_MESS.
PERFORM ADD_MESSAGE USING SUCC_MESS ABAP_TRUE.

* Check that the program is not running in background with foreground
* option
IF NOT SY-BATCH IS INITIAL AND NOT R_FORE IS INITIAL.
MESSAGE E000(26) WITH 'Please select background execution mode '.
ENDIF.

CLEAR: G_APP_STRUC, G_INC_STRUC, GT_ETL_MESSAGE, G_VIEW_WITH_AST.
REFRESH: GT_ETL_MESSAGE, GT_MODIF.

* append lines of messages that where found in the selection screen
LOOP AT GT_SCR_MESSAGE.
PERFORM ADD_MESSAGE USING GT_SCR_MESSAGE-MESSAGE ABAP_FALSE.
ENDLOOP.
CLEAR GT_SCR_MESSAGE[].

PERFORM INIT.
PERFORM VERSION_SPECIFIC_INIT.

* Create the main factory and the initial document
PERFORM CREATE_XML_DOCUMENT.

* Create the root element of the XML
PERFORM XML_HEADER USING G_IREF_PDOCUMENT ROOT_ELEMENT_NAME
CHANGING G_IREF_ROOT_ELEM.

PERFORM OPEN_XML_FILE.

* Add data to the XML
PERFORM ADD_DATA_TO_XML.

PERFORM CLOSE_XML_FILE.
*----------------
END-OF-SELECTION.
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
*       FORM SET_TEMP_FILENAMES                                       *
*---------------------------------------------------------------------*
FORM SET_TEMP_FILENAMES.

DATA: PATH_TAB TYPE TABLE OF STRING,
CURR_PATH TYPE STRING,
PATH_LENGTH TYPE I,
FILE_SEPARATOR TYPE C,
LEN TYPE I,
COMP TYPE I.

* Set temp filename
CONCATENATE 'temp' '_' SY-DATUM '_' SY-UZEIT '.xml'
INTO TEMP_FILENAME.

* Check if foreground or background mode was set
IF NOT R_FORE IS INITIAL.
CONCATENATE P_FORE TEMP_FILENAME INTO TEMP_FORE_FILENAME.
ELSE.
CONCATENATE P_BACK TEMP_FILENAME INTO TEMP_BACK_FILENAME.
ENDIF.
ENDFORM.                    "SET_TEMP_FILENAMES

*---------------------------------------------------------------------*
*       FORM BUILD_TEMP_FILENAME                                      *
*---------------------------------------------------------------------*
FORM BUILD_TEMP_FILENAME USING FILEPATH
SEPARATOR
CHANGING NEW_FILE_PATH.

DATA: PATH_TAB TYPE TABLE OF STRING,
CURR_PATH TYPE STRING,
PATH_LENGTH TYPE I.

*   Split the filename at file separator. Concatenate all
*   path components except the last one that will be the temporary
*   filename.
SPLIT FILEPATH AT SEPARATOR INTO TABLE PATH_TAB.
DESCRIBE TABLE PATH_TAB LINES PATH_LENGTH.
DELETE PATH_TAB INDEX PATH_LENGTH.
LOOP AT PATH_TAB INTO CURR_PATH.
IF SY-TABIX = 1.
NEW_FILE_PATH = CURR_PATH.
ELSE.
CONCATENATE NEW_FILE_PATH SEPARATOR CURR_PATH
INTO NEW_FILE_PATH.
ENDIF.
ENDLOOP.
CONCATENATE NEW_FILE_PATH SEPARATOR TEMP_FILENAME
INTO NEW_FILE_PATH.

ENDFORM.                    "BUILD_TEMP_FILENAME

*---------------------------------------------------------------------*
*       FORM open_xml_file                                            *
*---------------------------------------------------------------------*
FORM OPEN_XML_FILE.

DATA: HEADER_STRING TYPE STRING.

* Initialize stream factory
G_IREF_PSTREAMFACTORY = G_IREF_PIXML->CREATE_STREAM_FACTORY( ).
G_OSTREAM = G_IREF_PSTREAMFACTORY->CREATE_OSTREAM_ITABLE(
TABLE = G_BUFFER_ITAB ).
CALL METHOD G_OSTREAM->SET_PRETTY_PRINT
EXPORTING
PRETTY_PRINT = 'X'.

CONCATENATE '<?xml version="1.0" encoding="' ENCODING '"?>'
INTO HEADER_STRING.

CALL METHOD G_OSTREAM->WRITE_STRING
EXPORTING
STRING = HEADER_STRING.
PERFORM APPEND_STRING_TO_FILE USING '<ROOT_ELEMENT>'.

ENDFORM.                    "open_xml_file

*---------------------------------------------------------------------*
*       FORM close_xml_file                                           *
*---------------------------------------------------------------------*
FORM CLOSE_XML_FILE.

DATA: STREAM_SIZE TYPE I,
MSG_LINE1(70) TYPE C,
MSG_LINE2(70) TYPE C,
MSG_LINE3(70) TYPE C.

PERFORM APPEND_STRING_TO_FILE USING '</ROOT_ELEMENT>'.

* flush the buffered data to the file - last time
STREAM_SIZE = G_OSTREAM->GET_NUM_WRITTEN_RAW( ).
PERFORM APPEND_ITAB_TO_FILE USING STREAM_SIZE G_BUFFER_ITAB.

* Write the file to original location
PERFORM MOVE_FILE USING TEMP_FORE_FILENAME
TEMP_BACK_FILENAME
P_FORE
P_BACK
R_FORE.

* Display finish message
IF PANAYA_TEST_MODE IS INITIAL.
MSG_LINE1 = 'The data extraction was finished successfully.'.
IF NO_USAGE = 'X'.
MSG_LINE2 = 'Please note: No usage statistics were found.'.
MSG_LINE3 = 'Contact Panaya support for assistance.'.
IF POPUP_OK = 'X'.
CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT_LO'
EXPORTING
TITEL        = 'Panaya'
TEXTLINE1    = MSG_LINE1
TEXTLINE2    = MSG_LINE2
TEXTLINE3    = MSG_LINE3
START_COLUMN = 15
START_ROW    = 6.
ELSE.
WRITE:/ MSG_LINE1.
WRITE:/ MSG_LINE2.
WRITE:/ MSG_LINE3.
ENDIF.
ELSE.
IF POPUP_OK = 'X'.

CALL FUNCTION 'POPUP_TO_DISPLAY_TEXT_LO'
EXPORTING
TITEL        = 'Panaya'
TEXTLINE1    = MSG_LINE1
START_COLUMN = 15
START_ROW    = 6.
ELSE.
WRITE:/ MSG_LINE1.
WRITE:/ MSG_LINE2.
WRITE:/ MSG_LINE3.
ENDIF.

ENDIF.
ENDIF.

ENDFORM.                    "close_xml_file

*---------------------------------------------------------------------*
*       FORM append_string_to_file                                    *
*---------------------------------------------------------------------*
FORM APPEND_STRING_TO_FILE USING STR TYPE STRING.

CALL METHOD G_OSTREAM->WRITE_STRING
EXPORTING
STRING = NEW_LINE.
CALL METHOD G_OSTREAM->WRITE_STRING
EXPORTING
STRING = STR.
CALL METHOD G_OSTREAM->WRITE_STRING
EXPORTING
STRING = NEW_LINE.

ENDFORM.                    "append_string_to_file

*---------------------------------------------------------------------*
*       FORM append_xml_element_to_file                               *
*---------------------------------------------------------------------*
FORM APPEND_XML_ELEMENT_TO_FILE USING
I_ELEMENT TYPE REF TO IF_IXML_ELEMENT
I_REMOVE_NODE TYPE C.

DATA: STREAM_SIZE TYPE I.

STREAM_SIZE = G_OSTREAM->GET_NUM_WRITTEN_RAW( ).

IF ( STREAM_SIZE > BUFFER_MAX_SIZE ).
PERFORM APPEND_ITAB_TO_FILE USING STREAM_SIZE G_BUFFER_ITAB.
G_OSTREAM = G_IREF_PSTREAMFACTORY->CREATE_OSTREAM_ITABLE(
TABLE = G_BUFFER_ITAB ).
CALL METHOD G_OSTREAM->SET_PRETTY_PRINT
EXPORTING
PRETTY_PRINT = 'X'.
CLEAR G_BUFFER_ITAB.
ENDIF.

CALL METHOD G_OSTREAM->WRITE_STRING
EXPORTING
STRING = NEW_LINE.
CALL METHOD I_ELEMENT->RENDER( OSTREAM = G_OSTREAM ).

IF I_REMOVE_NODE = 'X'.
CALL METHOD I_ELEMENT->REMOVE_NODE.
CLEAR I_ELEMENT.
ENDIF.

ENDFORM.                    "append_xml_element_to_file
*---------------------------------------------------------------------*
*       FORM add_data_to_xml                                          *
*---------------------------------------------------------------------*
FORM ADD_DATA_TO_XML.

PERFORM ADD_DOCUMENT_HEADER.

IF USAGEONL IS INITIAL.

*   First we fetch the "customer" (non-SAP) development classes. Then,
* we get the list of objects for these dev. classes. The list of objects
*   is divided into lists per object type
PERFORM EXTRACT_DEVELOPMENT_CLASSES.
IF TESTING_DATA_ONLY IS INITIAL.
PERFORM EXTRACT_REPOSITORY_OBJECTS.
ENDIF.

IF VANILLA = 'X'.
IF FIRSTBLK = 'X'.
*     execute only first round
PERFORM EXTRACT_MODULE_APP_COMP.
PERFORM EXTRACT_HR_DATA.
PERFORM EXTRACT_BUSINESS_OBJECTS.
ENDIF.

*     execute every round
PERFORM EXTRACT_REL_DEV_CLASS_COMP.
ENDIF.

PERFORM EXTRACT_FUNCTIONS.

*   The extraction of programs must occur after the extraction of
*   functions, since we add a program entry for each function group
PERFORM EXTRACT_PROGRAMS.
PERFORM EXTRACT_VANILLA_PROG_CUST_VARI.

PERFORM EXTRACT_TRANSACTIONS.
PERFORM EXTRACT_LOGICAL_DATABASES.
PERFORM EXTRACT_MESSAGES.
PERFORM EXTRACT_VANILLA_SOURCE.

*   Find SAP types with customer append structures/customer include.
*   The ETL also extracts these SAP "modified" types in the relevant
*   extraction forms
PERFORM FIND_APPEND_STRUCTURES.
PERFORM FIND_CUSTOMER_INCLUDES.

*   Find SAP views that include * notion, and at least one of the
*   tables that are included in the view has customer append structure/
*   customer include
PERFORM FIND_VIEW_WITH_ASTRIX.

PERFORM EXTRACT_TABLES.
PERFORM EXTRACT_VANILLA_TABL_CUST_INDX.

PERFORM EXTRACT_VIEWS.
PERFORM EXTRACT_FOREIGN_KEYS.
PERFORM EXTRACT_DATA_ELEMENTS.
*    PERFORM EXTRACT_CLUSTER_TABLES.
*    PERFORM EXTRACT_TABLE_TYPES.
*    PERFORM EXTRACT_DOMAINS.

*   Runtime representation of types
PERFORM EXTRACT_DATA_TYPES.

IF TESTING_DATA_ONLY IS INITIAL.
PERFORM EXTRACT_USER_EXITS.
PERFORM EXTRACT_MODIFICATIONS.
PERFORM EXTRACT_AUTHORIZATIONS.
ENDIF.

PERFORM EXTRACT_SOFTWARE_COMPONENTS.
PERFORM EXTRACT_SUPPORT_PACKAGES.
PERFORM EXTRACT_DEV_CLASSES.
PERFORM EXTRACT_NAMESPACES.
IF TESTING_DATA_ONLY IS INITIAL.
PERFORM EXTRACT_INFOTYPE_TEXTS.
PERFORM EXTRACT_IDOCS.
PERFORM EXTRACT_FUGR_INCLUDES_STATUS.
PERFORM EXTRACT_FORMS.
PERFORM EXTRACT_LAYOUTS.

PERFORM EXTRACT_WEB_SERVICES.

*   This part will be performed only in ECC6
IF VANILLA = ''.
PERFORM EXTRACT_INDUSTRY_SOLUTION.
ENDIF.

PERFORM EXTRACT_USERS_DATA.
PERFORM EXTRACT_BW_EXTRACTORS.
PERFORM EXTRACT_USERS.
PERFORM EXTRACT_BW_DATA.
ENDIF.
IF NO_SUET_DATA IS INITIAL.
PERFORM EXTRACT_AREA_MENUS.
PERFORM EXTRACT_VOFM_USER_EXITS.
PERFORM EXTRACT_BTE_USER_EXITS.
PERFORM EXTRACT_SALES_USER_EXITS.
PERFORM EXTRACT_BADI_IMP.

IF NOT EXTRACT_WORKFLOW_DATA IS INITIAL.
PERFORM EXTRACT_WORKFLOWS.
ENDIF.

PERFORM EXTRACT_LSMW.
PERFORM EXTRACT_SAP_SCRIPT_FORMS.
PERFORM EXTRACT_LANGUAGES_INSTALLED.
PERFORM EXTRACT_LANDSCAPE_DETAILS.
PERFORM EXTRACT_HARDWARE_PLATFORM.
PERFORM EXTRACT_GATEWAY_CONNECTIONS.
ENDIF.
ELSE.

PERFORM EXTRACT_AUTH_USAGE_ONLY.
PERFORM EXTRACT_IDOCS_USAGE_ONLY.
ENDIF.

* Extract proxies data in any case (usage only)
IF NOT EXTRACT_PROXY_DATA IS INITIAL.
PERFORM EXTRACT_PROXIES.
ENDIF.

PERFORM EXTRACT_USAGE.

IF TESTING_DATA_ONLY IS INITIAL.
PERFORM EXTRACT_UPL_DATA.
PERFORM ADD_SERVERS_LIST.
PERFORM GET_RFC_LIST.
PERFORM ADD_RFCS_LIST.
PERFORM EXTRACT_SYSTEM_PARAMETERS.
PERFORM GET_SM_DATA.
PERFORM GET_SOLAR_RAW_DATA.
ENDIF.

PERFORM ADD_TIME_STATS.
PERFORM ADD_ETL_ERROR_MESSAGES.
PERFORM ADD_ETL_JOBLOG.

ENDFORM.                          " add_data_to_xml
*---------------------------------------------------------------------*
*       FORM update_progress                                *
*---------------------------------------------------------------------*
FORM UPDATE_PROGRESS USING TEXT.

DATA: BATCH_TEXT(50) TYPE C,
CURR_STEP(2) TYPE C,
TOTAL_STEPS(2) TYPE C,
STEPS_TEXT(50) TYPE C,
PROGRESS_TEXT(512) TYPE C.

CURR_OBJECT_TYPE = CURR_OBJECT_TYPE + 1.
PERCENTAGE = PERCENTAGE + OBJ_PERC.
CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
EXPORTING
PERCENTAGE = PERCENTAGE
TEXT       = TEXT.

IF SY-BATCH = 'X'.
CURR_STEP = CURR_OBJECT_TYPE.
TOTAL_STEPS = NUM_OBJECT_TYPES.
CONCATENATE '(' CURR_STEP '/' TOTAL_STEPS ')' INTO STEPS_TEXT.
MESSAGE S000(CONV) WITH TEXT STEPS_TEXT.
CONCATENATE TEXT STEPS_TEXT INTO PROGRESS_TEXT SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING PROGRESS_TEXT ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.
ENDIF.

ENDFORM.                    "update_progress

*&---------------------------------------------------------------------*
*&      Form  add_document_header
*&---------------------------------------------------------------------*
FORM ADD_DOCUMENT_HEADER.

DATA: HEADER_NODE       TYPE XML_ELEMENT.
DATA: CODE_VERSION(15)  TYPE C.

DATA: LV_TEXT    TYPE CHAR10,
LV_LICENSE TYPE CHAR10,
LV_MODE    TYPE CHAR10,
LV_LOGSYS  TYPE LOGSYS,
LV_RFC_SYSID TYPE SY-SYSID,
LV_RFC_MANDT TYPE SY-MANDT.

DATA: K_RELEASE TYPE SYSAPRL,
K_PATCH   TYPE SYCHAR05.
DATA: HOST TYPE STRING.

* Create a child node for the Header node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'HEADER'
CHANGING HEADER_NODE.
*---
* Set Date
LV_TEXT = SY-DATUM.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'DATE' LV_TEXT.

* Set Time
LV_TEXT = SY-UZEIT.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TIME' LV_TEXT.
* Set Application Server
IF SHOW_SERVERS_NAME IS INITIAL.
HOST = 'XXX'.
ELSE.
HOST = SY-HOST.
ENDIF.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'APPLICATION_SERVER'
HOST.
MESSAGE S000(CONV) WITH 'APPLICATION_SERVER =' SY-HOST.

* Set System ID name
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SYSTEM_ID' SY-SYSID.
MESSAGE S000(CONV) WITH 'SYSTEM_ID =' SY-SYSID.

* Set Client number
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'CLIENT' SY-MANDT.
MESSAGE S000(CONV) WITH 'CLIENT =' SY-MANDT.

* Set Operating System
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'OPERATING_SYSTEM'
SY-OPSYS.
MESSAGE S000(CONV) WITH 'OPERATING_SYSTEM =' SY-OPSYS.

* Set SAP System Release
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SYSTEM_RELEASE'
SY-SAPRL.
MESSAGE S000(CONV) WITH 'SYSTEM_RELEASE =' SY-SAPRL.

* Set Installation number
CALL FUNCTION 'SLIC_GET_LICENCE_NUMBER'
IMPORTING
LICENSE_NUMBER = LV_LICENSE.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'INSTALLATION_NUMBER'
LV_LICENSE.
MESSAGE S000(CONV) WITH 'INSTALLATION_NUMBER =' LV_LICENSE.

* Set User name
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'USER_NAME' SY-UNAME.
MESSAGE S000(CONV) WITH 'USER_NAME =' SY-UNAME.

* Set Export Tool Version
CONCATENATE GENERAL_PART_VER REL_SPECIFIC_VER
INTO CODE_VERSION SEPARATED BY '.'.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'EXPORT_TOOL_VERSION'
CODE_VERSION.

* Set Target System
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM'
P_RFCDES.
MESSAGE S000(CONV) WITH 'TARGET_SYSTEM =' P_RFCDES.

* Set Target System Id ( production system id )
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM_ID'
RFC_SYSID.
MESSAGE S000(CONV) WITH 'TARGET_SYSTEM_ID =' RFC_SYSID.

* Set Target system release
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM_REL'
RFC_SAPRL.
MESSAGE S000(CONV) WITH 'TARGET_SYSTEM_REL =' RFC_SAPRL.

IF ( IS_ON_TRIAL = 'X' ).
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SYSTEM_ROLE'
P_ROLE.
MESSAGE S000(CONV) WITH 'SYSTEM_ROLE =' P_ROLE.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TARGET_SYSTEM_ROLE'
P_TRROLE.
MESSAGE S000(CONV) WITH 'TARGET_SYSTEM_ROLE =' P_TRROLE.
ENDIF.

* Set ETL vanilla extraction flag
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'VANILLA_EXTRACTION'
VANILLA.

* Set SM Target System
IF NOT P_SM_RFC IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM'
P_SM_RFC.
MESSAGE S000(CONV) WITH 'SM_SYSTEM =' P_SM_RFC.

*   Set SM System Id
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_ID'
SM_SYSID.
MESSAGE S000(CONV) WITH 'SM_SYSTEM_ID =' SM_SYSID.

*   Set SM system release
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_REL'
SM_SAPRL.
MESSAGE S000(CONV) WITH 'SM_SYSTEM_REL =' SM_SAPRL.

ENDIF.

* Set execution mode
IF R_BACK IS INITIAL.
LV_MODE = 'FOREGROUND'.
ELSE.
LV_MODE = 'BACKGROUND'.
ENDIF.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'MODE'
LV_MODE.

PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'PRD_LOGSYS'
GV_LOGSYS.

CALL FUNCTION 'PARTNER_LOGICAL_SYSTEM_GET'
IMPORTING
P_LOGSYS                       = LV_LOGSYS
EXCEPTIONS
OWN_LOGICAL_SYSTEM_NOT_DEFINED = 1
OTHERS                         = 2.
IF SY-SUBRC <> 0.
LV_LOGSYS = 'UNDEFINED'.
ENDIF.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'LOCAL_LOGSYS'
LV_LOGSYS.

* Add unicode length of the current system
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'UCLEN' UNICODELG.
MESSAGE S000(CONV) WITH 'UCLEN =' UNICODELG.

* Add current Logon Language
LV_TEXT = SY-LANGU.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'LOGIN_LANGU' LV_TEXT.
MESSAGE S000(CONV) WITH 'LOGIN_LANGU =' LV_TEXT.

* Add active industry solution when applicable
IF ACTIVE_INDUSTRY_SOLUTION NE SPACE.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE
'ACTIVE_INDUSTRY_SOLUTION' ACTIVE_INDUSTRY_SOLUTION.
MESSAGE S000(CONV) WITH 'ACTIVE_INDUSTRY_SOLUTION ='
ACTIVE_INDUSTRY_SOLUTION.
ENDIF.

* Add usage only
IF  NOT USAGEONL IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'USAGE_ONLY'
USAGEONL.
MESSAGE S000(CONV) WITH 'USAGE_ONLY =' USAGEONL.
ENDIF.

IF NOT IA_DATA_ONLY IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'IA_DATA_ONLY'
IA_DATA_ONLY.
ENDIF.
MESSAGE S000(CONV) WITH 'IA_DATA_ONLY =' IA_DATA_ONLY.

IF NOT REQUIRE_SOLMAN_RFC IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'REQUIRE_SOLMAN_RFC'
REQUIRE_SOLMAN_RFC.
ENDIF.
MESSAGE S000(CONV) WITH 'REQUIRE_SOLMAN_RFC =' REQUIRE_SOLMAN_RFC.

IF NOT TESTING_DATA_ONLY IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'TESTING_DATA_ONLY'
TESTING_DATA_ONLY.
ENDIF.
MESSAGE S000(CONV) WITH 'TESTING_DATA_ONLY =' TESTING_DATA_ONLY.

IF NOT NO_SUET_DATA IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'NO_SUET_DATA'
NO_SUET_DATA.
ENDIF.
MESSAGE S000(CONV) WITH 'NO_SUET_DATA =' NO_SUET_DATA.

IF NOT EXTRACT_DEBUG IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'EXTRACT_DEBUG'
EXTRACT_DEBUG.
ENDIF.
MESSAGE S000(CONV) WITH 'EXTRACT_DEBUG =' EXTRACT_DEBUG.

IF NOT NO_WEB_USAGE IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'NO_WEB_USAGE'
NO_WEB_USAGE.
ENDIF.
MESSAGE S000(CONV) WITH 'NO_WEB_USAGE =' NO_WEB_USAGE.

IF NOT EXTRACT_PROXY_DATA IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'EXTRACT_PROXY_DATA'
EXTRACT_PROXY_DATA.
ENDIF.
MESSAGE S000(CONV) WITH 'EXTRACT_PROXY_DATA =' EXTRACT_PROXY_DATA.

IF NOT EXTRACT_PROXY_CALLERS IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE
'EXTRACT_PROXY_CALLERS'
EXTRACT_PROXY_CALLERS.
ENDIF.
MESSAGE S000(CONV) WITH 'EXTRACT_PROXY_CALLERS ='
EXTRACT_PROXY_CALLERS.

IF NOT EXTRACT_IDOCS_USAGE IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE
'EXTRACT_IDOCS_USAGE'
EXTRACT_IDOCS_USAGE.
ENDIF.
MESSAGE S000(CONV) WITH 'EXTRACT_IDOCS_USAGE ='
EXTRACT_IDOCS_USAGE.

IF NOT EXTRACT_FULL_USAGE IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'EXTRACT_FULL_USAGE'
EXTRACT_FULL_USAGE.
ENDIF.
MESSAGE S000(CONV) WITH 'EXTRACT_FULL_USAGE =' EXTRACT_FULL_USAGE.

IF NOT EXTRACT_WORKFLOW_DATA IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE
'EXTRACT_WORKFLOW_DATA'
EXTRACT_WORKFLOW_DATA.
ENDIF.
MESSAGE S000(CONV) WITH 'EXTRACT_WORKFLOW_DATA ='
EXTRACT_WORKFLOW_DATA.

IF NOT GET_AGR_USERS IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'GET_AGR_USERS'
GET_AGR_USERS.
ENDIF.
MESSAGE S000(CONV) WITH 'GET_AGR_USERS =' GET_AGR_USERS.

* Add version specific header attributes
PERFORM VERSION_SPECIFIC_HEADER_ATTRIB USING HEADER_NODE.

* Add kernel data
PERFORM GET_KERNEL_DATA CHANGING K_RELEASE
K_PATCH.

PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'KERNEL_RELEASE'
K_RELEASE.
MESSAGE S000(CONV) WITH 'KERNEL_RELEASE =' K_RELEASE.

PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'KERNEL_PATCH'
K_PATCH.
MESSAGE S000(CONV) WITH 'KERNEL_PATCH =' K_PATCH.

PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'EXTRACT_USER_DATA'
EXTRACT_USER_DATA.
MESSAGE S000(CONV) WITH 'EXTRACT_USER_DATA =' EXTRACT_USER_DATA.
* Set SM Target System
IF NOT P_SM_RFC IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM'
P_SM_RFC.
MESSAGE S000(CONV) WITH 'SM_SYSTEM =' P_SM_RFC.

*   Set SM System Id
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_ID'
SM_SYSID.
MESSAGE S000(CONV) WITH 'SM_SYSTEM_ID =' SM_SYSID.

*   Set SM system release
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'SM_SYSTEM_REL'
SM_SAPRL.
MESSAGE S000(CONV) WITH 'SM_SYSTEM_REL =' SM_SAPRL.

ENDIF.

* Set bw extraction system data
IF NOT P_BW_RFC IS INITIAL.
*   BW system
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'BW_DESTINATION'
P_BW_RFC.
MESSAGE S000(CONV) WITH 'BW_DESTINATION =' P_BW_RFC.

CALL FUNCTION 'SCT2_GET_T000_ENTRY_RFC' DESTINATION P_BW_RFC
IMPORTING
EV_SYSID              = LV_RFC_SYSID
EV_MANDT              = LV_RFC_MANDT
EXCEPTIONS
SYSTEM_FAILURE        = 1
COMMUNICATION_FAILURE = 2.
IF NOT SY-SUBRC IS INITIAL.
ELSE.
*     Set BW System ID
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'BW_SYSID'
LV_RFC_SYSID.
MESSAGE S000(CONV) WITH 'BW_SYSID =' LV_RFC_SYSID.

*     Set BW Client
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'BW_CLIENT'
LV_RFC_MANDT.
MESSAGE S000(CONV) WITH 'BW_CLIENT =' LV_RFC_MANDT.
ENDIF.
ENDIF.

* Set the local system and target system's types
PERFORM ADD_SYSTEM_TYPES_TO_HEADER USING HEADER_NODE.

* Logging to job log of ETL execution settings
MESSAGE S000(CONV) WITH 'FILE NAME =' P_BACK.
MESSAGE S000(CONV) WITH 'TEMP FILE NAME=' TEMP_BACK_FILENAME.
MESSAGE S000(CONV) WITH 'PACKET SIZE=' PAC_SIZE.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING HEADER_NODE 'X'.

ENDFORM.                    " add_document_header

*&---------------------------------------------------------------------*
*&      Form  extract_development_classes
*&---------------------------------------------------------------------*
FORM EXTRACT_DEVELOPMENT_CLASSES.

RANGES: R_DEVCLASS FOR TDEVC-DEVCLASS.
DATA: MESS_TEXT(512) TYPE C.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING
'Extracting development classes'.

* Get Development Classes Data
PERFORM GET_DEV_CLASS_DATA.

* Get Development Classes Text
IF NOT LT_TDEVC[] IS INITIAL.
SELECT * FROM  TDEVCT
INTO TABLE LT_TDEVCT
FOR ALL ENTRIES IN LT_TDEVC
WHERE  DEVCLASS = LT_TDEVC-DEVCLASS.
ENDIF.

CHECK NOT LT_TDEVC[] IS INITIAL.

* Add non 'Z' or 'Y' namespace dev. classes to log
IF SY-BATCH = 'X'.
LOOP AT LT_TDEVC INTO LS_TDEVC.
IF ( LS_TDEVC-DEVCLASS(1) <> 'Z'
AND LS_TDEVC-DEVCLASS(1) <> 'Y' ).
MESSAGE S000(CONV) WITH '*** Found namespace dev. class: '
LS_TDEVC-DEVCLASS.
CLEAR MESS_TEXT.
CONCATENATE '*** Found namespace dev. class: ' LS_TDEVC-DEVCLASS
INTO MESS_TEXT SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING MESS_TEXT ABAP_TRUE.
ENDIF.
ENDLOOP.
CLEAR LS_TDEVC.
ENDIF.

* Extract Development classes
PERFORM APPEND_STRING_TO_FILE USING '<DEVELOPMENT_CLASSES>'.

PERFORM APPEND_STRING_TO_FILE USING '<DEV_CLASSES_DATA>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TDEVC
USING G_IREF_PDOCUMENT
'TDEVC'.
PERFORM APPEND_STRING_TO_FILE USING '</DEV_CLASSES_DATA>'.

PERFORM APPEND_STRING_TO_FILE USING '<DEV_CLASSES_TEXT>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TDEVCT
USING G_IREF_PDOCUMENT
'TDEVCT'.
PERFORM APPEND_STRING_TO_FILE USING '</DEV_CLASSES_TEXT>'.

PERFORM APPEND_STRING_TO_FILE USING '</DEVELOPMENT_CLASSES>'.

* Get Development Class Objects list
IF NOT LT_TDEVC[] IS INITIAL.
SELECT * FROM TADIR
APPENDING TABLE GT_TADIR
FOR ALL ENTRIES IN LT_TDEVC
WHERE DEVCLASS = LT_TDEVC-DEVCLASS
AND  PGMID     EQ 'R3TR'.
ENDIF.

* Select from tadir where the objects are in customer name range
SELECT *
FROM   TADIR AS TDR
APPENDING  TABLE GT_TADIR
WHERE  TDR~PGMID EQ 'R3TR'
AND    TDR~OBJ_NAME IN CUST_NAMESPACE_RNG
AND   AUTHOR <> 'SAP'
AND   DEVCLASS <> '$TMP'.

* -- Check if generated obejects should also be removed ----------------
* Add generated objects
IF ADD_GEN_PROGRAMS = 'X'.
*   Add also generated programs
SELECT * FROM TADIR
APPENDING TABLE GT_TADIR
WHERE PGMID = 'R3TR'
AND   SRCSYSTEM = 'SAP'
AND   AUTHOR <> 'SAP'
AND   DEVCLASS <> '$TMP'
AND   GENFLAG = 'X'.
ELSE.
*   Add all generated objects (except programs)
SELECT * FROM TADIR
APPENDING TABLE GT_TADIR
WHERE PGMID = 'R3TR'
AND   OBJECT <> 'PROG'
AND   SRCSYSTEM = 'SAP'
AND   AUTHOR <> 'SAP'
AND   DEVCLASS <> '$TMP'
AND   GENFLAG = 'X'.
ENDIF.

* Add Query programs
PERFORM ADD_ABAP_QUERY_OBJECTS.

SORT GT_TADIR BY PGMID OBJECT OBJ_NAME.
DELETE ADJACENT DUPLICATES FROM GT_TADIR.

IF VANILLA = ''.
* Add customer ABAP Dictionary modifications
SELECT * FROM SMODILOG
INTO TABLE GT_MODIF
WHERE ( OBJ_TYPE = 'TABL' AND SUB_TYPE <> 'DOCU' )
OR    ( OBJ_TYPE IN ('VIEW', 'DTEL', 'TABL', 'SQLT',
'TTYP', 'DOMA' ) )
AND   INACTIVE <> '1'.

IF NOT GT_MODIF[] IS INITIAL.
LOOP AT GT_MODIF.
READ TABLE GT_TADIR INTO GS_TADIR WITH KEY
PGMID = 'R3TR'
OBJECT = GT_MODIF-OBJ_TYPE
OBJ_NAME = GT_MODIF-OBJ_NAME
BINARY SEARCH.
CHECK SY-SUBRC <> 0.

MODIFIED_OBJECTS-OBJ_TYPE = GT_MODIF-OBJ_TYPE.
MODIFIED_OBJECTS-OBJ_NAME = GT_MODIF-OBJ_NAME.
APPEND MODIFIED_OBJECTS.
ENDLOOP.

IF NOT MODIFIED_OBJECTS[] IS INITIAL.
SELECT * FROM TADIR
APPENDING TABLE GT_TADIR
FOR ALL ENTRIES IN MODIFIED_OBJECTS
WHERE PGMID = 'R3TR'
AND   OBJECT = MODIFIED_OBJECTS-OBJ_TYPE
AND   OBJ_NAME = MODIFIED_OBJECTS-OBJ_NAME.
ENDIF.
ENDIF.
ENDIF.

SORT GT_TADIR BY PGMID OBJECT OBJ_NAME.

DELETE ADJACENT DUPLICATES FROM GT_TADIR.

LOOP AT GT_TADIR INTO GS_TADIR.

GS_OBJECTLIST-OBJ_TYPE = GS_TADIR-OBJECT.
GS_OBJECTLIST-OBJ_NAME = GS_TADIR-OBJ_NAME.

CASE GS_TADIR-OBJECT.
WHEN 'FUGR'.
APPEND GS_OBJECTLIST TO GT_OBJ_FUNC.
WHEN 'PROG'.
*       Check if the program is active. Only then
*       add it to the file
SELECT SINGLE *
FROM PROGDIR
WHERE NAME = GS_OBJECTLIST-OBJ_NAME AND
STATE <> 'I'.
IF SY-SUBRC IS INITIAL.
APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
ENDIF.
WHEN 'TRAN'.
APPEND GS_OBJECTLIST TO GT_OBJ_TRNS.
WHEN 'LDBA'.
APPEND GS_OBJECTLIST TO GT_OBJ_LGDB.

*       Add ldb program to object list
PERFORM ADD_LDB_TO_OBJ_LIST USING GS_TADIR-OBJ_NAME
GS_OBJECTLIST.
WHEN 'TYPE'.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPEPOOL.
WHEN 'MSAG'.
APPEND GS_OBJECTLIST TO GT_OBJ_MESG.
WHEN 'TABL'.
APPEND GS_OBJECTLIST TO GT_OBJ_TABL.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
WHEN 'VIEW'.
APPEND GS_OBJECTLIST TO GT_OBJ_VIEW.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
WHEN 'DTEL'.
APPEND GS_OBJECTLIST TO GT_OBJ_DELM.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
WHEN 'SQLT'.
APPEND GS_OBJECTLIST TO GT_OBJ_CTAB.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
WHEN 'TTYP'.
APPEND GS_OBJECTLIST TO GT_OBJ_TTYP.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
WHEN 'DOMA'.
APPEND GS_OBJECTLIST TO GT_OBJ_DOMN.
WHEN 'CLAS'.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
APPEND GS_OBJECTLIST TO GT_OBJ_CLAS.
WHEN 'BMFR'.
APPEND GS_OBJECTLIST TO GT_OBJ_APPL.
WHEN 'CMOD'.
APPEND GS_OBJECTLIST TO GT_OBJ_UEXT.
WHEN 'SSFO'.
APPEND GS_OBJECTLIST TO GT_OBJ_SSFO.
WHEN 'FORM'.
APPEND GS_OBJECTLIST TO GT_OBJ_FORM.
WHEN 'OSOA' OR 'OSOD'.
APPEND GS_OBJECTLIST TO GT_OBJ_OSOA_D.
WHEN 'SHI3'.
APPEND GS_OBJECTLIST TO GT_OBJ_SHI3.
WHEN 'SXCI'.
APPEND GS_OBJECTLIST TO GT_OBJ_SXCI.
WHEN 'WEBI'. " Web Services
APPEND GS_OBJECTLIST TO GT_OBJ_WEBI.
ENDCASE.
ENDLOOP.

SORT: GT_OBJ_FUNC, GT_OBJ_PROG, GT_OBJ_TRNS, GT_OBJ_LGDB,
GT_OBJ_MESG, GT_OBJ_TABL, GT_OBJ_VIEW, GT_OBJ_DELM,
GT_OBJ_CTAB, GT_OBJ_TTYP, GT_OBJ_DOMN, GT_OBJ_TYPE,
GT_OBJ_APPL, GT_OBJ_UEXT, GT_OBJ_SSFO, GT_OBJ_FORM,
GT_OBJ_OSOA_D, GT_OBJ_SHI3, GT_OBJ_SXCI, GT_OBJ_WEBI,
GT_OBJ_TYPEPOOL, ABAP_QUERY_PROGS.

PERFORM ADD_TIME_STAT USING 'Extract developement classes' L_STARTTIME.

ENDFORM.                    " extract_development_classes

*&---------------------------------------------------------------------*
*&      Form  GET_DEV_CLASS_DATA
*&---------------------------------------------------------------------*
FORM GET_DEV_CLASS_DATA.

IF DEVCLASS[] IS INITIAL.
SELECT * FROM TDEVC
INTO TABLE LT_TDEVC
WHERE ( DEVCLASS LIKE 'Z%' OR DEVCLASS LIKE 'Y%' )
OR    ( DEVCLASS LIKE '/%' AND AS4USER <> 'SAP' AND
PDEVCLASS <> 'SAP' AND DLVUNIT <> 'LOCAL'
AND
NOT NAMESPACE IN EXCL_NAMESPACES )
OR    ( NAMESPACE IN THIRD_PARTY_NS ).
ELSE.
SELECT * FROM TDEVC
INTO TABLE LT_TDEVC
WHERE DEVCLASS IN DEVCLASS.
ENDIF.

ENDFORM.                    " GET_DEV_CLASS_DATA

*---------------------------------------------------------------------*
*       FORM ADD_SMODILOG_PROGRAMS                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM ADD_SMODILOG_PROGRAMS.

DATA: MODIFIED_PROGS TYPE TABLE OF SMODILOG WITH HEADER LINE.

CHECK VANILLA = ''.

* Find all the customer modified programs (vanilla only)
SELECT * FROM SMODILOG
INTO TABLE MODIFIED_PROGS
WHERE SUB_TYPE = 'REPS'
AND   SUB_NAME NOT IN CUST_NAMESPACE_RNG
AND   INACTIVE = SPACE.

* Add TADIR entries for the programs (for types other then 'PROG'
* there are no entries in TADIR)
IF NOT MODIFIED_PROGS[] IS INITIAL.
SELECT * FROM TADIR
APPENDING TABLE GT_TADIR
FOR ALL ENTRIES IN MODIFIED_PROGS
WHERE PGMID = 'R3TR' AND OBJECT = 'PROG' AND
OBJ_NAME = MODIFIED_PROGS-OBJ_NAME.
ENDIF.
SORT GT_TADIR.
DELETE ADJACENT DUPLICATES FROM GT_TADIR.
ENDFORM.                    "ADD_SMODILOG_PROGRAMS

*---------------------------------------------------------------------*
*       FORM get_class_data
*---------------------------------------------------------------------*
FORM GET_CLASS_DATA TABLES METHODS_INCLUDES STRUCTURE  RPY_REPO
USING CLSNAME TYPE  SEOCLSNAME
CHANGING MAIN_INCLUDE_NAME TYPE PROGRAMM.

DATA: CLASSKEY         TYPE SEOCLSKEY,
SOURCE_LINE      TYPE EDPLINE,
MAIN_INC_TYPE(2) TYPE C,
TADIR_REC        LIKE TADIR,
OBJ_NAME         TYPE TROBJ_NAME,
OREF             TYPE REF TO IF_OO_CLASS_INCL_NAMING,
MTDS_W_INCL      TYPE SEOP_METHODS_W_INCLUDE,
MTDS_REC         TYPE LINE OF SEOP_METHODS_W_INCLUDE,
SECTION          TYPE TROBJTYPE,
INCLUDE          TYPE PROGRAMM,
APPENDAGE        TYPE SEOP_INCLUDE_APPENDAGE,
TMDIR_REC        TYPE TMDIR.


CLASS CL_OO_INCLUDE_NAMING DEFINITION LOAD.

* Check if this is a class or an interface and determine the main
* include type accordingly
SELECT SINGLE *
FROM TADIR
INTO TADIR_REC
WHERE OBJ_NAME = CLSNAME AND
( OBJECT = SEOK_R3TR_CLASS OR
OBJECT = SEOK_R3TR_INTERFACE ).

IF NOT SY-SUBRC IS INITIAL.
EXIT.
ENDIF.

* Check if there are implemented methods to this class. If not -
* don't continue.
SELECT SINGLE *
FROM TMDIR
INTO TMDIR_REC
WHERE CLASSNAME = CLSNAME.

IF NOT SY-SUBRC IS INITIAL.
EXIT.
ENDIF.

* Get the class name
OBJ_NAME = TADIR_REC-OBJ_NAME.
OREF ?= CL_OO_INCLUDE_NAMING=>GET_INSTANCE_BY_TRKEY(
PGMID = TADIR_REC-PGMID
OBJECT = TADIR_REC-OBJECT
OBJ_NAME = OBJ_NAME ).

MAIN_INCLUDE_NAME = OREF->CLASS_POOL.


* If class source was not found - raise exception.
IF SY-SUBRC <> 0.
RAISE CLASS_WAS_NOT_FOUND.
ENDIF.

* Get the includes of the methods
MTDS_W_INCL = OREF->GET_ALL_METHOD_INCLUDES( ).

LOOP AT MTDS_W_INCL INTO MTDS_REC.
APPEND MTDS_REC-INCNAME TO METHODS_INCLUDES.
ENDLOOP.

* Get public
SECTION = 'CPUB'.
INCLUDE = OREF->GET_INCLUDE_BY_SECTION( SECTION ).
APPEND INCLUDE TO METHODS_INCLUDES.

* Get private
SECTION = 'CPRI'.
INCLUDE = OREF->GET_INCLUDE_BY_SECTION( SECTION ).
APPEND INCLUDE TO METHODS_INCLUDES.

* Get protected
SECTION = 'CPRO'.
INCLUDE = OREF->GET_INCLUDE_BY_SECTION( SECTION ).
APPEND INCLUDE TO METHODS_INCLUDES.

* Add type and locals
INCLUDE = OREF->TYPE_DEP.
APPEND INCLUDE TO METHODS_INCLUDES.
INCLUDE = OREF->LOCALS_OLD.
APPEND INCLUDE TO METHODS_INCLUDES.

* Get class locals
APPENDAGE = 'DEF'.
INCLUDE = OREF->GET_INCLUDE_BY_APPENDAGE( APPENDAGE ).
APPEND INCLUDE TO METHODS_INCLUDES.
APPENDAGE = 'IMP'.
INCLUDE = OREF->GET_INCLUDE_BY_APPENDAGE( APPENDAGE ).
APPEND INCLUDE TO METHODS_INCLUDES.
APPENDAGE = 'MAC'.
INCLUDE = OREF->GET_INCLUDE_BY_APPENDAGE( APPENDAGE ).
APPEND INCLUDE TO METHODS_INCLUDES.

ENDFORM.                    "GET_CLASS_DATA

*---------------------------------------------------------------------*
*       FORM EXTRACT_VANILLA_SOURCE                                   *
*---------------------------------------------------------------------*
FORM EXTRACT_VANILLA_SOURCE.
CHECK TESTING_DATA_ONLY IS INITIAL.
DATA: L_STARTTIME LIKE SY-UZEIT,
LT_PROGRAMS_NODES  TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
LS_PROGRAM_NODE    LIKE LINE OF LT_PROGRAMS_NODES,
LT_SOURCE TYPE TABLE OF ABAPSOURCE WITH HEADER LINE,
LV_SOURCE_SRC TYPE STRING,
LV_SOURCE_TAR TYPE STRING,
LT_UNIFIED_SOURCE TYPE TT_UNIFIED_SOURCE WITH HEADER LINE,
IS_FIRST TYPE C,
LT_TEXTELM TYPE TABLE OF TEXTPOOL,
CLASS_INCLUDES TYPE PROG_TAB_TYPE,
PROG_NAME TYPE PROGNAME,
VAN_PROGRAMS_NODE TYPE XML_ELEMENT,
ACC_VAN_PROGRAMS_NODE TYPE XML_ELEMENT,
READ_SOURCE_RC TYPE I,
CDATA_ELEM_SRC TYPE REF TO IF_IXML_ELEMENT,
CDATA_ELEM_TAR TYPE REF TO IF_IXML_ELEMENT,
ACTUAL_VANILLA_PROGS_COUNT TYPE I,
ACTUAL_VANILLA_PROGS_COUNT_STR TYPE STRING,
LV_SOURCE_LINE_COUNT TYPE I,
FORMS_TAB TYPE SUBROUTINE_TAB_TYPE,
MODU_TAB TYPE SUBROUTINE_TAB_TYPE.

FIELD-SYMBOLS: <LS_PROG> TYPE PROG_TYPE.

CHECK NOT G_VANILLA_PROGRAMS[] IS INITIAL.

SORT G_VANILLA_PROGRAMS BY PROG.
CLEAR ACTUAL_VANILLA_PROGS_COUNT.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting vanilla programs'.

* Create a child node for the Programs node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'VANILLA_PROGRAMS'
CHANGING VAN_PROGRAMS_NODE.

PERFORM APPEND_STRING_TO_FILE USING '<VANILLA_PROGRAMS>'.

* Read the programs source code from the SOURCE system
LOOP AT G_VANILLA_PROGRAMS.

PROG_NAME = G_VANILLA_PROGRAMS-PROG.

IF ( G_VANILLA_PROGRAMS-ORIGIN = ORIGIN_TARGET ).

*     Read program's source code from TARGET system
PERFORM READ_PROGRAM_DATA TABLES LT_TEXTELM CLASS_INCLUDES
FORMS_TAB
MODU_TAB
USING PROG_NAME 'NONE' 'X' SPACE SPACE SPACE
CHANGING LV_SOURCE_SRC READ_SOURCE_RC
LV_SOURCE_LINE_COUNT.

IF READ_SOURCE_RC = 0.

*     Add the Program Source data to the current program
PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
VAN_PROGRAMS_NODE
'VANILLA_SOURCE'
LV_SOURCE_SRC 'X'
CHANGING CDATA_ELEM_SRC.

PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_SRC
'PROGRAM' PROG_NAME.
PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_SRC
'ORIGIN' 'TARGET'.
PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_SRC
'LINE_COUNT' LV_SOURCE_LINE_COUNT.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING CDATA_ELEM_SRC 'X'.

*       Increase the acctual programs counter
ADD 1 TO ACTUAL_VANILLA_PROGS_COUNT.
ENDIF.
ELSEIF ( G_VANILLA_PROGRAMS-ORIGIN = ORIGIN_SOURCE ).

*     Read program's source code from SOURCE system
PERFORM READ_PROGRAM_DATA TABLES LT_TEXTELM CLASS_INCLUDES
FORMS_TAB
MODU_TAB
USING PROG_NAME P_RFCDES 'X' SPACE SPACE SPACE
CHANGING LV_SOURCE_TAR READ_SOURCE_RC
LV_SOURCE_LINE_COUNT.

IF READ_SOURCE_RC = 0.
*     Add the Program Source data to the current program
PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
VAN_PROGRAMS_NODE
'VANILLA_SOURCE'
LV_SOURCE_TAR 'X'
CHANGING CDATA_ELEM_TAR.

PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_TAR
'PROGRAM' PROG_NAME.
PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_TAR
'ORIGIN' 'SOURCE'.
PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM_TAR
'LINE_COUNT' LV_SOURCE_LINE_COUNT.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING CDATA_ELEM_TAR 'X'.

*       Increase the acctual programs counter
ADD 1 TO ACTUAL_VANILLA_PROGS_COUNT.

ENDIF.
ENDIF.

ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '</VANILLA_PROGRAMS>'.

* Add vanilla programs actual count tag

* Create a child node for the Actual vanilla programs that were found
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'ACC_VANILLA_PROGS'
CHANGING ACC_VAN_PROGRAMS_NODE.

ACTUAL_VANILLA_PROGS_COUNT_STR = ACTUAL_VANILLA_PROGS_COUNT.

PERFORM ADD_ATTRIBUTE_TO_NODE USING ACC_VAN_PROGRAMS_NODE
'ACTUAL_PROGS' ACTUAL_VANILLA_PROGS_COUNT.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING ACC_VAN_PROGRAMS_NODE 'X'.

PERFORM ADD_TIME_STAT USING 'Extract vanilla programs' L_STARTTIME.

ENDFORM.                    "EXTRACT_VANILLA_SOURCE

*---------------------------------------------------------------------*
*       FORM extract_programs
*---------------------------------------------------------------------*
FORM EXTRACT_PROGRAMS.

DATA: LT_PROG            TYPE LT_PROG_TYPE WITH HEADER LINE,
LT_PROGRAMS_NODES  TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
LS_PROGRAM_NODE    LIKE LINE OF LT_PROGRAMS_NODES,
PROGRAMS_NODE      TYPE XML_ELEMENT,
LV_IS_WITH_SOUCE_EXT  TYPE C,
GET_PROGRAM_DATA   TYPE C,
L_STARTTIME LIKE SY-UZEIT,
CLASS_NAME TYPE SEOCLSNAME,
METHODS_INCLUDES TYPE TABLE OF RPY_REPO,
CURR_INCLUDE TYPE RPY_REPO,
MAIN_INCLUDE_NAME TYPE PROGRAMM,
CLASS_INCLUDES TYPE PROG_TAB_TYPE,
CLASS_INCLUDES_WA LIKE LINE OF CLASS_INCLUDES,
PROG_NUM TYPE I,
PROG_NUM_TEXT TYPE STRING.

FIELD-SYMBOLS: <LS_PROG> LIKE LT_PROG_EXP.
RANGES: R_NAME FOR TRDIR-NAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting programs'.

SORT GT_OBJ_PROG.
DELETE ADJACENT DUPLICATES FROM GT_OBJ_PROG.

* Set Object list
LOOP AT GT_OBJ_PROG INTO GS_OBJECTLIST.
CLEAR R_NAME.
R_NAME-SIGN   = 'I'.
R_NAME-OPTION = 'EQ'.
R_NAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_NAME.
ENDLOOP.

* Pay attention !!! extract functions/dev. classes uses this global
* data, so make sure that the 'free' occurs AFTER these extractions
FREE GT_OBJ_PROG.

* Add also type group programs
LOOP AT GT_OBJ_TYPEPOOL INTO GS_OBJECTLIST.
CLEAR R_NAME.
R_NAME-SIGN   = 'I'.
R_NAME-OPTION = 'EQ'.
CONCATENATE '%_C' GS_OBJECTLIST-OBJ_NAME INTO R_NAME-LOW.
APPEND R_NAME.
ENDLOOP.

* Add object oriented
LOOP AT GT_OBJ_CLAS INTO GS_OBJECTLIST.
CLASS_NAME = GS_OBJECTLIST-OBJ_NAME.
CLEAR METHODS_INCLUDES[].
PERFORM GET_CLASS_DATA TABLES METHODS_INCLUDES
USING CLASS_NAME
CHANGING MAIN_INCLUDE_NAME.

IF ( NOT MAIN_INCLUDE_NAME IS INITIAL ).
R_NAME-SIGN   = 'I'.
R_NAME-OPTION = 'EQ'.
R_NAME-LOW = MAIN_INCLUDE_NAME.
APPEND R_NAME.
ENDIF.

LOOP AT METHODS_INCLUDES INTO CURR_INCLUDE.
R_NAME-LOW = CURR_INCLUDE-INCLNAME.
APPEND R_NAME.

CLASS_INCLUDES_WA-PROG = CURR_INCLUDE-INCLNAME.
APPEND CLASS_INCLUDES_WA TO CLASS_INCLUDES.
ENDLOOP.

ENDLOOP.
SORT CLASS_INCLUDES BY PROG.
DELETE ADJACENT DUPLICATES FROM CLASS_INCLUDES.

CHECK NOT R_NAME[] IS INITIAL.

SORT G_PROGS_ADDED_BY_SMODILOG.
SORT R_NAME.

* Check support to source_extendend variable in RPY_PROGRAM_READ
PERFORM CHECK_SOURCE_EXT_SUPPORT CHANGING LV_IS_WITH_SOUCE_EXT.

* Save program names for filtering vanilla programs
* with customer variants
G_CUST_PROGS[] = R_NAME[].

* Get the Programs data
IF NOT R_NAME[] IS INITIAL.
IF NOT EXTRACT_DEBUG IS INITIAL.

DATA: MESSAGE_STR TYPE STRING.

PERFORM EXTRACT_R_NAME TABLES R_NAME.
LOOP AT R_NAME.
CONCATENATE 'DEBUG!Prog Range,program name -' R_NAME-LOW
INTO MESSAGE_STR.
MESSAGE S000(CONV) WITH MESSAGE_STR.
PERFORM ADD_MESSAGE USING MESSAGE_STR ABAP_TRUE.
ENDLOOP.
ENDIF.

DESCRIBE TABLE R_NAME LINES PROG_NUM.
PROG_NUM_TEXT = PROG_NUM.
MESSAGE S000(CONV) WITH 'Number of program to extract: '
PROG_NUM_TEXT.
CLEAR MESSAGE_STR.
CONCATENATE 'Number of program to extract: ' PROG_NUM_TEXT
INTO MESSAGE_STR SEPARATED BY SPACE.

*   Create a child node for the Programs node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'PROGRAMS'
CHANGING PROGRAMS_NODE.

PERFORM APPEND_STRING_TO_FILE USING '<PROGRAMS>'.

SELECT * FROM TRDIR
INTO CORRESPONDING FIELDS OF TABLE LT_PROG
FOR ALL ENTRIES IN R_NAME
WHERE NAME = R_NAME-LOW AND
SUBC <> 'X'.

FREE R_NAME.

LOOP AT LT_PROG.

*     Set 'added by smodilog' flag
READ TABLE G_PROGS_ADDED_BY_SMODILOG BINARY SEARCH
WITH KEY PROG = LT_PROG-NAME.
IF SY-SUBRC IS INITIAL.
LT_PROG-ADDED_BY_SMODILOG = 'X'.
MODIFY LT_PROG.
ENDIF.
ENDLOOP.

MESSAGE S000(CONV) WITH '*** ALL programs packet'.
PERFORM ADD_MESSAGE USING '*** ALL programs packet' ABAP_TRUE.
PERFORM ADD_USED_MEMORY_TO_LOG.

*   Add the Programs data to the current node
PERFORM ADD_ITAB_TO_XML TABLES LT_PROG LT_PROGRAMS_NODES
USING G_IREF_PDOCUMENT PROGRAMS_NODE
'PROGRAM'.
FREE LT_PROG.

LOOP AT LT_PROGRAMS_NODES INTO LS_PROGRAM_NODE.
IF NOT EXTRACT_DEBUG IS INITIAL.
ASSIGN LS_PROGRAM_NODE-WA->* TO <LS_PROG>.
CONCATENATE 'PROG: ' <LS_PROG>-NAME INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
ENDIF.

GET_PROGRAM_DATA = 'X'.

*     Don't get abap query programs if not needed
IF ADD_ABAP_QUERIES = SPACE.
ASSIGN LS_PROGRAM_NODE-WA->* TO <LS_PROG>.
READ TABLE ABAP_QUERY_PROGS WITH KEY OBJ_NAME = <LS_PROG>-NAME
BINARY SEARCH TRANSPORTING NO FIELDS.

*     Add the abap query program header (don't get more program data)
IF SY-SUBRC IS INITIAL.
CLEAR GET_PROGRAM_DATA.
ENDIF.
ENDIF.

*     Add Program's titles anyway ( even in case of ABAP Query )
PERFORM GET_PROGRAM_TEXTS USING LS_PROGRAM_NODE.

IF GET_PROGRAM_DATA = 'X'.
*       Add Program's Screens
PERFORM GET_PROGRAM_SCREENS    USING  LS_PROGRAM_NODE.
*       Add Program's GUI status
PERFORM GET_PROGRAM_GUI_STATUS_WRAP USING  LS_PROGRAM_NODE.
*       Add Program's Mains
PERFORM GET_PROGRAM_MAINS      USING  LS_PROGRAM_NODE.
*       Add Program's Source
PERFORM GET_PROGRAM_SOURCE     TABLES CLASS_INCLUDES
USING  LS_PROGRAM_NODE
LV_IS_WITH_SOUCE_EXT.
*       Add Program's syntax check result
PERFORM GET_PROGRAM_SYNTAX_CHECK USING  LS_PROGRAM_NODE.

ENDIF.

PERFORM GET_PROGRAM_VARIANTS  USING LS_PROGRAM_NODE.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LS_PROGRAM_NODE-NODE_REF 'X'.
DELETE LT_PROGRAMS_NODES.

ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '</PROGRAMS>'.

ENDIF.

PERFORM ADD_TIME_STAT USING 'Extract programs' L_STARTTIME.

ENDFORM.                          " extract_programs
*&---------------------------------------------------------------------*
*&      Form  extract_r_name
*&---------------------------------------------------------------------*
FORM EXTRACT_R_NAME TABLES R_NAME.
PERFORM APPEND_STRING_TO_FILE USING '<R_NAMES>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES R_NAME
USING  G_IREF_PDOCUMENT
'R_NAME'.
PERFORM APPEND_STRING_TO_FILE USING '</R_NAMES>'.

ENDFORM.                          "extract_r_name

*&---------------------------------------------------------------------*
*&      Form  get_program_screens
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_SCREENS USING  PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

DATA: SCREENS_NODE    TYPE XML_ELEMENT,
ELEMENTS_NODE   TYPE XML_ELEMENT,
FLOW_LOGIC_NODE TYPE XML_ELEMENT.

DATA: BEGIN OF LT_SCREENS OCCURS 0.
INCLUDE STRUCTURE D020S.
DATA:   DTXT LIKE D020V-DTXT,
END OF LT_SCREENS,

LT_D020T              TYPE TABLE OF D020T   WITH HEADER LINE,
LT_SCREENS_NODES      TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
SCREEN_HEADER         LIKE D020S.

* For Function: RS_IMPORT_DYNPRO
DATA: LT_FTAB               TYPE TABLE OF D021S   WITH HEADER LINE,
LT_PLTAB              TYPE TABLE OF D022S   WITH HEADER LINE.
* For Function: RS_SCRP_GET_FIELD_TYPE_TEXT
DATA: LV_FIELD_TYPE TYPE SCRFGTYP.
* For Function: RS_SCRP_GET_ALL_DIMENSIONS
DATA: LV_LINE       TYPE I,
LV_COLUMN     TYPE I,
LV_VIS_LENGTH TYPE I.

DATA: LV_NUMBER     TYPE I.
* For Foreign key active check
DATA: FLG1DDF TYPE X VALUE '20',
FLG3FOR TYPE X VALUE '04',
FLG3FDU TYPE X VALUE '02',
FLG3FKU TYPE X VALUE '08'.

DATA: BEGIN OF LT_FTAB_EXT  OCCURS 0.
INCLUDE STRUCTURE D021S.
DATA:   LINE_NO        TYPE NUMC2,
COLN_NO        TYPE NUMC2,
LENG_NO        TYPE NUMC2,
FIELD_TYPE     TYPE SCRFGTYP,
FORKEY_ACTIVE  TYPE CHAR1,
FUNTYPE        TYPE SCRFPTYPE,
FUNCODE        TYPE CUA_FUNC,
END OF LT_FTAB_EXT.

DATA: LS_FUNKEY  TYPE D021S_RES1.
DATA: LV_STRING  TYPE STRING,
CDATA_ELEM TYPE REF TO IF_IXML_ELEMENT.

FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP,
<LS_SCREENS> LIKE LINE OF LT_SCREENS.

*--- Get Program's screens ---------------------------------------------
*   Create a node for the program screens
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'SCREENS'
CHANGING SCREENS_NODE.

ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

*   Get the current program's screens data
SELECT * FROM  D020S
INTO CORRESPONDING FIELDS OF TABLE LT_SCREENS
WHERE  PROG  = <LS_PROG>-NAME.
CHECK NOT LT_SCREENS[] IS INITIAL.
*   Get Screens text
IF NOT LT_SCREENS[] IS INITIAL.
SELECT * FROM  D020T
INTO TABLE LT_D020T
FOR ALL ENTRIES IN LT_SCREENS
WHERE  PROG  = LT_SCREENS-PROG
AND    LANG  = 'E'.
ENDIF.
*   Set Screens text
LOOP AT LT_SCREENS.
GV_TABIX = SY-TABIX.
READ TABLE LT_D020T WITH KEY DYNR = LT_SCREENS-DNUM.
CHECK SY-SUBRC = 0.
LT_SCREENS-DTXT = LT_D020T-DTXT.
MODIFY LT_SCREENS INDEX GV_TABIX TRANSPORTING DTXT.
ENDLOOP.

*   Add the screens data to the current screen tag
PERFORM ADD_ITAB_TO_XML TABLES LT_SCREENS LT_SCREENS_NODES
USING G_IREF_PDOCUMENT SCREENS_NODE
'SCREEN'.

*--- Get Screen's elements
LOOP AT LT_SCREENS_NODES.

*   Create a node for the screen elements
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LT_SCREENS_NODES-NODE_REF
'ELEMENTS'
CHANGING ELEMENTS_NODE.

ASSIGN LT_SCREENS_NODES-WA->* TO <LS_SCREENS>.

FREE: LT_FTAB,
LT_FTAB_EXT,
LT_PLTAB.

* Get the current screen's elements data
CALL FUNCTION 'RS_IMPORT_DYNPRO'
EXPORTING
DYLANG               = 'E'
DYNAME               = <LS_SCREENS>-PROG
DYNUMB               = <LS_SCREENS>-DNUM
*             REQUEST              = ' '
*             SUPPRESS_CHECKS      = ' '
IMPORTING
HEADER               = SCREEN_HEADER
TABLES
FTAB                 = LT_FTAB
PLTAB                = LT_PLTAB
EXCEPTIONS
BUTTON_ERROR         = 1
DYLANGUAGE_INVALID   = 2
DYLANGUAGE_NOT_INST  = 3
DYNAME_INVALID       = 4
DYNPROLOAD_NOT_FOUND = 5
DYNPRO_OLD           = 6
DYNUMB_INVALID       = 7
FTAB_INVALID         = 8
GEN_ERROR            = 9
GEN_OK               = 10
HEADER_INVALID       = 11
INTERNAL_ERROR       = 12
NO_DYNPRO            = 13
NO_FTAB_ROW          = 14
NO_MEMORY            = 15
NO_PROCESSLOGIC      = 16
PLTAB_INVALID        = 17
REQUEST_INVALID      = 18
OTHERS               = 19.
IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'button_error'.
WHEN 2. ERROR = 'dylanguage_invalid'.
WHEN 3. ERROR = 'dylanguage_not_inst'.
WHEN 4. ERROR = 'dyname_invalid'.
WHEN 5. ERROR = 'dynproload_not_found'.
WHEN 6. ERROR = 'dynpro_old'.
WHEN 7. ERROR = 'dynumb_invalid'.
WHEN 8. ERROR = 'ftab_invalid'.
WHEN 9. ERROR = 'gen_error'.
WHEN 10. ERROR = 'gen_ok'.
WHEN 11. ERROR = 'header_invalid'.
WHEN 12. ERROR = 'internal_error'.
WHEN 13. ERROR = 'no_dynpro'.
WHEN 14. ERROR = 'no_ftab_row'.
WHEN 15. ERROR = 'no_memory'.
WHEN 16. ERROR = 'no_processlogic'.
WHEN 17. ERROR = 'pltab_invalid'.
WHEN 18. ERROR = 'request_invalid'.
WHEN 19. ERROR = 'Others'.
ENDCASE.

CONCATENATE 'extract programs: RS_IMPORT_DYNPRO, program:'
<LS_SCREENS>-PROG 'Screen:' <LS_SCREENS>-DNUM 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
CHECK SY-SUBRC = 0.

*   Set LT_FTAB
LOOP AT LT_FTAB.
CLEAR LT_FTAB_EXT.
MOVE-CORRESPONDING LT_FTAB TO LT_FTAB_EXT.

*     This field's data contains invalid chars. when transported to
*     the xml file
CLEAR LT_FTAB_EXT-FMKY.

*     Get Field type
CALL FUNCTION 'RS_SCRP_GET_FIELD_TYPE_TEXT'
EXPORTING
FIELD                    = LT_FTAB
*         TEXT_KIND                = 'LONG'
IMPORTING
FIELD_TYPE               = LT_FTAB_EXT-FIELD_TYPE.

CLEAR: LV_LINE, LV_COLUMN, LV_VIS_LENGTH.
*     Get Field line, column, vis.langth,
CALL FUNCTION 'RS_SCRP_GET_ALL_DIMENSIONS'
EXPORTING
DYNP_FIELD         = LT_FTAB
IMPORTING
LINE               = LV_LINE
COLUMN             = LV_COLUMN
*         LENGTH             =
VIS_LENGTH         = LV_VIS_LENGTH.
*         HIGHT              =
*         RELATIVE_POSITIONS =
MOVE LV_LINE   TO LV_NUMBER.
MOVE LV_NUMBER TO LT_FTAB_EXT-LINE_NO.

MOVE LV_COLUMN TO LV_NUMBER.
MOVE LV_NUMBER TO LT_FTAB_EXT-COLN_NO.

MOVE LV_VIS_LENGTH TO LV_NUMBER.
MOVE LV_NUMBER     TO LT_FTAB_EXT-LENG_NO.


*     Set the flag 'Foreign key active'
IF    LT_FTAB-FLG1 O FLG1DDF
AND LT_FTAB-FLG3 O FLG3FOR
AND LT_FTAB-FLG3 Z FLG3FDU
AND LT_FTAB-FLG3 Z FLG3FKU.
LT_FTAB_EXT-FORKEY_ACTIVE = 'X'.
ENDIF.

*     Set the 'Function code'
LS_FUNKEY = LT_FTAB-RES1.
IF NOT LS_FUNKEY-FUNCCODE IS INITIAL.
LT_FTAB_EXT-FUNTYPE = LS_FUNKEY-FUNCTYPE.
LT_FTAB_EXT-FUNCODE = LS_FUNKEY-FUNCCODE.
ENDIF.

*     These fields' data may contain invalid chars. when transported to
*     the xml file
*      CLEAR LT_FTAB_EXT-RES1.
*      CLEAR LT_FTAB_EXT-RES2.

APPEND LT_FTAB_EXT.

ENDLOOP.

*   Add the screen Elements data to the current screen
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_FTAB_EXT
USING G_IREF_PDOCUMENT
ELEMENTS_NODE
'ELEMENT'.

*   Create a node for the screen Flow Logic
*    PERFORM create_xml_node USING g_iref_pdocument
*                                  lt_screens_nodes-node_ref
*                                  'FLOW_LOGIC'
*                            CHANGING flow_logic_node.

*   Export screen flow logic if the current screen is not a selection
*   screen
IF SCREEN_HEADER-TYPE <> 'S'.

*     Set the Flow Logic lines to a string
CLEAR LV_STRING.
LOOP AT LT_PLTAB.
CONCATENATE LV_STRING LT_PLTAB-LINE INTO LV_STRING
SEPARATED BY GV_ENDLINE.
ENDLOOP.

*     Add the screen Flow Logic data to the current screen
PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
LT_SCREENS_NODES-NODE_REF
'FLOW_LOGIC'
LV_STRING 'X'
CHANGING CDATA_ELEM.

ENDIF.

ENDLOOP.

ENDFORM.                    " get_program_screens

*&---------------------------------------------------------------------*
*&      Form  get_program_gui_status
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_GUI_STATUS USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

DATA: STATUSES_NODE     TYPE XML_ELEMENT,
FKEYS_NODE        TYPE XML_ELEMENT,
TREES_NODE        TYPE XML_ELEMENT.

DATA: LT_STATUS_NODES   TYPE HANDLES_TAB_TYPE WITH HEADER LINE.

* For Function: RS_CUA_STATUS
DATA: LT_STATUS         TYPE TABLE OF  RLSEU0_DOK.
* For Function: RS_CUA_GET_STATUS
DATA: LT_FKEYS          TYPE TABLE OF  RSEUL_KEYS  WITH HEADER LINE,
LT_FUNCTIONKEYS   TYPE TABLE OF  RSMPE_KEYS  WITH HEADER LINE.
* For Function: RS_CUA_GET_TREE
DATA: LT_TREE           TYPE TABLE OF  RSEUL_TREE  WITH HEADER LINE,
LT_MENUTREE       TYPE TABLE OF  RSMPE_TREE  WITH HEADER LINE.

* Function Keys
DATA: BEGIN OF LT_FUNKEYS  OCCURS 0.
INCLUDE STRUCTURE RSMPE_KEYS.
DATA:   TCODE   TYPE CUA_FUNC.         " Function code
DATA: END OF LT_FUNKEYS.

* Trees
DATA: BEGIN OF LT_TREES  OCCURS 0.
INCLUDE STRUCTURE RSMPE_TREE.
DATA:   TEXTNO     TYPE CUA_TEXTNR,    " Reference to assigned text
SHORT      TYPE CUA_SHORT,     " GUI: Short text
LONG       TYPE CUA_LONG,      " GUI: Long text
TRANSLATED TYPE CUA_JA.        " Execute function
DATA: END OF LT_TREES.

FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP,
<LS_STATUS>  LIKE LINE OF LT_STATUS.

*--- Get Program's GUI statuses ----------------------------------------

*   Create a node for the program GUI statuses
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'GUI_STATUSES'
CHANGING STATUSES_NODE.

ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

FREE: LT_STATUS.
*   Get the current program's GUI statuses data
CALL FUNCTION 'RS_CUA_STATUS'
EXPORTING
OBJECTNAME           = <LS_PROG>-NAME
LANGUAGE             = SY-LANGU
TABLES
STATUS               = LT_STATUS
EXCEPTIONS
OBJECT_NOT_FOUND     = 1
OBJECT_NOT_SPECIFIED = 2
PROGRAM_NOT_FOUND    = 3
OTHERS               = 4.
CHECK SY-SUBRC = 0.
CHECK NOT LT_STATUS[] IS INITIAL.

*   Add the GUIs list to the GUI_STATUSES tag
PERFORM ADD_ITAB_TO_XML TABLES LT_STATUS LT_STATUS_NODES
USING G_IREF_PDOCUMENT STATUSES_NODE
'GUI_STATUS'.

*--- Get GUI status's Function Keys ------------------------------------
LOOP AT LT_STATUS_NODES.

*   Create a node for the GUI Function Keys
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LT_STATUS_NODES-NODE_REF
'FKEYS'
CHANGING FKEYS_NODE.

*   Create a node for the GUI trees
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LT_STATUS_NODES-NODE_REF
'TREE'
CHANGING TREES_NODE.

ASSIGN LT_STATUS_NODES-WA->* TO <LS_STATUS>.

FREE: LT_FKEYS,
LT_FUNCTIONKEYS,
LT_TREE,
LT_MENUTREE.

* Get the Function Keys data to the current GUI status
CALL FUNCTION 'RS_CUA_GET_STATUS'
EXPORTING
LANGUAGE              = SY-LANGU
PROGRAM               = <LS_PROG>-NAME
STATUS                = <LS_STATUS>-STATUS
SUPPRESS_CMOD_ENTRIES = ' '
TABLES
FKEYS                 = LT_FKEYS
TREE                  = LT_TREE
MENUTREE              = LT_MENUTREE
FUNCTIONKEYS          = LT_FUNCTIONKEYS
EXCEPTIONS
NOT_FOUND_PROGRAM     = 1
NOT_FOUND_STATUS      = 2
RECURSIVE_MENUES      = 3
EMPTY_LIST            = 4
NOT_FOUND_MENU        = 5
OTHERS                = 6.
IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'not_found_program'.
WHEN 2. ERROR = 'not_found_status'.
WHEN 3. ERROR = 'recursive_menues'.
WHEN 4. ERROR = 'empty_list'.
WHEN 5. ERROR = 'not_found_menu'.
WHEN 6. ERROR = 'Others'.
ENDCASE.

CONCATENATE 'extract programs: RS_CUA_GET_STATUS, program:'
<LS_PROG>-NAME 'Status:' <LS_STATUS>-STATUS 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

ENDIF.
CHECK SY-SUBRC = 0.

*   When the gui status name contains asterisk the 'RS_CUA_GET_STATUS'
*   function module doesn't refer the asterisk as character but as a
*   placeholder - in this case, several statuses (that match the
*   pattern) may be selected into the returned tables. We keep only the
*   current status relevant records
*   Also, remove inactive entries
DELETE LT_FKEYS WHERE STATUS <> <LS_STATUS>-STATUS
OR ACTIVE <> 'X'.
DELETE LT_TREE WHERE STATUS <> <LS_STATUS>-STATUS
OR ACTIVE <> 'X'.
DELETE LT_MENUTREE WHERE STATUS <> <LS_STATUS>-STATUS
OR ACTIVE <> 'X'.
DELETE LT_FUNCTIONKEYS WHERE STATUS <> <LS_STATUS>-STATUS
OR ACTIVE <> 'X'.

*   Remove any duplicate records
SORT LT_FKEYS BY PFNO CODE PROGRAM STATUS.
SORT LT_FUNCTIONKEYS BY PROGRAM STATUS PFNO CODE.
SORT LT_TREE BY POS_1 POS_2 POS_3 POS_4 CODE PROGRAM STATUS.
SORT LT_MENUTREE BY PROGRAM STATUS POS_1 POS_2 POS_3 POS_4 CODE.
DELETE ADJACENT DUPLICATES FROM LT_FKEYS COMPARING
PFNO CODE PROGRAM STATUS.
DELETE ADJACENT DUPLICATES FROM LT_FUNCTIONKEYS COMPARING
PROGRAM STATUS PFNO CODE.
DELETE ADJACENT DUPLICATES FROM LT_TREE COMPARING
POS_1 POS_2 POS_3 POS_4 CODE PROGRAM STATUS.
DELETE ADJACENT DUPLICATES FROM LT_MENUTREE COMPARING
PROGRAM STATUS POS_1 POS_2 POS_3 POS_4 CODE.

* Merge 2 tables: LT_FKEYS & LT_FUNCTIONKEYS
FREE: LT_FUNKEYS.
LOOP AT LT_FUNCTIONKEYS.
MOVE-CORRESPONDING LT_FUNCTIONKEYS TO LT_FUNKEYS.
READ TABLE LT_FKEYS WITH KEY PROGRAM = LT_FUNCTIONKEYS-PROGRAM
STATUS  = LT_FUNCTIONKEYS-STATUS
PFNO    = LT_FUNCTIONKEYS-PFNO
CODE    = LT_FUNCTIONKEYS-CODE.
IF SY-SUBRC = 0.
LT_FUNKEYS-TCODE = LT_FKEYS-TCODE.
ENDIF.
APPEND LT_FUNKEYS.
ENDLOOP.

*   Add the Function Keys data to the current GUI status
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_FUNKEYS
USING G_IREF_PDOCUMENT
FKEYS_NODE
'FKEY'.

* Merge 2 tables: LT_TREE & LT_MENUTREE
FREE: LT_TREES.
LOOP AT LT_MENUTREE.
MOVE-CORRESPONDING LT_MENUTREE TO LT_TREES.
READ TABLE LT_TREE WITH KEY PROGRAM = LT_MENUTREE-PROGRAM
STATUS  = LT_MENUTREE-STATUS
POS_1   = LT_MENUTREE-POS_1
POS_2   = LT_MENUTREE-POS_2
POS_3   = LT_MENUTREE-POS_3
POS_4   = LT_MENUTREE-POS_4
CODE    = LT_MENUTREE-CODE.
IF SY-SUBRC = 0.
LT_TREES-TEXTNO     = LT_TREE-TEXTNO.
LT_TREES-SHORT      = LT_TREE-SHORT.
LT_TREES-LONG       = LT_TREE-LONG.
LT_TREES-TRANSLATED = LT_TREE-TRANSLATED.
ENDIF.
APPEND LT_TREES.
ENDLOOP.

*   Add the Trees data to the current GUI status
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TREES
USING G_IREF_PDOCUMENT
TREES_NODE
'TREE_ELEMENT'.
ENDLOOP.

ENDFORM.                    " get_program_gui_status

*&---------------------------------------------------------------------*
*&      Form  get_program_texts
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_TEXTS USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

DATA: TEXTS_NODE   TYPE XML_ELEMENT,
LT_TRDIRT          TYPE TABLE OF TRDIRT.

FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP.

*   Create a node for the Program Text Elements
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'TITLE_TEXT'
CHANGING TEXTS_NODE.

ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

SELECT *
FROM   TRDIRT
INTO   TABLE LT_TRDIRT
WHERE  NAME = <LS_PROG>-NAME.

IF NOT LT_TRDIRT[] IS INITIAL.
*     Add the Text Elements data to the current program
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TRDIRT
USING G_IREF_PDOCUMENT
TEXTS_NODE 'TRDIRT'.
ENDIF.

ENDFORM.                    " get_program_texts

*&---------------------------------------------------------------------*
*&      Form  read_program_data
*&---------------------------------------------------------------------*
FORM READ_PROGRAM_DATA TABLES LT_TEXTELM STRUCTURE TEXTPOOL
CLASS_INCLUDES TYPE PROG_TAB_TYPE
P_FORMS
P_MODU
USING P_NAME TYPE PROGNAME
P_RFC_DEST TYPE RFCDEST
P_READ_SOURCE TYPE C
P_READ_TEXTELEMENTS TYPE C
P_READ_FORMS TYPE C
P_READ_MODU TYPE C
CHANGING P_SOURCE TYPE STRING
P_READ_SOURCE_RC TYPE I
P_SOURCE_LINE_COUNT TYPE I.

DATA: LT_SOURCE TYPE TABLE OF ABAPSOURCE WITH HEADER LINE,
LT_SOURCE_EXT TYPE TABLE OF ABAPTXT255 WITH HEADER LINE,
LT_UNIFIED_SOURCE TYPE TT_UNIFIED_SOURCE WITH HEADER LINE,
IS_FIRST TYPE C.

CLEAR: P_READ_SOURCE_RC.
CLEAR: P_SOURCE_LINE_COUNT.

IF P_READ_SOURCE = 'X'.

CALL FUNCTION 'RPY_PROGRAM_READ' DESTINATION P_RFC_DEST
EXPORTING
LANGUAGE         = 'E'
PROGRAM_NAME     = P_NAME
TABLES
SOURCE           = LT_SOURCE
SOURCE_EXTENDED  = LT_SOURCE_EXT
EXCEPTIONS
CANCELLED        = 1
NOT_FOUND        = 2
PERMISSION_ERROR = 3
OTHERS           = 4.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'canceled'.
WHEN 2. ERROR = 'not_found'.
WHEN 3. ERROR = 'permission_error'.
WHEN 4. ERROR = 'Others'.
ENDCASE.

P_READ_SOURCE_RC = SY-SUBRC.
CONCATENATE 'read program source: RPY_PROGRAM_READ, program:'
P_NAME 'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

IF NOT LT_SOURCE[] IS INITIAL.
LT_UNIFIED_SOURCE[] = LT_SOURCE[].
ELSE.
LT_UNIFIED_SOURCE[] = LT_SOURCE_EXT[].
ENDIF.

DESCRIBE TABLE LT_UNIFIED_SOURCE LINES P_SOURCE_LINE_COUNT.

CLEAR P_SOURCE.

* Don't start new line for first line
LOOP AT LT_UNIFIED_SOURCE.
REPLACE ']]>' WITH CDATA_END_REPLACE INTO LT_UNIFIED_SOURCE-LINE.
IF IS_FIRST IS INITIAL.
P_SOURCE = LT_UNIFIED_SOURCE-LINE.
IS_FIRST = 'X'.
ELSE.
CONCATENATE P_SOURCE LT_UNIFIED_SOURCE-LINE INTO P_SOURCE
SEPARATED BY GV_ENDLINE.
ENDIF.
ENDLOOP.

IF NOT P_READ_FORMS IS INITIAL.
PERFORM GET_SUBROUTINE_FOR_PROGRAM TABLES LT_UNIFIED_SOURCE
P_FORMS
USING 'FORM'.
ENDIF.
IF NOT P_READ_MODU IS INITIAL.
PERFORM GET_SUBROUTINE_FOR_PROGRAM TABLES LT_UNIFIED_SOURCE
P_MODU
USING 'MODULE'.
ENDIF.

ENDIF.

IF P_READ_TEXTELEMENTS = 'X'.
CLEAR LT_TEXTELM.
REFRESH LT_TEXTELM.
PERFORM GET_TEXT_ELEMENTS TABLES LT_TEXTELM
CLASS_INCLUDES
USING P_NAME P_RFC_DEST.
ENDIF.

ENDFORM.                    "READ_PROGRAM_DATA

*&---------------------------------------------------------------------*
*&      Form  get_program_source
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_SOURCE TABLES CLASS_INCLUDES TYPE PROG_TAB_TYPE
USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE
LV_SOURCE_WITH_EXT.

DATA: SOURCE_NODE   TYPE XML_ELEMENT,
TEXTELM_NODE  TYPE XML_ELEMENT,
FORM_NODE     TYPE XML_ELEMENT,
MODULES_NODE  TYPE XML_ELEMENT,
LT_TEXTELM TYPE TABLE OF TEXTPOOL WITH HEADER LINE,
CDATA_ELEM TYPE REF TO IF_IXML_ELEMENT,
LV_STRING TYPE STRING,
IS_FIRST TYPE C,
READ_SOURCE_RC TYPE I,
LV_SOURCE_LINE_COUNT TYPE I,
FORMS_TAB TYPE SUBROUTINE_TAB_TYPE,
MODU_TAB  TYPE SUBROUTINE_TAB_TYPE.

FIELD-SYMBOLS: <LS_PROG> LIKE LT_PROG_EXP.

*   Create a node for the Program Text Elements
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'TEXT_ELEMENTS'
CHANGING TEXTELM_NODE.

ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

PERFORM READ_PROGRAM_DATA TABLES LT_TEXTELM CLASS_INCLUDES
FORMS_TAB
MODU_TAB
USING <LS_PROG>-NAME 'NONE' 'X' 'X' 'X' 'X'
CHANGING LV_STRING READ_SOURCE_RC
LV_SOURCE_LINE_COUNT.

IF READ_SOURCE_RC = 0.

*   Add the Program Source data to the current program
PERFORM CREATE_XML_NODE_VALUE_CDATA USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'SOURCE' LV_STRING 'X'
CHANGING CDATA_ELEM.

IF NOT CDATA_ELEM IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING CDATA_ELEM
'LINE_COUNT' LV_SOURCE_LINE_COUNT.
ENDIF.

ENDIF.

IF NOT LT_TEXTELM[] IS INITIAL.
SORT LT_TEXTELM.
DELETE ADJACENT DUPLICATES FROM LT_TEXTELM COMPARING ID KEY.

*     Add the Text Elements data to the current program
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TEXTELM
USING G_IREF_PDOCUMENT
TEXTELM_NODE 'TEXT_ELEMENT'.
ENDIF.

IF NOT FORMS_TAB[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'FORMS'
CHANGING FORM_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES FORMS_TAB
USING  G_IREF_PDOCUMENT
FORM_NODE 'FORM'.
ENDIF.
IF NOT MODU_TAB[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'MODULES'
CHANGING MODULES_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES MODU_TAB
USING  G_IREF_PDOCUMENT
MODULES_NODE 'MODULE'.
ENDIF.

ENDFORM.                    " get_program_source

*&---------------------------------------------------------------------*
*&      Form  get_program_mains
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_MAINS USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

DATA: MAINS_NODE     TYPE XML_ELEMENT,
LT_MAINS       TYPE PROG_TAB_TYPE,
LV_MAINS_COUNT TYPE I.

FIELD-SYMBOLS: <LS_PROG> LIKE LT_PROG_EXP.

* Create a node for the program mains
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'MAINS'
CHANGING MAINS_NODE.

ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

CLEAR LT_MAINS[].

* Get the active mains of the program
SELECT MASTER FROM D010INC
INTO TABLE LT_MAINS
WHERE INCLUDE = <LS_PROG>-NAME.

* Get the inactive mains of the program
SELECT MASTER FROM RSEUINC
APPENDING TABLE LT_MAINS
WHERE INCLUDE = <LS_PROG>-NAME.

DESCRIBE TABLE LT_MAINS LINES LV_MAINS_COUNT.

IF ( NOT LT_MAINS[] IS INITIAL ) AND
( LV_MAINS_COUNT < MAX_MAINS ) .

SORT LT_MAINS.
DELETE ADJACENT DUPLICATES FROM LT_MAINS.

*   Add the mains of the current program
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_MAINS
USING G_IREF_PDOCUMENT
MAINS_NODE 'MAIN'.
ENDIF.

ENDFORM.                    " get_program_mains

*---------------------------------------------------------------------*
*       FORM get_function_group_program_name
*---------------------------------------------------------------------*
FORM GET_FUGR_PROGRAM_NAME
USING    FUNCTION_GROUP_NAME LIKE  RS38L-INCLUDE
CHANGING PROGRAM_NAME TYPE RS38L-INCLUDE
NAME LIKE RS38L-INCLUDE
NAMESPACE LIKE RS38L-NAMESPACE.

CALL FUNCTION 'RS_NAME_SPLIT_NAMESPACE'
EXPORTING
NAME_WITH_NAMESPACE    = FUNCTION_GROUP_NAME
IMPORTING
NAMESPACE              = NAMESPACE
NAME_WITHOUT_NAMESPACE = NAME
EXCEPTIONS
DELIMITER_ERROR        = 1
OTHERS                 = 2.
IF SY-SUBRC <> 0.
NAMESPACE = ''.
ENDIF.

IF NAME CP 'SAPL*'.
CONCATENATE NAMESPACE NAME INTO PROGRAM_NAME.
ELSE.
CONCATENATE NAMESPACE 'SAPL' NAME INTO PROGRAM_NAME.
ENDIF.

ENDFORM.                    "get_fugr_program_name
*---------------------------------------------------------------------*
*       FORM extract_functions
*---------------------------------------------------------------------*
FORM EXTRACT_FUNCTIONS.

DATA: LT_FUNC            TYPE T_FUNCTION_TYPE,
TITLE_NODE         TYPE XML_ELEMENT,
FUNCTIONS_NODE     TYPE XML_ELEMENT,
LT_FUNCTIONS_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
LT_OBJ_FUNC        TYPE TABLE OF RSEUI_SET,
LS_OBJ_PROG        TYPE RSEUI_SET,
LV_PROGNAME        TYPE RPY_PROG-PROGNAME,
LV_FUGR            LIKE RS38L-INCLUDE,
LT_INCLUDE         TYPE TABLE OF RPY_REPO WITH HEADER LINE,
LT_FUPARAREF       TYPE TABLE OF FUPARAREF.

* For Function: RPY_FUNCTIONMODULE_READ/RPY_FUNCTIONMODULE_READ_NEW
DATA: LV_GLOBAL_FLAG        LIKE RS38L-GLOBAL,
LV_REMOTE_CALL        LIKE RS38L-REMOTE,
LV_UPDATE_TASK        LIKE RS38L-UTASK,
LV_SHORT_TEXT         LIKE TFTIT-STEXT,
LV_FUNCTION_POOL      LIKE RS38L-AREA,
LT_IMPORT_PARAMETER   TYPE TABLE OF RSIMP,
LT_CHANGING_PARAMETER TYPE TABLE OF RSCHA,
LT_EXPORT_PARAMETER   TYPE TABLE OF RSEXP,
LT_TABLES_PARAMETER   TYPE TABLE OF RSTBL,
LT_EXCEPTION_LIST     TYPE TABLE OF RSEXC,
LT_DOCUMENTATION      TYPE TABLE OF RSFDO,
LT_SOURCE             TYPE TABLE OF T_FUNCTION_SOURCE ,
LV_PNAME              TYPE TFDIR-PNAME,
RC                    LIKE SY-SUBRC,
FUGR_NAME_PART        LIKE RS38L-INCLUDE,
FUGR_NAMESPACE        LIKE RS38L-NAMESPACE,
UXX_INCLUDE           TYPE TFDIR-PNAME,
FLAG                  TYPE BOOLEAN,
INCLUDE_NAME          LIKE D010INC-INCLUDE,
FUNCNAME              LIKE  RS38L-NAME,
FUNC_INCLUDE          LIKE  RS38L-INCLUDE,
L_STARTTIME           LIKE SY-UZEIT,
INC_NAME              LIKE TRDIR-NAME.

FIELD-SYMBOLS: <LS_FUNC> LIKE LINE OF LT_FUNC.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING
'Extracting function groups & function modules'.

* Add ALL function group includes to the programs list
* ----------------------------------------------------
LOOP AT GT_OBJ_FUNC INTO GS_OBJECTLIST.

*   Get the function group's program name
LV_FUGR = GS_OBJECTLIST-OBJ_NAME.
PERFORM GET_FUGR_PROGRAM_NAME USING LV_FUGR
CHANGING LV_PROGNAME
FUGR_NAME_PART
FUGR_NAMESPACE.

*   Get the function modules of the current func. group
SELECT * FROM TFDIR
APPENDING CORRESPONDING FIELDS OF TABLE LT_FUNC
WHERE  PNAME = LV_PROGNAME.

*   Continue collecting function group includes only if the current
*   processed
*   function group is not a fugr of an ABAP query. (includes of AQ are
*   added as programs in a previous step)
*   Pay attention that the function modules of the function group are
*   collected
CHECK LV_FUGR NP '/1BCDWB/IQ*'.

*   Add Function group's program to the list of programs - will
*   be read with the rest of the programs
CLEAR LS_OBJ_PROG.
LS_OBJ_PROG-OBJ_TYPE = 'PROG'.
LS_OBJ_PROG-OBJ_NAME = LV_PROGNAME.
APPEND LS_OBJ_PROG TO GT_OBJ_PROG.

*   Add the UXX include (doesn't return in function group includes list)
CONCATENATE FUGR_NAMESPACE 'L' FUGR_NAME_PART 'UXX' INTO
UXX_INCLUDE.
LS_OBJ_PROG-OBJ_NAME = UXX_INCLUDE.
APPEND LS_OBJ_PROG TO GT_OBJ_PROG.

*   Get the function group includes
REFRESH LT_INCLUDE.

*   Get active include
SELECT INCLUDE FROM D010INC
INTO   INCLUDE_NAME
WHERE MASTER = LV_PROGNAME
AND   INCLUDE NOT LIKE 'L%V__'
AND   INCLUDE NOT LIKE 'L%$__'.
LT_INCLUDE-INCLNAME = INCLUDE_NAME.
APPEND LT_INCLUDE.
ENDSELECT.

*   Get inactive include
SELECT INCLUDE FROM RSEUINC
INTO   INCLUDE_NAME
WHERE MASTER = LV_PROGNAME
AND   INCLUDE NOT LIKE 'L%V__'
AND   INCLUDE NOT LIKE 'L%$__'.
LT_INCLUDE-INCLNAME = INCLUDE_NAME.
APPEND LT_INCLUDE.
ENDSELECT.

IF LT_INCLUDE[] IS INITIAL.

PERFORM READ_PROGRAM_INCLUDES TABLES LT_INCLUDE
USING LV_PROGNAME.

IF LT_INCLUDE[] IS INITIAL.
CONCATENATE 'FUGRINC: ' LV_PROGNAME
'2. not found includes in db tables and in source scan'
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
CONCATENATE 'FUGRINC: ' LV_PROGNAME
'3. found includes in source scan' INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

ELSE.
CONCATENATE 'FUGRINC: ' LV_PROGNAME
'1. found includes in db tables' INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

*   Add the function group includes as programs,
*   In the case of vanilla extraction, add standard
*   includes instead of customer's.
LOOP AT LT_INCLUDE.
PERFORM IS_CUSTOMER_DEV_INCLUDE USING LT_INCLUDE-INCLNAME
CHANGING FLAG.
IF ( FLAG NE VANILLA ).
LS_OBJ_PROG-OBJ_NAME = LT_INCLUDE-INCLNAME.
APPEND LS_OBJ_PROG TO GT_OBJ_PROG.
ENDIF.
ENDLOOP.
ENDLOOP.

FREE GT_OBJ_FUNC.

CHECK NOT LT_FUNC[] IS INITIAL.
SORT LT_FUNC.
* Get all functions for Extracting BTE user exits
PERFORM GET_BTE_USER_EXITS USING LT_FUNC.

* Create a child node for the Functions node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'FUNCTIONS'
CHANGING FUNCTIONS_NODE.

* Add Functions data
PERFORM ADD_ITAB_TO_XML TABLES LT_FUNC LT_FUNCTIONS_NODES
USING G_IREF_PDOCUMENT FUNCTIONS_NODE
'FUNCTION'.

PERFORM APPEND_STRING_TO_FILE USING '<FUNCTIONS>'.

* Extract the function modules data to the xml
* --------------------------------------------
LOOP AT LT_FUNCTIONS_NODES.

ASSIGN LT_FUNCTIONS_NODES-WA->* TO <LS_FUNC>.
CHECK SY-SUBRC = 0.

CLEAR: LV_GLOBAL_FLAG, LV_REMOTE_CALL, LV_UPDATE_TASK,
LV_SHORT_TEXT, LV_FUNCTION_POOL.
FREE:  LT_IMPORT_PARAMETER, LT_CHANGING_PARAMETER,
LT_EXPORT_PARAMETER, LT_TABLES_PARAMETER,
LT_EXCEPTION_LIST, LT_DOCUMENTATION, LT_SOURCE.

*   Get function parameters
SELECT *
FROM   FUPARAREF
INTO   TABLE LT_FUPARAREF
WHERE  FUNCNAME = <LS_FUNC>-FUNCNAME.

*   Get Function meta data
PERFORM READ_FUNCTION_MODULE_INTERFACE
TABLES LT_IMPORT_PARAMETER
LT_CHANGING_PARAMETER
LT_EXPORT_PARAMETER
LT_TABLES_PARAMETER
LT_EXCEPTION_LIST
LT_DOCUMENTATION
LT_SOURCE
USING  <LS_FUNC>-FUNCNAME
CHANGING LV_GLOBAL_FLAG
LV_REMOTE_CALL
LV_UPDATE_TASK
LV_SHORT_TEXT
LV_FUNCTION_POOL
RC.
IF RC <> 0.
CLEAR ERROR.
CASE RC.
WHEN 1. ERROR = 'error_message'.
WHEN 2. ERROR = 'function_not_found'.
WHEN 3. ERROR = 'invalid_name'.
WHEN 4. ERROR = 'others'.
ENDCASE.

CONCATENATE
'extract functions: read_function_module_interface, function:'
<LS_FUNC>-FUNCNAME 'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
CHECK RC = 0.

*   Get the function group of the current function module
SELECT SINGLE PNAME FROM TFDIR
INTO LV_PNAME
WHERE  FUNCNAME = <LS_FUNC>-FUNCNAME.
IF SY-SUBRC = 0.
PERFORM GET_FUGR_FROM_FUGR_PROG USING LV_PNAME
CHANGING LV_FUGR.
ELSE.
CLEAR LV_FUGR.
ENDIF.

*   Find the function's include file name
FUNCNAME = <LS_FUNC>-FUNCNAME.
CALL FUNCTION 'FUNCTION_INCLUDE_INFO'
CHANGING
FUNCNAME            = FUNCNAME
INCLUDE             = FUNC_INCLUDE
EXCEPTIONS
FUNCTION_NOT_EXISTS = 1
INCLUDE_NOT_EXISTS  = 2
GROUP_NOT_EXISTS    = 3
NO_SELECTIONS       = 4
NO_FUNCTION_INCLUDE = 5
OTHERS              = 6.

IF SY-SUBRC <> 0.
ENDIF.

*   Add Function meta data - Parameters
PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
'GLOBAL_FLAG' LV_GLOBAL_FLAG.
PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
'REMOTE_CALL' LV_REMOTE_CALL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
'UPDATE_TASK' LV_UPDATE_TASK.
PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
'SHORT_TEXT' LV_SHORT_TEXT.
PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
'FUNCTION_POOL' LV_FUGR.
PERFORM ADD_ATTRIBUTE_TO_NODE USING LT_FUNCTIONS_NODES-NODE_REF
'INCLUDE_NAME' FUNC_INCLUDE.

*   Create node for parameters table
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LT_FUNCTIONS_NODES-NODE_REF
'PARAMETERS_TABLE'
CHANGING TITLE_NODE.

*   Add the function parameters table to the XML
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_FUPARAREF
USING G_IREF_PDOCUMENT TITLE_NODE
'FUPARAREF'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LT_FUNCTIONS_NODES-NODE_REF 'X'.
DELETE LT_FUNCTIONS_NODES.

ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '</FUNCTIONS>'.

PERFORM ADD_TIME_STAT USING 'Extract functions' L_STARTTIME.

ENDFORM.                          " extract_functions
*&---------------------------------------------------------------------*
*&      Form  extract_transactions
*&---------------------------------------------------------------------*
FORM EXTRACT_TRANSACTIONS.

CONSTANTS: REPORT_TRANSACTION_CINFO TYPE X VALUE '80'.

TABLES: TSTCP.

DATA: LT_TSTC   TYPE TABLE OF TSTC  WITH HEADER LINE,
LT_TSTCT  TYPE TABLE OF TSTCT,
L_STARTTIME LIKE SY-UZEIT.

DATA: BEGIN OF LT_TSTCP  OCCURS 0.
INCLUDE STRUCTURE TSTCP.
DATA:   BASE_TCODE  TYPE TSTC-TCODE,
END OF LT_TSTCP.

RANGES: R_TCODE FOR TSTC-TCODE.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting transactions'.

* Set Object list
LOOP AT GT_OBJ_TRNS INTO GS_OBJECTLIST.
CLEAR R_TCODE.
R_TCODE-SIGN   = 'I'.
R_TCODE-OPTION = 'EQ'.
R_TCODE-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_TCODE.
ENDLOOP.

FREE GT_OBJ_TRNS.

CHECK NOT R_TCODE[] IS INITIAL.

* Get Transaction Codes list
IF NOT R_TCODE[] IS INITIAL.
SELECT * FROM  TSTC  AS TS
INTO TABLE LT_TSTC
FOR ALL ENTRIES IN R_TCODE
WHERE  TCODE = R_TCODE-LOW.
ENDIF.

SORT LT_TSTC.

CHECK NOT LT_TSTC[] IS INITIAL.

LOOP AT LT_TSTC.
IF LT_TSTC-DYPNO IS INITIAL AND
LT_TSTC-CINFO = REPORT_TRANSACTION_CINFO.
LT_TSTC-DYPNO = '1000'.
MODIFY LT_TSTC TRANSPORTING DYPNO.
ENDIF.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<TRANSACTIONS>'.

PERFORM APPEND_STRING_TO_FILE USING '<BASE_TRANSACTIONS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TSTC
USING G_IREF_PDOCUMENT
'TSTC'.
PERFORM APPEND_STRING_TO_FILE USING '</BASE_TRANSACTIONS>'.
FREE LT_TSTC.

* Get Transactions Text 'TSTCT'
IF NOT R_TCODE[] IS INITIAL.
SELECT * FROM  TSTCT
INTO TABLE LT_TSTCT
FOR ALL ENTRIES IN R_TCODE
WHERE  TCODE = R_TCODE-LOW.
ENDIF.
SORT LT_TSTCT.

PERFORM APPEND_STRING_TO_FILE USING '<TRANSACTIONS_TEXT>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TSTCT
USING G_IREF_PDOCUMENT
'TSTCT'.
PERFORM APPEND_STRING_TO_FILE USING '</TRANSACTIONS_TEXT>'.
FREE LT_TSTCT.

* Get Parameters Transaction Codes list 'TSTCP'
IF NOT R_TCODE[] IS INITIAL.
SELECT * FROM  TSTCP
INTO TABLE LT_TSTCP
FOR ALL ENTRIES IN R_TCODE
WHERE  TCODE = R_TCODE-LOW.
ENDIF.
SORT LT_TSTCP.

LOOP AT LT_TSTCP.
GV_TABIX = SY-TABIX.
* Get Transaction
CALL FUNCTION 'RS_TRANSACTION_SINGLE_GET'
EXPORTING
PARAMETER_TCODE = LT_TSTCP-TCODE
IMPORTING
TCODE           = LT_TSTCP-BASE_TCODE.
MODIFY LT_TSTCP INDEX GV_TABIX TRANSPORTING BASE_TCODE.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<PARAM_TRANSACTIONS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TSTCP
USING G_IREF_PDOCUMENT
'TSTCP'.
PERFORM APPEND_STRING_TO_FILE USING '</PARAM_TRANSACTIONS>'.
FREE LT_TSTCP.

PERFORM APPEND_STRING_TO_FILE USING '</TRANSACTIONS>'.

PERFORM ADD_TIME_STAT USING 'Extract transactions' L_STARTTIME.

ENDFORM.                    " extract_transactions

*&---------------------------------------------------------------------*
*&      Form  extract_logical_data_bases
*&---------------------------------------------------------------------*
FORM EXTRACT_LOGICAL_DATABASES.
CHECK TESTING_DATA_ONLY IS INITIAL.
DATA: LT_LDBN  TYPE TABLE OF LDBN,
LT_LDBD  TYPE TABLE OF LDBD WITH HEADER LINE,
LT_LDBT  TYPE TABLE OF LDBT,
L_STARTTIME LIKE SY-UZEIT.

DATA: BEGIN OF LT_LDB_SHLP OCCURS 0,
LDBNAME TYPE LDBNAM.
INCLUDE STRUCTURE DDSHLDB1.
DATA: END OF LT_LDB_SHLP,
LT_DDSHLDB1 TYPE TABLE OF DDSHLDB1 WITH HEADER LINE.

RANGES: R_LDBNAME FOR LDBN-LDBNAME.


L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING
'Extracting logical databases'.

* Set Object list
LOOP AT GT_OBJ_LGDB INTO GS_OBJECTLIST.
CLEAR R_LDBNAME.
R_LDBNAME-SIGN   = 'I'.
R_LDBNAME-OPTION = 'EQ'.
R_LDBNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_LDBNAME.
ENDLOOP.

FREE GT_OBJ_LGDB.

CHECK NOT R_LDBNAME[] IS INITIAL.

* Get Logical Data Bases admin info
IF NOT R_LDBNAME[] IS INITIAL.
SELECT * FROM  LDBD
INTO TABLE LT_LDBD
FOR ALL ENTRIES IN R_LDBNAME
WHERE  LDBNAME = R_LDBNAME-LOW.
ENDIF.

LOOP AT LT_LDBD WHERE NOT SHLPNAME IS INITIAL.

LT_LDB_SHLP-LDBNAME = LT_LDBD-LDBNAME.

*   Get the search help parameters
REFRESH LT_DDSHLDB1.
CALL FUNCTION 'DD_SHLP_GET_OUTPARAMS'
EXPORTING
SHLP_NAME  = LT_LDBD-SHLPNAME
TABLES
FIELDS_TAB = LT_DDSHLDB1.
LOOP AT LT_DDSHLDB1.
MOVE-CORRESPONDING LT_DDSHLDB1 TO LT_LDB_SHLP.
APPEND LT_LDB_SHLP.
ENDLOOP.

ENDLOOP.

CHECK NOT LT_LDBD[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASES>'.

PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_ADMIN_INFO>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDBD
USING G_IREF_PDOCUMENT
'LDBD'.
PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASE_ADMIN_INFO>'.
FREE LT_LDBD.

* Get Logical Data Bases nodes
PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_NODES>'.

IF NOT R_LDBNAME[] IS INITIAL.
SELECT * FROM  LDBN
INTO TABLE LT_LDBN PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_LDBNAME
WHERE  LDBNAME = R_LDBNAME-LOW.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDBN
USING G_IREF_PDOCUMENT
'LDBN'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASE_NODES>'.
FREE LT_LDBN.

PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_SEARCH_HELP>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDB_SHLP
USING G_IREF_PDOCUMENT
'LDB_SHLP'.
PERFORM APPEND_STRING_TO_FILE USING
'</LOGICAL_DATA_BASE_SEARCH_HELP>'.
FREE LT_LDB_SHLP.

* Get Logical Data Bases Text
PERFORM APPEND_STRING_TO_FILE USING '<LOGICAL_DATA_BASE_TEXT>'.
IF NOT R_LDBNAME[] IS INITIAL.
SELECT * FROM  LDBT
INTO TABLE LT_LDBT PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_LDBNAME
WHERE  LDBNAME = R_LDBNAME-LOW.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LDBT
USING G_IREF_PDOCUMENT
'LDBT'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASE_TEXT>'.
FREE LT_LDBT.

PERFORM APPEND_STRING_TO_FILE USING '</LOGICAL_DATA_BASES>'.

PERFORM ADD_TIME_STAT USING 'Extract LDBs' L_STARTTIME.

ENDFORM.                    " extract_logical_data_bases

*&---------------------------------------------------------------------*
*&      Form  extract_messages
*&---------------------------------------------------------------------*
FORM EXTRACT_MESSAGES.
CHECK IA_DATA_ONLY IS INITIAL.
DATA: LT_T100   TYPE TABLE OF T100,
LT_T100A  TYPE TABLE OF T100A WITH HEADER LINE,
LT_T100A1 TYPE TABLE OF T100A,
LT_T100T  TYPE TABLE OF T100T,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_ARBGB FOR T100A-ARBGB.

PERFORM UPDATE_PROGRESS USING 'Extracting messages'.

L_STARTTIME = SY-UZEIT.

* Set Object list
LOOP AT GT_OBJ_MESG INTO GS_OBJECTLIST.
CLEAR R_ARBGB.
R_ARBGB-SIGN   = 'I'.
R_ARBGB-OPTION = 'EQ'.
R_ARBGB-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_ARBGB.
ENDLOOP.

FREE GT_OBJ_MESG.

CHECK NOT R_ARBGB[] IS INITIAL.

* Get Messages IDs
IF NOT R_ARBGB[] IS INITIAL.
SELECT * FROM  T100A
INTO TABLE LT_T100A
FOR ALL ENTRIES IN R_ARBGB
WHERE  ARBGB = R_ARBGB-LOW.
ENDIF.

CHECK NOT LT_T100A[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<MESSAGES>'.

LOOP AT LT_T100A.

PERFORM APPEND_STRING_TO_FILE USING '<MESSAGE_GROUP>'.

FREE: LT_T100A1.
APPEND LT_T100A TO LT_T100A1.
*   Add Message Header data
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T100A1
USING G_IREF_PDOCUMENT
'MESSAGE_HEADER'.
FREE LT_T100A1.

*   Get Message Text
SELECT * FROM  T100T
INTO TABLE LT_T100T
WHERE  ARBGB  = LT_T100A-ARBGB.
*   Add the Message text
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T100T
USING G_IREF_PDOCUMENT
'MESSAGE_TEXT'.
FREE LT_T100T.

*   Get Messages list
SELECT * FROM  T100
INTO TABLE LT_T100
WHERE  ARBGB  = LT_T100A-ARBGB.
*   Add the Messages list
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T100
USING G_IREF_PDOCUMENT
'MESSAGE_NO'.
FREE LT_T100.

PERFORM APPEND_STRING_TO_FILE USING '</MESSAGE_GROUP>'.

ENDLOOP.

FREE LT_T100A.

PERFORM APPEND_STRING_TO_FILE USING '</MESSAGES>'.

PERFORM ADD_TIME_STAT USING 'Extract messages' L_STARTTIME.

ENDFORM.                    " extract_messages

*&---------------------------------------------------------------------*
*&      Form  extract_tables
*&---------------------------------------------------------------------*
FORM EXTRACT_TABLES.

TYPES: BEGIN OF DD03L_TYPE,
TABNAME LIKE DD03L-TABNAME,
FIELDNAME LIKE DD03L-FIELDNAME,
END OF DD03L_TYPE.

DATA: LT_DD02L   TYPE TABLE OF DD02L,
LT_DD02T   TYPE TABLE OF DD02T,
LT_DD09L   TYPE TABLE OF DD09L,
LT_DD03L   TYPE TABLE OF DD03L_TYPE,
LT_DD03T   TYPE TABLE OF DD03T,
LT_DD12V   TYPE TABLE OF DD12V,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_TABNAME FOR DD02L-TABNAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting DB tables'.

* Set Object list
LOOP AT GT_OBJ_TABL INTO GS_OBJECTLIST.
CLEAR R_TABNAME.
R_TABNAME-SIGN   = 'I'.
R_TABNAME-OPTION = 'EQ'.
R_TABNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_TABNAME.

READ TABLE MODIFIED_OBJECTS
WITH KEY OBJ_TYPE = 'TABL'
OBJ_NAME = GS_OBJECTLIST-OBJ_NAME
TRANSPORTING NO FIELDS.
IF SY-SUBRC <> 0.
G_TABNAME_INDEX = R_TABNAME.
APPEND G_TABNAME_INDEX.
ENDIF.

ENDLOOP.

* Add also the SAP types with append structure
IF NOT G_APP_STRUC IS INITIAL.
APPEND LINES OF G_APP_STRUC TO R_TABNAME.
ENDIF.
* Add also the SAP types with customer include
IF NOT G_INC_STRUC IS INITIAL.
APPEND LINES OF G_INC_STRUC TO R_TABNAME.
ENDIF.

CHECK NOT R_TABNAME[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<TABLES>'.

* Get Table Data 'DD02L'
PERFORM APPEND_STRING_TO_FILE USING '<TABLE_METADATA>'.

IF NOT R_TABNAME[] IS INITIAL.
SELECT * FROM  DD02L
INTO TABLE LT_DD02L PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_TABNAME
WHERE  TABNAME = R_TABNAME-LOW
AND    AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD02L
USING G_IREF_PDOCUMENT
'DD02L'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</TABLE_METADATA>'.
FREE LT_DD02L.

** Get Table Text 'DD02T'
*  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TEXT>'.
*  IF NOT R_TABNAME[] IS INITIAL.
*    SELECT * FROM  DD02T
*    INTO TABLE LT_DD02T PACKAGE SIZE PAC_SIZE
*    FOR ALL ENTRIES IN R_TABNAME
*    WHERE  TABNAME = R_TABNAME-LOW
*    AND    AS4LOCAL = 'A'
*    AND AS4VERS = '0000'.   " Take only the active version
*
*      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD02T
*                                     USING G_IREF_PDOCUMENT
*                                           'DD02T'.
*    ENDSELECT.
*  ENDIF.
*  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TEXT>'.
*  FREE LT_DD02T.
*
** Get Table Technical settings 'DD09L'
*  PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TECHNICAL>'.
*  IF NOT R_TABNAME[] IS INITIAL.
*    SELECT * FROM  DD09L
*    INTO TABLE LT_DD09L PACKAGE SIZE PAC_SIZE
*    FOR ALL ENTRIES IN R_TABNAME
*    WHERE  TABNAME = R_TABNAME-LOW
*    AND    AS4LOCAL = 'A'
*    AND AS4VERS = '0000'.   " Take only the active version
*
*      PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD09L
*                                     USING G_IREF_PDOCUMENT
*                                           'DD09L'.
*    ENDSELECT.
*  ENDIF.
*  PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TECHNICAL>'.
*  FREE LT_DD09L.

* Get Table Fields 'DD03L'
PERFORM APPEND_STRING_TO_FILE USING '<TABLE_FIELD_METADATA>'.
IF NOT R_TABNAME[] IS INITIAL.
SELECT TABNAME FIELDNAME FROM  DD03L
INTO CORRESPONDING FIELDS OF TABLE LT_DD03L PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_TABNAME
WHERE  TABNAME = R_TABNAME-LOW
AND    AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD03L
USING G_IREF_PDOCUMENT
'DD03L'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</TABLE_FIELD_METADATA>'.
FREE LT_DD03L.

* Get Table Fields Text 'DD03T'
PERFORM APPEND_STRING_TO_FILE USING '<TABLE_FIELD_TEXT>'.
IF NOT R_TABNAME[] IS INITIAL.
SELECT * FROM  DD03T
INTO TABLE LT_DD03T PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_TABNAME
WHERE  TABNAME = R_TABNAME-LOW
AND    AS4LOCAL = 'A'.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD03T
USING G_IREF_PDOCUMENT
'DD03T'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</TABLE_FIELD_TEXT>'.
FREE LT_DD03T.

IF NO_SUET_DATA IS INITIAL.
*   Get Table Indexes 'DD12V'
*   Don't get indexes that were created by SAP or DDIC,
*   This could happen in case of an index created by
*   SAP or DDIC on a generated table.
PERFORM APPEND_STRING_TO_FILE USING '<TABLE_INDEXES>'.
IF NOT G_TABNAME_INDEX[] IS INITIAL.
SELECT SQLTAB INDEXNAME DDLANGUAGE DDTEXT FROM DD12V
INTO CORRESPONDING FIELDS OF TABLE LT_DD12V PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN G_TABNAME_INDEX
WHERE SQLTAB = G_TABNAME_INDEX-LOW
AND NOT AS4USER IN ('SAP','DDIC')
AND DDLANGUAGE IN ('E',SY-LANGU).

SORT LT_DD12V BY SQLTAB INDEXNAME DDLANGUAGE.
DELETE ADJACENT DUPLICATES FROM LT_DD12V
COMPARING SQLTAB INDEXNAME DDLANGUAGE.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD12V
USING  G_IREF_PDOCUMENT
'DD12V'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</TABLE_INDEXES>'.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '</TABLES>'.

PERFORM ADD_TIME_STAT USING 'Extract tables' L_STARTTIME.


ENDFORM.                    " extract_tables

*---------------------------------------------------------------------*
*       FORM extract_views                                            *
*---------------------------------------------------------------------*
FORM EXTRACT_VIEWS.

TYPES: BEGIN OF VIEWS_TYPE,
TABNAME LIKE DD02L-TABNAME,
END OF VIEWS_TYPE.

DATA: LT_VIEWS TYPE TABLE OF VIEWS_TYPE,
VIEW_WA  LIKE LINE OF LT_VIEWS,
VIEW_NAME TYPE DDOBJNAME,
DD26V_TAB TYPE TABLE OF DD26V,
DD27P_TAB TYPE TABLE OF DD27P,
DD28J_TAB TYPE TABLE OF DD28J,
DD28V_TAB TYPE TABLE OF DD28V,
LT_VIEWS_NODES  TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
LS_VIEW_NODE    LIKE LINE OF LT_VIEWS_NODES,
VIEWS_NODE      TYPE XML_ELEMENT,
VIEW_BASE_TABLES_NODE TYPE XML_ELEMENT,
VIEW_FIELDS_NODE      TYPE XML_ELEMENT,
VIEW_JOIN_NODE        TYPE XML_ELEMENT,
VIEW_SELECTION_NODE   TYPE XML_ELEMENT,
DUMMY_TAB_HANDLES TYPE HANDLES_TAB_TYPE,
L_STARTTIME LIKE SY-UZEIT.

FIELD-SYMBOLS: <LS_VIEW> TYPE VIEWS_TYPE.

RANGES: R_VIEWS FOR DD02L-TABNAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting views'.

* Set Object list
LOOP AT GT_OBJ_VIEW INTO GS_OBJECTLIST.
CLEAR R_VIEWS.
R_VIEWS-SIGN   = 'I'.
R_VIEWS-OPTION = 'EQ'.
R_VIEWS-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_VIEWS.
ENDLOOP.

* Add also the SAP view types with * notion and
* tables that were changed by customer
IF NOT G_VIEW_WITH_AST IS INITIAL.
APPEND LINES OF G_VIEW_WITH_AST TO R_VIEWS.
ENDIF.

FREE GT_OBJ_VIEW.

CHECK NOT R_VIEWS[] IS INITIAL.

* Get the matching views
IF NOT R_VIEWS[] IS INITIAL.
SELECT * FROM DD02L
INTO CORRESPONDING FIELDS OF TABLE LT_VIEWS
FOR ALL ENTRIES IN R_VIEWS
WHERE TABNAME = R_VIEWS-LOW
AND   AS4LOCAL = 'A'
AND   TABCLASS = 'VIEW'
AND AS4VERS = '0000'.   " Take only the active version

ENDIF.

CHECK NOT LT_VIEWS[] IS INITIAL.

* Create a child node for the Views node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'VIEWS'
CHANGING VIEWS_NODE.

* Add the views data to the current node
PERFORM ADD_ITAB_TO_XML TABLES LT_VIEWS LT_VIEWS_NODES
USING G_IREF_PDOCUMENT VIEWS_NODE
'VIEW'.

PERFORM APPEND_STRING_TO_FILE USING '<VIEWS>'.

LOOP AT LT_VIEWS_NODES INTO LS_VIEW_NODE.

ASSIGN LS_VIEW_NODE-WA->* TO <LS_VIEW>.

CLEAR: VIEW_NAME, DD26V_TAB, DD27P_TAB,
DD28J_TAB, DD28V_TAB.

VIEW_NAME = <LS_VIEW>-TABNAME.
CALL FUNCTION 'DDIF_VIEW_GET'
EXPORTING
NAME          = VIEW_NAME
STATE         = 'A'
TABLES
DD26V_TAB     = DD26V_TAB
DD27P_TAB     = DD27P_TAB
DD28J_TAB     = DD28J_TAB
DD28V_TAB     = DD28V_TAB
EXCEPTIONS
ILLEGAL_INPUT = 1
OTHERS        = 2.

CHECK SY-SUBRC IS INITIAL.

*   Get base Tables of a View
*   -------------------------
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LS_VIEW_NODE-NODE_REF
'BASE_TABLES'
CHANGING VIEW_BASE_TABLES_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD26V_TAB
USING G_IREF_PDOCUMENT
VIEW_BASE_TABLES_NODE
'DD26V'.

*   Fields in an SAP Table View
*   ---------------------------
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LS_VIEW_NODE-NODE_REF
'FIELDS'
CHANGING VIEW_FIELDS_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD27P_TAB
USING G_IREF_PDOCUMENT
VIEW_FIELDS_NODE
'DD27P'.

*   joins of views
*   --------------
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LS_VIEW_NODE-NODE_REF
'JOINS'
CHANGING VIEW_JOIN_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD28J_TAB
USING G_IREF_PDOCUMENT
VIEW_JOIN_NODE
'DD28J'.

*   Selection Condition
*   -------------------
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LS_VIEW_NODE-NODE_REF
'SELECTION_CONDITIONS'
CHANGING VIEW_SELECTION_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES DD28V_TAB
USING G_IREF_PDOCUMENT
VIEW_SELECTION_NODE
'DD28V'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LS_VIEW_NODE-NODE_REF 'X'.
DELETE LT_VIEWS_NODES.

ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '</VIEWS>'.

PERFORM ADD_TIME_STAT USING 'Extract views' L_STARTTIME.

ENDFORM.                    "extract_views

*&---------------------------------------------------------------------*
*&      Form  extract_foreign_keys
*&---------------------------------------------------------------------*
FORM EXTRACT_FOREIGN_KEYS.

CHECK TESTING_DATA_ONLY IS INITIAL.
DATA: DOMAIN LIKE DD03L-DOMNAME,
LT_DD08L   TYPE TABLE OF DD08L  WITH HEADER LINE,
LT_DD05M1  TYPE TABLE OF DD05M,
LT_DD05M   TYPE TABLE OF DD05M,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_TABNAME FOR DD02L-TABNAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting foreign keys'.

* Set Object list
LOOP AT GT_OBJ_TABL INTO GS_OBJECTLIST.
CLEAR R_TABNAME.
R_TABNAME-SIGN   = 'I'.
R_TABNAME-OPTION = 'EQ'.
R_TABNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_TABNAME.
ENDLOOP.

FREE GT_OBJ_TABL.

CHECK NOT R_TABNAME[] IS INITIAL.

* Get Foreign Keys Data
IF NOT R_TABNAME[] IS INITIAL.
SELECT * FROM  DD08L
INTO TABLE LT_DD08L
FOR ALL ENTRIES IN R_TABNAME
WHERE  TABNAME = R_TABNAME-LOW
AND  AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

ENDIF.

CHECK NOT LT_DD08L[] IS INITIAL.

LOOP AT LT_DD08L WHERE CHECKTABLE = '*'.
SELECT SINGLE DOMNAME
FROM   DD03L
INTO   DOMAIN
WHERE  TABNAME = LT_DD08L-TABNAME
AND    FIELDNAME = LT_DD08L-FIELDNAME
AND    AS4LOCAL = LT_DD08L-AS4LOCAL
AND    AS4VERS = LT_DD08L-AS4VERS.

CHECK SY-SUBRC IS INITIAL.

SELECT SINGLE ENTITYTAB FROM DD01L
INTO LT_DD08L-CHECKTABLE
WHERE DOMNAME = DOMAIN
AND   AS4LOCAL = 'A'.

MODIFY LT_DD08L TRANSPORTING CHECKTABLE.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<FOREIGN_KEYS>'.

PERFORM APPEND_STRING_TO_FILE USING '<FOREIGN_KEY_DATA>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD08L
USING G_IREF_PDOCUMENT
'DD08L'.
PERFORM APPEND_STRING_TO_FILE USING '</FOREIGN_KEY_DATA>'.

* Get the Foreign Keys Fields
LOOP AT LT_DD08L.
CALL FUNCTION 'DD_TBFK_GET'
EXPORTING
FIELDNAME     = LT_DD08L-FIELDNAME
TABL_NAME     = LT_DD08L-TABNAME
TABLES
DD05M_TAB_N   = LT_DD05M1
EXCEPTIONS
ILLEGAL_VALUE = 1
OTHERS        = 2.
IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'illegal_value'.
WHEN 2. ERROR = 'Others'.
ENDCASE.

CONCATENATE 'extract foreign keys: DD_TBFK_GET, table:'
LT_DD08L-TABNAME 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
CHECK SY-SUBRC = 0.
APPEND LINES OF LT_DD05M1 TO LT_DD05M.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<FOREIGN_KEY_FIELDS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD05M
USING G_IREF_PDOCUMENT
'DD05M'.
PERFORM APPEND_STRING_TO_FILE USING '</FOREIGN_KEY_FIELDS>'.
FREE: LT_DD05M, LT_DD08L.

PERFORM APPEND_STRING_TO_FILE USING '</FOREIGN_KEYS>'.

PERFORM ADD_TIME_STAT USING 'Extract foreign keys' L_STARTTIME.

ENDFORM.                    " extract_foreign_keys

*&---------------------------------------------------------------------*
*&      Form  extract_data_elements
*&---------------------------------------------------------------------*
FORM EXTRACT_DATA_ELEMENTS.

TYPES: BEGIN OF DD04L_TYPE,
ROLLNAME LIKE DD04L-ROLLNAME,
END OF DD04L_TYPE.

DATA: LT_DD04L   TYPE TABLE OF DD04L_TYPE,
LT_DD04T   TYPE TABLE OF DD04T,
DD04L_WA   LIKE LINE OF LT_DD04L,
ABTYPE_INT LIKE  DD03L-INTTYPE,
ABLEN LIKE  DD03L-INTLEN,
L_STARTTIME LIKE SY-UZEIT.

DATA: BEGIN OF DATA_ELEMENTS OCCURS 0.
INCLUDE STRUCTURE DD04L.
DATA:   INTTYPE LIKE DFIES-INTTYPE,
INTLEN  LIKE DFIES-INTLEN,
END OF DATA_ELEMENTS,
DATA_ELEMENT LIKE LINE OF DATA_ELEMENTS.

RANGES: R_ROLLNAME FOR DD04L-ROLLNAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting data elements'.

* Set Object list
LOOP AT GT_OBJ_DELM INTO GS_OBJECTLIST.
CLEAR R_ROLLNAME.
R_ROLLNAME-SIGN   = 'I'.
R_ROLLNAME-OPTION = 'EQ'.
R_ROLLNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_ROLLNAME.
ENDLOOP.

FREE GT_OBJ_DELM.

CHECK NOT R_ROLLNAME[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<DATA_ELEMENTS>'.

* Get Data Elements Data 'DD04L'
PERFORM APPEND_STRING_TO_FILE USING '<DATA_ELEMENT_DATA>'.
IF NOT R_ROLLNAME[] IS INITIAL.
SELECT ROLLNAME FROM  DD04L
INTO CORRESPONDING FIELDS OF TABLE LT_DD04L PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_ROLLNAME
WHERE  ROLLNAME = R_ROLLNAME-LOW
AND    AS4LOCAL  = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD04L
USING G_IREF_PDOCUMENT
'DD04L'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</DATA_ELEMENT_DATA>'.
FREE LT_DD04L.

* Get Data Elements Text 'DD04T'
PERFORM APPEND_STRING_TO_FILE USING '<DATA_ELEMENT_TEXT>'.
IF NOT R_ROLLNAME[] IS INITIAL.
SELECT * FROM  DD04T
INTO TABLE LT_DD04T PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_ROLLNAME
WHERE  ROLLNAME = R_ROLLNAME-LOW
AND    AS4LOCAL  = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD04T
USING G_IREF_PDOCUMENT
'DD04T'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</DATA_ELEMENT_TEXT>'.
FREE LT_DD04T.

PERFORM APPEND_STRING_TO_FILE USING '</DATA_ELEMENTS>'.

PERFORM ADD_TIME_STAT USING 'Extract data elements' L_STARTTIME.

ENDFORM.                    " extract_data_elements

*&---------------------------------------------------------------------*
*&      Form  extract_cluster_tables
*&---------------------------------------------------------------------*
FORM EXTRACT_CLUSTER_TABLES.

DATA: LT_DD06L   TYPE TABLE OF DD06L,
LT_DD06T   TYPE TABLE OF DD06T,
LT_DD16S   TYPE TABLE OF DD16S,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_SQLTAB FOR DD06L-SQLTAB.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting cluster tables'.

* Set Object list
LOOP AT GT_OBJ_CTAB INTO GS_OBJECTLIST.
CLEAR R_SQLTAB.
R_SQLTAB-SIGN   = 'I'.
R_SQLTAB-OPTION = 'EQ'.
R_SQLTAB-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_SQLTAB.
ENDLOOP.

FREE GT_OBJ_CTAB.

CHECK NOT R_SQLTAB[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<CLUSTER_TABLES>'.

* Extract Cluster Tables Data 'DD06L'
PERFORM APPEND_STRING_TO_FILE USING '<CLUSTER_TABLE_DATA>'.
IF NOT R_SQLTAB[] IS INITIAL.
SELECT * FROM  DD06L
INTO TABLE LT_DD06L PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_SQLTAB
WHERE  SQLTAB = R_SQLTAB-LOW
AND    AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD06L
USING G_IREF_PDOCUMENT
'DD06L'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</CLUSTER_TABLE_DATA>'.
FREE LT_DD06L.

* Get Cluster Tables Text 'DD06T'
PERFORM APPEND_STRING_TO_FILE USING '<CLUSTER_TABLE_TEXT>'.
IF NOT R_SQLTAB[] IS INITIAL.
SELECT * FROM  DD06T
INTO TABLE LT_DD06T PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_SQLTAB
WHERE  SQLTAB = R_SQLTAB-LOW
AND    AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD06T
USING G_IREF_PDOCUMENT
'DD06T'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</CLUSTER_TABLE_TEXT>'.
FREE LT_DD06T.

* Get Cluster Tables Field 'DD16S'
PERFORM APPEND_STRING_TO_FILE USING '<CLUSTER_TABLE_FIELDS>'.
IF NOT R_SQLTAB[] IS INITIAL.
SELECT * FROM  DD16S
INTO TABLE LT_DD16S PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_SQLTAB
WHERE  SQLTAB = R_SQLTAB-LOW
AND    AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD16S
USING G_IREF_PDOCUMENT
'DD16S'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</CLUSTER_TABLE_FIELDS>'.
FREE LT_DD16S.

PERFORM APPEND_STRING_TO_FILE USING '</CLUSTER_TABLES>'.

PERFORM ADD_TIME_STAT USING 'Extract cluster tables' L_STARTTIME.

ENDFORM.                    " extract_cluster_tables

*&---------------------------------------------------------------------*
*&      Form  extract_table_types
*&---------------------------------------------------------------------*
FORM EXTRACT_TABLE_TYPES.

DATA: LT_DD40L   TYPE TABLE OF DD40L,
LT_DD40T   TYPE TABLE OF DD40T,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_TYPENAME FOR DD40L-TYPENAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting table types'.

* Set Object list
LOOP AT GT_OBJ_TTYP INTO GS_OBJECTLIST.
CLEAR R_TYPENAME.
R_TYPENAME-SIGN   = 'I'.
R_TYPENAME-OPTION = 'EQ'.
R_TYPENAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_TYPENAME.
ENDLOOP.

FREE GT_OBJ_TTYP.

CHECK NOT R_TYPENAME[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TYPES>'.

* Get Table Types Data 'DD40L'
PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TYPES_DATA>'.
IF NOT R_TYPENAME[] IS INITIAL.
*   Get Table Types Data
SELECT * FROM  DD40L
INTO TABLE LT_DD40L PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_TYPENAME
WHERE  TYPENAME = R_TYPENAME-LOW
AND    AS4LOCAL = 'A'.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD40L
USING G_IREF_PDOCUMENT
'DD40L'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TYPES_DATA>'.
FREE LT_DD40L.

* Get Table Types Text 'DD40T'
PERFORM APPEND_STRING_TO_FILE USING '<TABLE_TYPES_TEXT>'.
IF NOT R_TYPENAME[] IS INITIAL.
SELECT * FROM  DD40T
INTO TABLE LT_DD40T PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_TYPENAME
WHERE  TYPENAME = R_TYPENAME-LOW
AND    AS4LOCAL = 'A'.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD40T
USING G_IREF_PDOCUMENT
'DD40T'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TYPES_TEXT>'.
FREE LT_DD40T.

PERFORM APPEND_STRING_TO_FILE USING '</TABLE_TYPES>'.

PERFORM ADD_TIME_STAT USING 'Extract table types' L_STARTTIME.

ENDFORM.                    " extract_table_types

*&---------------------------------------------------------------------*
*&      Form  extract_domains
*&---------------------------------------------------------------------*
FORM EXTRACT_DOMAINS.

DATA: BEGIN OF LT_DD01L  OCCURS 0.
INCLUDE STRUCTURE DD01L.
DATA:   ABCODE      TYPE X031L-FIELDTYPE,   " ABAP Coding for nametab
ABLEN       TYPE DD03L-INTLEN,      " ABAP Length
ABTYPE      TYPE DD03L-INTTYPE,     " ABAP Category
ABTYPE_INT  TYPE DD03L-INTTYPE,     " ABAP Nametab type
END OF LT_DD01L,
LT_DD01T   TYPE TABLE OF DD01T,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_DOMNAME FOR DD01L-DOMNAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting domains'.

* Set Object list
LOOP AT GT_OBJ_DOMN INTO GS_OBJECTLIST.
CLEAR R_DOMNAME.
R_DOMNAME-SIGN   = 'I'.
R_DOMNAME-OPTION = 'EQ'.
R_DOMNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_DOMNAME.
ENDLOOP.

FREE GT_OBJ_DOMN.

CHECK NOT R_DOMNAME[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<DOMAINS>'.

* Extract the Domains Data 'DD01L'
PERFORM APPEND_STRING_TO_FILE USING '<DOMAINS_DATA>'.
IF NOT R_DOMNAME[] IS INITIAL.
*     Get Domains Data
SELECT * FROM  DD01L
INTO TABLE LT_DD01L PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_DOMNAME
WHERE  DOMNAME = R_DOMNAME-LOW
AND    AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

LOOP AT LT_DD01L.
GV_TABIX = SY-TABIX.
*     Get ABAP Types
CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
EXPORTING
DDLEN         = LT_DD01L-LENG
DDTYPE        = LT_DD01L-DATATYPE
IMPORTING
ABCODE        = LT_DD01L-ABCODE
ABLEN         = LT_DD01L-ABLEN
ABTYPE        = LT_DD01L-ABTYPE
ABTYPE_INT    = LT_DD01L-ABTYPE_INT
EXCEPTIONS
ILLEGAL_VALUE = 1
OTHERS        = 2.
IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'illegal_value'.
WHEN 2. ERROR = 'Others'.
ENDCASE.

CONCATENATE 'extract domains: DD_DDTYPE_TO_ABAPTYPE, type:'
LT_DD01L-DATATYPE 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
CHECK SY-SUBRC = 0.
MODIFY LT_DD01L INDEX GV_TABIX TRANSPORTING ABCODE ABLEN ABTYPE
ABTYPE_INT.
ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD01L
USING G_IREF_PDOCUMENT
'DD01L'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</DOMAINS_DATA>'.
FREE LT_DD01L.

* Extract the Domains Data 'DD01T'
PERFORM APPEND_STRING_TO_FILE USING '<DOMAINS_TEXT>'.
IF NOT R_DOMNAME[] IS INITIAL.
SELECT * FROM  DD01T
INTO TABLE LT_DD01T PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_DOMNAME
WHERE  DOMNAME = R_DOMNAME-LOW
AND    AS4LOCAL = 'A'
AND AS4VERS = '0000'.   " Take only the active version

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD01T
USING G_IREF_PDOCUMENT
'DD01T'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</DOMAINS_TEXT>'.
FREE LT_DD01T.

PERFORM APPEND_STRING_TO_FILE USING '</DOMAINS>'.

PERFORM ADD_TIME_STAT USING 'Extract domains' L_STARTTIME.

ENDFORM.                    " extract_domains

*&---------------------------------------------------------------------*
*&      Form  extract_extract_infotype_texts
*&---------------------------------------------------------------------*
FORM EXTRACT_INFOTYPE_TEXTS.

TYPES: BEGIN OF T582S_TYPE,
MANDT(3) TYPE C,
SPRSL(1) TYPE C,
INFTY(4) TYPE C,
ITBLD(2) TYPE C,
ITEXT(35) TYPE C,
END OF T582S_TYPE.

DATA: LT_T582S   TYPE TABLE OF T582S_TYPE,
L_STARTTIME LIKE SY-UZEIT,
T582S_TAB(15) TYPE C VALUE 'T582S',
TADIR_WA TYPE TADIR.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting infotype texts'.

* Get Infotype Texts Data ( only user defined infotypes )
PERFORM APPEND_STRING_TO_FILE USING '<INFOTYPE_TEXTS>'.

* Check if table 'T582S' exists
SELECT SINGLE * FROM TADIR INTO TADIR_WA
WHERE PGMID = 'R3TR' AND OBJECT = 'TABL' AND OBJ_NAME = T582S_TAB.

IF SY-SUBRC IS INITIAL.
SELECT * FROM  (T582S_TAB)
INTO TABLE LT_T582S PACKAGE SIZE PAC_SIZE
WHERE INFTY > '9000'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_T582S
USING G_IREF_PDOCUMENT
'T582S'.
ENDSELECT.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '</INFOTYPE_TEXTS>'.
FREE LT_T582S.

PERFORM ADD_TIME_STAT USING 'Extract infotype texts' L_STARTTIME.

ENDFORM.                    " extract_infotype_texts

*&---------------------------------------------------------------------*
*&      Form  extract_data_types
*&---------------------------------------------------------------------*
FORM EXTRACT_DATA_TYPES.

DATA: DATA_TYPES_NODE  TYPE XML_ELEMENT,
TYPES_INDEX_NODE TYPE XML_ELEMENT,
DATA_ELEMENTS_NODE TYPE XML_ELEMENT,
TABLES_NODE TYPE XML_ELEMENT,
CLUSTERS_NODE TYPE XML_ELEMENT,
VIEWS_NODE TYPE XML_ELEMENT,
TABLE_TYPES_NODE TYPE XML_ELEMENT,
DATA_TYPES TYPE TABLE OF DDTYPES_TYPE,
NEW_TYPEKIND TYPE C,
END_TYPEKIND TYPE C,
TAG_NAME     TYPE STRING,
START_TAG    TYPE STRING,
END_TAG      TYPE STRING,
DATA_ELEMENT TYPE DATA_ELEMENT_TAB_TYPE,
STRUCTURE_FIELDS TYPE STRUCTURE_FIELDS_TAB_TYPE,
TABLE_TYPE TYPE TABLE_TYPE_TAB_TYPE,
LT_DDTYPES   TYPE TABLE OF DDTYPES_TYPE,
LS_DDTYPE    LIKE LINE OF LT_DDTYPES,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_TYPENAME FOR DDTYPES-TYPENAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting data types'.

* Set Object list
LOOP AT GT_OBJ_TYPE INTO GS_OBJECTLIST.
CLEAR R_TYPENAME.
R_TYPENAME-SIGN   = 'I'.
R_TYPENAME-OPTION = 'EQ'.
R_TYPENAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_TYPENAME.
ENDLOOP.

FREE GT_OBJ_TYPE.

* Add also the SAP types with append structure
IF NOT G_APP_STRUC IS INITIAL.
APPEND LINES OF G_APP_STRUC TO R_TYPENAME.
ENDIF.
* Add also the SAP types with customer include
IF NOT G_INC_STRUC IS INITIAL.
APPEND LINES OF G_INC_STRUC TO R_TYPENAME.
ENDIF.
* Add also the SAP view types with * notion and
* tables that were changed by customer
IF NOT G_VIEW_WITH_AST IS INITIAL.
APPEND LINES OF G_VIEW_WITH_AST TO R_TYPENAME.
ENDIF.

CHECK NOT R_TYPENAME[] IS INITIAL.

IF NOT R_TYPENAME[] IS INITIAL.
*   Get Master Tables Data
SELECT * FROM  DDTYPES
INTO CORRESPONDING FIELDS OF TABLE LT_DDTYPES
FOR ALL ENTRIES IN R_TYPENAME
WHERE  TYPENAME = R_TYPENAME-LOW
AND    STATE = 'A'.

FREE R_TYPENAME.
ENDIF.

CHECK NOT LT_DDTYPES[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<DATA_TYPES>'.

* Add the Master Tables Data
PERFORM APPEND_STRING_TO_FILE USING '<DDTYPES_INDEX>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DDTYPES
USING G_IREF_PDOCUMENT
'DDTYPE'.
PERFORM APPEND_STRING_TO_FILE USING '</DDTYPES_INDEX>'.

SORT LT_DDTYPES BY TYPEKIND TYPENAME.

* Process types
LOOP AT LT_DDTYPES INTO LS_DDTYPE.

CLEAR: NEW_TYPEKIND, END_TYPEKIND, TAG_NAME.

*   Check that the current data type is supported
CHECK LS_DDTYPE-TYPEKIND = 'DTEL' OR LS_DDTYPE-TYPEKIND = 'TABL' OR
LS_DDTYPE-TYPEKIND = 'SQLT' OR LS_DDTYPE-TYPEKIND = 'VIEW' OR
LS_DDTYPE-TYPEKIND = 'TTYP' OR ( LS_DDTYPE-TYPEKIND = 'INTF'
AND VANILLA = 'X' ).

AT NEW TYPEKIND. NEW_TYPEKIND = 'X'. ENDAT.
AT END OF TYPEKIND. END_TYPEKIND = 'X'. ENDAT.

IF NEW_TYPEKIND = 'X' OR END_TYPEKIND = 'X'.
CASE LS_DDTYPE-TYPEKIND.
WHEN 'DTEL'.
TAG_NAME = 'DATA_ELEMENTS'.
WHEN 'TABL'.
TAG_NAME = 'TABLES'.
WHEN 'SQLT'.
TAG_NAME = 'CLUSTER_TABLES'.
WHEN 'VIEW'.
TAG_NAME = 'VIEWS'.
WHEN 'TTYP'.
TAG_NAME = 'TABLE_TYPES'.
WHEN 'INTF'.
TAG_NAME = 'INTERFACES'.

ENDCASE.
ENDIF.

IF NEW_TYPEKIND = 'X'.
CONCATENATE '<' TAG_NAME '>' INTO START_TAG.
PERFORM APPEND_STRING_TO_FILE USING START_TAG.
ENDIF.

*   Process the type
CLEAR: DATA_ELEMENT, STRUCTURE_FIELDS, TABLE_TYPE.

PERFORM GET_TYPE_FIELDS TABLES DATA_ELEMENT
STRUCTURE_FIELDS
TABLE_TYPE
USING  LS_DDTYPE.

CASE LS_DDTYPE-TYPEKIND.

WHEN 'DTEL'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES DATA_ELEMENT
USING G_IREF_PDOCUMENT
'DATA_ELEMENT'.
WHEN 'TABL'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
USING G_IREF_PDOCUMENT
'TABLE_FIELD'.
WHEN 'SQLT'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
USING G_IREF_PDOCUMENT
'CLUSTER_TABLE_FIELD'.
WHEN 'VIEW'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
USING G_IREF_PDOCUMENT
'VIEW_FIELD'.
WHEN 'TTYP'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TABLE_TYPE
USING G_IREF_PDOCUMENT
'TABLE_TYPE'.
WHEN 'INTF'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES STRUCTURE_FIELDS
USING G_IREF_PDOCUMENT
'INTERFACE'.

ENDCASE.

IF END_TYPEKIND = 'X'.
CONCATENATE '</' TAG_NAME '>' INTO END_TAG.
PERFORM APPEND_STRING_TO_FILE USING END_TAG.
ENDIF.

ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '</DATA_TYPES>'.

PERFORM ADD_TIME_STAT USING 'Extract data types' L_STARTTIME.

ENDFORM.                    " extract_data_types

*---------------------------------------------------------------------*
*       FORM extract_append_structures                                *
*---------------------------------------------------------------------*
FORM FIND_APPEND_STRUCTURES.

DATA: APP_STRUC_TAB TYPE TABLE OF DD03L,
APP_STRUC LIKE LINE OF APP_STRUC_TAB,
SAP_TABLE_FIELDS TYPE TABLE OF DD03L,
PROCESS_TYPE TYPE C,
APPEND_STRUCTURES_NODE TYPE XML_ELEMENT,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING
'Searching for SAP types with append structures'.

CHECK NOT CUSTOMER_OBJECTS[] IS INITIAL.

* Find all SAP types that contain customer append structure
SELECT * FROM DD03L
INTO TABLE APP_STRUC_TAB
WHERE FIELDNAME = '.INCLU--AP'
AND   AS4LOCAL  = 'A' AND
AS4VERS = '0000'   " Take only the active version
AND   PRECFIELD IN CUSTOMER_OBJECTS.

SORT APP_STRUC_TAB BY TABNAME.

LOOP AT APP_STRUC_TAB INTO APP_STRUC.
AT END OF TABNAME. PROCESS_TYPE = 'X'. ENDAT.

IF PROCESS_TYPE = 'X'.
CLEAR PROCESS_TYPE.

SELECT * FROM DD03L
INTO TABLE SAP_TABLE_FIELDS
WHERE TABNAME = APP_STRUC-TABNAME
AND   AS4LOCAL = 'A' AND
AS4VERS = '0000'.   " Take only the active version

CHECK SY-SUBRC IS INITIAL.

G_APP_STRUC-SIGN   = 'I'.
G_APP_STRUC-OPTION = 'EQ'.
G_APP_STRUC-LOW    = APP_STRUC-TABNAME.
APPEND G_APP_STRUC.

ENDIF.
ENDLOOP.

PERFORM ADD_TIME_STAT USING 'Extract append structures' L_STARTTIME.

ENDFORM.                    "find_append_structures

*---------------------------------------------------------------------*
*       FORM extract_customer_includes                                *
*---------------------------------------------------------------------*
FORM FIND_CUSTOMER_INCLUDES.
DATA: INC_STRUC_TAB TYPE TABLE OF DD03L,
INC_STRUC LIKE LINE OF INC_STRUC_TAB,
SAP_TABLE_FIELDS TYPE TABLE OF DD03L,
DD02L_TAB TYPE TABLE OF DD02L WITH HEADER LINE,
PROCESS_TYPE TYPE C,
CUSTOMER_INCLUDES_NODE TYPE XML_ELEMENT,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING
'Searching for SAP types with customer includes'.

* Find all SAP types that contain active customer includes
SELECT * FROM DD02L
INTO TABLE DD02L_TAB
WHERE TABNAME LIKE 'CI%'
AND   AS4LOCAL = 'A'.

LOOP AT DD02L_TAB WHERE TABNAME NP 'CI_*'.
DELETE DD02L_TAB.
ENDLOOP.

CHECK NOT DD02L_TAB[] IS INITIAL.

IF NOT DD02L_TAB[] IS INITIAL.
SELECT * FROM DD03L
INTO TABLE INC_STRUC_TAB
FOR ALL ENTRIES IN DD02L_TAB
WHERE AS4LOCAL  = 'A'
AND AS4VERS = '0000'   " Take only the active version
AND   PRECFIELD = DD02L_TAB-TABNAME.
ENDIF.

SORT INC_STRUC_TAB BY TABNAME.

LOOP AT INC_STRUC_TAB INTO INC_STRUC.
AT END OF TABNAME. PROCESS_TYPE = 'X'. ENDAT.

IF PROCESS_TYPE = 'X'.
CLEAR PROCESS_TYPE.

SELECT * FROM DD03L
INTO TABLE SAP_TABLE_FIELDS
WHERE TABNAME = INC_STRUC-TABNAME
AND AS4VERS = '0000'   " Take only the active version
AND   AS4LOCAL = 'A'.

CHECK SY-SUBRC IS INITIAL.

G_INC_STRUC-SIGN   = 'I'.
G_INC_STRUC-OPTION = 'EQ'.
G_INC_STRUC-LOW    = INC_STRUC-TABNAME.
APPEND G_INC_STRUC.

ENDIF.
ENDLOOP.

PERFORM ADD_TIME_STAT USING 'Extract customer includes' L_STARTTIME.


ENDFORM.                    "find_customer_includes

*---------------------------------------------------------------------*
*       FORM get_type_fields                                          *
*---------------------------------------------------------------------*
FORM GET_TYPE_FIELDS TABLES
DATA_ELEMENT TYPE DATA_ELEMENT_TAB_TYPE
STRUCTURE_FIELDS TYPE STRUCTURE_FIELDS_TAB_TYPE
TABLE_TYPE TYPE TABLE_TYPE_TAB_TYPE
USING DATA_TYPE TYPE DDTYPES_TYPE.

DATA:   ROLLNAME TYPE ROLLNAME,
TABNAME TYPE DDOBJNAME,
TYPENAME TYPE DD40L-TYPENAME,
DD04L_ITAB TYPE TABLE OF DD04L,
DD04L_WA TYPE DD04L,
ABTYPE_INT LIKE  DD03L-INTTYPE,
ABLEN LIKE  DD03L-INTLEN,
DDTYPE LIKE  DD01V-DATATYPE,
DD02L_WA LIKE DD02L,
NEXT_FIELD_OFFSET LIKE DFIES-OFFSET.

ROLLNAME = DATA_TYPE-TYPENAME.
TABNAME = DATA_TYPE-TYPENAME.
TYPENAME = DATA_TYPE-TYPENAME.

* Decide according to kind from where to read its definition
CASE DATA_TYPE-TYPEKIND.
WHEN 'DTEL'. " Data Element

*     OBJECT is a Data Element
SELECT * FROM DD04L
INTO TABLE DD04L_ITAB
WHERE ROLLNAME = ROLLNAME
AND   AS4LOCAL = 'A'.

CHECK SY-SUBRC IS INITIAL.

LOOP AT DD04L_ITAB INTO DD04L_WA.
DATA_ELEMENT-ROLLNAME = DD04L_WA-ROLLNAME.
DATA_ELEMENT-DECIMALS = DD04L_WA-DECIMALS.

IF DD04L_WA-REFKIND = 'R'. "Reference type
DATA_ELEMENT-INTTYPE = 'l'.
DATA_ELEMENT-INTLEN = 8.
ELSE.
DDTYPE = DD04L_WA-DATATYPE.
CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
EXPORTING
DDLEN         = DD04L_WA-LENG
DDTYPE        = DDTYPE
IMPORTING
ABLEN         = ABLEN
ABTYPE_INT    = ABTYPE_INT
EXCEPTIONS
ILLEGAL_VALUE = 1
OTHERS        = 2.
IF SY-SUBRC IS INITIAL.
PERFORM UCLEN_TO_INTLEN USING DDTYPE ABLEN UNICODELG.
DATA_ELEMENT-INTTYPE = ABTYPE_INT.
DATA_ELEMENT-INTLEN = ABLEN.
ENDIF.
ENDIF.
APPEND DATA_ELEMENT.
ENDLOOP.

WHEN 'TABL' OR 'SQLT' OR 'VIEW'. " Table or cluster table

*     OBJECT is a DB/cluster table OR a Structure
CALL FUNCTION 'DDIF_NAMETAB_GET'
EXPORTING
TABNAME     = TABNAME
ALL_TYPES   = 'X'
*                group_names = 'X'
TABLES
DFIES_TAB   = STRUCTURE_FIELDS
EXCEPTIONS
NOT_FOUND         = 1
OTHERS            = 2
.

CHECK SY-SUBRC IS INITIAL.
DELETE STRUCTURE_FIELDS WHERE LFIELDNAME CA '-'.

LOOP AT STRUCTURE_FIELDS.

*        Get position and depth from table definition
*        (overriding actual position in runtime type)
SELECT SINGLE POSITION ADMINFIELD REFFIELD PRECFIELD
FROM   DD03L
INTO   (STRUCTURE_FIELDS-POSITION, STRUCTURE_FIELDS-ADMINFIELD,
STRUCTURE_FIELDS-REFFIELD, STRUCTURE_FIELDS-PRECFIELD)
WHERE  TABNAME = STRUCTURE_FIELDS-TABNAME
AND    FIELDNAME = STRUCTURE_FIELDS-FIELDNAME
AND    AS4LOCAL = 'A'
AND    DEPTH = ' '.

IF SY-SUBRC > 0.
STRUCTURE_FIELDS-ADMINFIELD = '0'.
CLEAR: STRUCTURE_FIELDS-REFFIELD,
STRUCTURE_FIELDS-PRECFIELD.
ENDIF.

DDTYPE = STRUCTURE_FIELDS-DATATYPE.
IF STRUCTURE_FIELDS-COMPTYPE = 'E' OR
STRUCTURE_FIELDS-COMPTYPE = SPACE.
CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
EXPORTING
DDLEN         = STRUCTURE_FIELDS-LENG
DDTYPE        = DDTYPE
IMPORTING
ABLEN         = ABLEN
ABTYPE_INT    = ABTYPE_INT
EXCEPTIONS
ILLEGAL_VALUE = 1
OTHERS        = 2.
IF SY-SUBRC IS INITIAL.
PERFORM UCLEN_TO_INTLEN USING DDTYPE ABLEN UNICODELG.
STRUCTURE_FIELDS-INTTYPE = ABTYPE_INT.
STRUCTURE_FIELDS-INTLEN = ABLEN.
ENDIF.
ENDIF.

IF STRUCTURE_FIELDS-CHECKTABLE = '*'.
SELECT SINGLE ENTITYTAB
FROM DD01L
INTO STRUCTURE_FIELDS-CHECKTABLE
WHERE DOMNAME = STRUCTURE_FIELDS-DOMNAME
AND   AS4LOCAL = 'A'.
ENDIF.
MODIFY STRUCTURE_FIELDS INDEX SY-TABIX.
ENDLOOP.

*     Add include structure fields to the type
SELECT *
FROM   DD03L
APPENDING CORRESPONDING FIELDS OF TABLE STRUCTURE_FIELDS
WHERE  TABNAME = STRUCTURE_FIELDS-TABNAME
AND    AS4LOCAL = 'A'
AND    PRECFIELD NE SPACE.

*     Add offsets to fields that are missing it
SORT STRUCTURE_FIELDS BY POSITION DESCENDING.
LOOP AT STRUCTURE_FIELDS.

*       Do not touch the first field since it should stay 0
AT LAST.
EXIT.
ENDAT.
IF SY-TABIX >= 2 AND NOT STRUCTURE_FIELDS-PRECFIELD IS INITIAL.
STRUCTURE_FIELDS-OFFSET = NEXT_FIELD_OFFSET.
MODIFY STRUCTURE_FIELDS INDEX SY-TABIX TRANSPORTING OFFSET.
ENDIF.
NEXT_FIELD_OFFSET = STRUCTURE_FIELDS-OFFSET.
ENDLOOP.

*     Sort the returned table by the field position
SORT STRUCTURE_FIELDS BY POSITION ASCENDING.

WHEN 'TTYP'. " Table type

*     Check if the OBJECT is a Table type
SELECT * FROM DD40L
INTO TABLE TABLE_TYPE
WHERE TYPENAME = TYPENAME
AND   AS4LOCAL = 'A'.

CHECK SY-SUBRC IS INITIAL.

LOOP AT TABLE_TYPE.
IF NOT TABLE_TYPE-DATATYPE IS INITIAL.
DDTYPE = TABLE_TYPE-DATATYPE.
CALL FUNCTION 'DD_DDTYPE_TO_ABAPTYPE'
EXPORTING
DDLEN         = TABLE_TYPE-LENG
DDTYPE        = DDTYPE
IMPORTING
ABLEN         = ABLEN
ABTYPE_INT    = ABTYPE_INT
EXCEPTIONS
ILLEGAL_VALUE = 1
OTHERS        = 2.
IF SY-SUBRC IS INITIAL.
PERFORM UCLEN_TO_INTLEN USING DDTYPE ABLEN UNICODELG.
TABLE_TYPE-INTTYPE = ABTYPE_INT.
TABLE_TYPE-INTLEN = ABLEN.
ENDIF.
MODIFY TABLE_TYPE
INDEX SY-TABIX TRANSPORTING INTTYPE INTLEN.
ENDIF.
ENDLOOP.

WHEN 'INTF'.  " Interface

STRUCTURE_FIELDS-TABNAME = TABNAME.
APPEND STRUCTURE_FIELDS.

ENDCASE.

ENDFORM.                    "get_type_fields

*&---------------------------------------------------------------------*
*&      Form  extract_repository_objects
*&---------------------------------------------------------------------*
FORM EXTRACT_REPOSITORY_OBJECTS.
DATA: L_STARTTIME LIKE SY-UZEIT.

RANGES: R_OBJ_NAME FOR TADIR-OBJ_NAME.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING
'Extracting repository objects'.

PERFORM ADD_SMODILOG_PROGRAMS.

CHECK NOT GT_TADIR[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<REPOSITORY_OBJECTS>'.

* Add the Repository Objects Data
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES GT_TADIR
USING G_IREF_PDOCUMENT
'TADIR'.

PERFORM APPEND_STRING_TO_FILE USING '</REPOSITORY_OBJECTS>'.

FREE GT_TADIR.

PERFORM ADD_TIME_STAT USING 'Extract rep objects' L_STARTTIME.

ENDFORM.                    " extract_repository_objects

*&---------------------------------------------------------------------*
*&      Form  extract_user_exits
*&---------------------------------------------------------------------*
FORM EXTRACT_USER_EXITS.

DATA: USER_EXIT_ENHANCEMENTS_TEXTS TYPE XML_ELEMENT,
USER_EXIT_COMPONENTS_TEXTS TYPE XML_ELEMENT,
LT_MODATTR  TYPE TABLE OF MODATTR,
LT_MODTEXT  TYPE TABLE OF MODTEXT,
LT_MODSAPT  TYPE TABLE OF MODSAPT,
LT_TFTIT    TYPE TABLE OF TFTIT,
LV_FUNCNAME TYPE RS38L-NAME,
LV_INCLUDE  TYPE RS38L-INCLUDE,
LT_SOURCE   TYPE TABLE OF  ABAPSOURCE  WITH HEADER LINE,
LT_SOURCE_EXT TYPE TABLE OF ABAPTXT255 WITH HEADER LINE,
LT_UNIFIED_SOURCE TYPE TT_UNIFIED_SOURCE WITH HEADER LINE,
MODSAP_WA   TYPE MODSAP,
L_STARTTIME LIKE SY-UZEIT,
RC LIKE SY-SUBRC.

DATA: BEGIN OF LT_EXITS  OCCURS 0,
PROJECT      TYPE MODACT-NAME,
ENHANCEMENT  TYPE MODACT-MEMBER,
COMPONENT    TYPE MODSAP-MEMBER,
INCLUDE      TYPE RS38L-INCLUDE,
IMPLEMENTED  TYPE CHAR3,
END OF LT_EXITS.

RANGES: R_NAME FOR MODACT-NAME,
R_MODSAPT FOR MODSAPT-NAME,
R_FUNCTIONS FOR TFTIT-FUNCNAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting user exits'.

* Set Object list - projects (CMOD)
LOOP AT GT_OBJ_UEXT INTO GS_OBJECTLIST.
CLEAR R_NAME.
R_NAME-SIGN   = 'I'.
R_NAME-OPTION = 'EQ'.
R_NAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_NAME.
ENDLOOP.

FREE GT_OBJ_UEXT.

* Get all SAP enhancements
SELECT * FROM MODSAP
INTO MODSAP_WA
WHERE TYP = 'E'.
LT_EXITS-ENHANCEMENT = MODSAP_WA-NAME.
LT_EXITS-COMPONENT = MODSAP_WA-MEMBER.
APPEND LT_EXITS.
ENDSELECT.

* Get projects attributes
SELECT * FROM  MODATTR
INTO TABLE LT_MODATTR
WHERE  NAME  IN R_NAME.

* Get projects descriptions
SELECT * FROM  MODTEXT
INTO TABLE LT_MODTEXT
WHERE  NAME  IN R_NAME.

CHECK NOT LT_EXITS[] IS INITIAL.

SORT LT_EXITS.
LOOP AT LT_EXITS.
GV_TABIX = SY-TABIX.
LV_FUNCNAME = LT_EXITS-COMPONENT.
CLEAR LV_INCLUDE.

*   Get the function exit's program
CALL FUNCTION 'FUNCTION_EXISTS'
EXPORTING
FUNCNAME           = LV_FUNCNAME
IMPORTING
INCLUDE            = LV_INCLUDE
EXCEPTIONS
FUNCTION_NOT_EXIST = 1
OTHERS             = 2.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'function_not_exist'.
WHEN 2. ERROR = 'Others'.
ENDCASE.

CONCATENATE 'extract user exits: FUNCTION_EXISTS, function:'
LV_FUNCNAME 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
DELETE LT_EXITS.
CONTINUE.
ENDIF.

REFRESH: LT_SOURCE, LT_SOURCE_EXT.
*   Get the function exit's source
CALL FUNCTION 'RPY_PROGRAM_READ'
EXPORTING
PROGRAM_NAME     = LV_INCLUDE
TABLES
SOURCE           = LT_SOURCE
SOURCE_EXTENDED  = LT_SOURCE_EXT
EXCEPTIONS
CANCELLED        = 1
NOT_FOUND        = 2
PERMISSION_ERROR = 3
OTHERS           = 4.
IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'cancelled'.
WHEN 2. ERROR = 'not_found'.
WHEN 3. ERROR = 'permission_error'.
WHEN 4. ERROR = 'Others'.
ENDCASE.

CONCATENATE 'extract user exits: RPY_PROGRAM_READ, program:'
LV_INCLUDE 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
DELETE LT_EXITS.
CONTINUE.
ENDIF.

IF NOT LT_SOURCE[] IS INITIAL.
LT_UNIFIED_SOURCE[] = LT_SOURCE[].
ELSE.
LT_UNIFIED_SOURCE[] = LT_SOURCE_EXT[].
ENDIF.

*   Go over the function exit's source code and find the 'Z' include
*   name. Then, check if the include exists which means that it is
*   implemented by the cutomer
LOOP AT LT_UNIFIED_SOURCE.
CHECK LT_UNIFIED_SOURCE-LINE(1) <> '*'.
TRANSLATE LT_UNIFIED_SOURCE-LINE TO UPPER CASE.
SEARCH LT_UNIFIED_SOURCE-LINE FOR 'INCLUDE'.
IF SY-SUBRC = 0.
ADD 8 TO SY-FDPOS.
LT_EXITS-INCLUDE = LT_UNIFIED_SOURCE-LINE+SY-FDPOS.
REPLACE '.' WITH SPACE INTO LT_EXITS-INCLUDE.

*       Check if the include is implemented
SELECT SINGLE * FROM  TRDIR
WHERE  NAME  = LT_EXITS-INCLUDE.

IF SY-SUBRC = 0.
LT_EXITS-IMPLEMENTED = 'YES'.

*         Create a list of the implemented enhancements
R_MODSAPT-SIGN = 'I'.
R_MODSAPT-OPTION = 'EQ'.
R_MODSAPT-LOW = LT_EXITS-ENHANCEMENT.
APPEND R_MODSAPT.

*         Create a list of all function exits
R_FUNCTIONS-SIGN = 'I'.
R_FUNCTIONS-OPTION = 'EQ'.
R_FUNCTIONS-LOW = LT_EXITS-COMPONENT.
APPEND R_FUNCTIONS.

SELECT SINGLE NAME FROM MODACT
INTO LT_EXITS-PROJECT
WHERE MEMBER = LT_EXITS-ENHANCEMENT.

MODIFY LT_EXITS INDEX GV_TABIX TRANSPORTING
PROJECT INCLUDE IMPLEMENTED.
ELSE.
DELETE LT_EXITS.
ENDIF.

EXIT.
ENDIF.
ENDLOOP.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<USER_EXITS>'.

PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_ATTRIBUTES>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MODATTR
USING G_IREF_PDOCUMENT
'MODATTR'.
PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_ATTRIBUTES>'.
FREE LT_MODATTR.

PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_COMPONENTS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_EXITS
USING G_IREF_PDOCUMENT
'MODACT'.
PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_COMPONENTS>'.
FREE LT_EXITS.

PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_TEXT>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MODTEXT
USING G_IREF_PDOCUMENT
'MODTEXT'.
PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_TEXT>'.
FREE LT_MODTEXT.

* Read enhancements descriptions 'MODSAPT'
IF NOT R_MODSAPT[] IS INITIAL.
SELECT * FROM MODSAPT
INTO TABLE LT_MODSAPT
FOR ALL ENTRIES IN R_MODSAPT
WHERE NAME = R_MODSAPT-LOW.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_ENHANCEMENTS_TEXTS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_MODSAPT
USING G_IREF_PDOCUMENT
'MODSAPT'.
PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_ENHANCEMENTS_TEXTS>'.
FREE LT_MODSAPT.

* Read function exits descriptions 'TFTIT'
IF NOT R_FUNCTIONS[] IS INITIAL.
SELECT * FROM TFTIT
INTO TABLE LT_TFTIT
FOR ALL ENTRIES IN R_FUNCTIONS
WHERE FUNCNAME = R_FUNCTIONS-LOW.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '<USER_EXIT_COMPONENTS_TEXTS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TFTIT
USING G_IREF_PDOCUMENT
'TFTIT'.
PERFORM APPEND_STRING_TO_FILE USING '</USER_EXIT_COMPONENTS_TEXTS>'.
FREE LT_TFTIT.

PERFORM APPEND_STRING_TO_FILE USING '</USER_EXITS>'.

PERFORM ADD_TIME_STAT USING 'Extract user exits' L_STARTTIME.

ENDFORM.                    " extract_user_exits

*&---------------------------------------------------------------------*
*&      Form  extract_badis
*&---------------------------------------------------------------------*
FORM EXTRACT_BADIS.

DATA: BADIS_NODE  TYPE XML_ELEMENT.

*---
* Set Object list
*  IF s_devcls[] IS INITIAL.
*    r_fctr_id[] = s_object[].
*  ELSE.
*    FREE r_fctr_id.
*    LOOP AT gt_objectlist INTO gs_objectlist WHERE obj_type = 'SXSD'.
*      CLEAR r_fctr_id.
*      r_fctr_id-sign   = 'I'.
*      r_fctr_id-option = 'EQ'.
*      r_fctr_id-low    = gs_objectlist-obj_name.
*      APPEND r_fctr_id.
*    ENDLOOP.
*  ENDIF.
*  CHECK NOT r_fctr_id[] IS INITIAL.

** Create a child node for the BADIs node
*  PERFORM create_xml_node USING g_iref_pdocument g_iref_root_elem
*                                'BADIS'
*                          CHANGING badis_node.

ENDFORM.                    " extract_badis

*---------------------------------------------------------------------*
*       FORM create_xml_document                                      *
*---------------------------------------------------------------------*
FORM CREATE_XML_DOCUMENT.

DATA: L_ENCODING TYPE STRING,
I_ENCODING TYPE REF TO IF_IXML_ENCODING.

* create the main factory
G_IREF_PIXML = CL_IXML=>CREATE( ).

* create the initial document
G_IREF_PDOCUMENT = G_IREF_PIXML->CREATE_DOCUMENT( ).

L_ENCODING = ENCODING.
I_ENCODING = G_IREF_PIXML->CREATE_ENCODING( CHARACTER_SET = L_ENCODING
BYTE_ORDER = '0' ).
CALL METHOD G_IREF_PDOCUMENT->SET_ENCODING( ENCODING = I_ENCODING ).

ENDFORM.                          " create_xml_document
*---------------------------------------------------------------------*
*       FORM add_itab_to_xml                                          *
*---------------------------------------------------------------------*
FORM ADD_ITAB_TO_XML_SIMPLE
TABLES   I_TAB_SAP_DATA
USING    L_IREF_PDOCUMENT TYPE REF TO IF_IXML_DOCUMENT
L_IREF_ROOT_ELEM TYPE REF TO IF_IXML_ELEMENT
I_REC_TAG        TYPE STRING.

DATA: DUMMY_TAB_HANDLES TYPE HANDLES_TAB_TYPE.

PERFORM ADD_ITAB_TO_XML TABLES I_TAB_SAP_DATA DUMMY_TAB_HANDLES
USING  L_IREF_PDOCUMENT L_IREF_ROOT_ELEM
I_REC_TAG.
ENDFORM.                          " add_itab_to_xml_simple

*---------------------------------------------------------------------*
*       FORM add_itab_to_xml                                          *
*---------------------------------------------------------------------*
FORM ADD_ITAB_TO_XML
TABLES   I_TAB_SAP_DATA
I_TAB_HANDLES    TYPE HANDLES_TAB_TYPE
USING    L_IREF_PDOCUMENT TYPE REF TO IF_IXML_DOCUMENT
L_IREF_ROOT_ELEM TYPE REF TO IF_IXML_ELEMENT
I_REC_TAG        TYPE STRING.
DATA: L_IREF_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_DATA  TYPE REF TO DATA,
LINES_NUM TYPE I,
STR_LINES_NUM TYPE STRING.
* Get the table size
DESCRIBE TABLE I_TAB_SAP_DATA LINES LINES_NUM.
* If the size of the table is larger than the constant, write a warning.
IF LINES_NUM > WARN_TABLE_SIZE.
STR_LINES_NUM = LINES_NUM.
CONCATENATE 'WARNING!! Table tag:' I_REC_TAG
'contains' STR_LINES_NUM 'rows' INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED
BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.

ENDIF.

SORT I_TAB_SAP_DATA.

FIELD-SYMBOLS: <FS_TEMP_TABLE> TYPE TABLE.
FIELD-SYMBOLS: <FS_TEMP_DATA>.
FIELD-SYMBOLS: <FS_TEMP> TYPE ANY.

DATA L_OREF_DESCR_SOURCE TYPE REF TO CL_ABAP_STRUCTDESCR.
DATA: L_TAB_DFIES TYPE TABLE OF DFIES.
DATA: TEMP_WA_REF TYPE REF TO DATA.

ASSIGN I_TAB_SAP_DATA[] TO <FS_TEMP_TABLE>.
CREATE DATA L_DATA LIKE LINE OF <FS_TEMP_TABLE>.
ASSIGN L_DATA->* TO <FS_TEMP_DATA>.

PERFORM GET_VARIABLE_TYPE_FIELDS TABLES   L_TAB_DFIES
USING    <FS_TEMP_DATA>
CHANGING L_OREF_DESCR_SOURCE
I_REC_TAG.

* Create XML doc with content
LOOP AT <FS_TEMP_TABLE> INTO <FS_TEMP_DATA>.
IF NOT I_REC_TAG IS INITIAL.
PERFORM CREATE_XML_NODE USING L_IREF_PDOCUMENT L_IREF_ROOT_ELEM
I_REC_TAG
CHANGING L_IREF_ELEM.
ELSE.
L_IREF_ELEM = L_IREF_ROOT_ELEM.
ENDIF.

PERFORM ADD_STRUCTURE_TO_XML TABLES L_TAB_DFIES
USING  L_IREF_ELEM
L_OREF_DESCR_SOURCE
<FS_TEMP_DATA>.

I_TAB_HANDLES-NODE_REF = L_IREF_ELEM.

CREATE DATA I_TAB_HANDLES-WA LIKE <FS_TEMP_DATA>.
ASSIGN I_TAB_HANDLES-WA->* TO <FS_TEMP>.
<FS_TEMP> = <FS_TEMP_DATA>.
APPEND I_TAB_HANDLES.
ENDLOOP.

ENDFORM.                          " add_itab_to_xml

*---------------------------------------------------------------------*
*       FORM add_itab_to_file_simple                                  *
*---------------------------------------------------------------------*
FORM ADD_ITAB_TO_FILE_SIMPLE
TABLES   I_TAB_SAP_DATA
USING    L_IREF_PDOCUMENT TYPE REF TO IF_IXML_DOCUMENT
I_REC_TAG        TYPE STRING.

DATA: L_IREF_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_IREF_ROOT_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_DATA  TYPE REF TO DATA.

SORT I_TAB_SAP_DATA.

FIELD-SYMBOLS: <FS_TEMP_TABLE> TYPE TABLE.
FIELD-SYMBOLS: <FS_TEMP_DATA>.
FIELD-SYMBOLS: <FS_TEMP> TYPE ANY.

DATA L_OREF_DESCR_SOURCE TYPE REF TO CL_ABAP_STRUCTDESCR.
DATA: L_TAB_DFIES TYPE TABLE OF DFIES.
DATA: TEMP_WA_REF TYPE REF TO DATA.

ASSIGN I_TAB_SAP_DATA[] TO <FS_TEMP_TABLE>.
CREATE DATA L_DATA LIKE LINE OF <FS_TEMP_TABLE>.
ASSIGN L_DATA->* TO <FS_TEMP_DATA>.

PERFORM GET_VARIABLE_TYPE_FIELDS TABLES   L_TAB_DFIES
USING    <FS_TEMP_DATA>
CHANGING L_OREF_DESCR_SOURCE
I_REC_TAG.

L_IREF_ROOT_ELEM = L_IREF_PDOCUMENT->GET_ROOT_ELEMENT( ).

* Create XML doc with content
LOOP AT <FS_TEMP_TABLE> INTO <FS_TEMP_DATA>.
IF NOT I_REC_TAG IS INITIAL.
PERFORM CREATE_XML_NODE USING L_IREF_PDOCUMENT
L_IREF_ROOT_ELEM
I_REC_TAG
CHANGING L_IREF_ELEM.
ELSE.
L_IREF_ELEM = L_IREF_ROOT_ELEM.
ENDIF.

PERFORM ADD_STRUCTURE_TO_XML TABLES L_TAB_DFIES
USING  L_IREF_ELEM
L_OREF_DESCR_SOURCE
<FS_TEMP_DATA>.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING L_IREF_ELEM
'X'.
ENDLOOP.

ENDFORM.                          " add_itab_to_xml

*---------------------------------------------------------------------*
*       FORM get_variable_type_fields                                 *
*---------------------------------------------------------------------*
FORM GET_VARIABLE_TYPE_FIELDS TABLES L_TAB_DFIES STRUCTURE DFIES
USING VALUE(REC)
CHANGING
VALUE(L_OREF_DESCR_SOURCE) TYPE REF TO CL_ABAP_STRUCTDESCR
VALUE(VAR_TYPE_NAME)       TYPE STRING.

DATA: L_TABNAME TYPE  DD02L-TABNAME.
DATA: L_TABNAME_STRING TYPE  STRING.

L_OREF_DESCR_SOURCE ?=
CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( REC ).

SEARCH L_OREF_DESCR_SOURCE->ABSOLUTE_NAME FOR '\TYPE='.
IF SY-SUBRC = 0.
SY-FDPOS = SY-FDPOS + STRLEN( '\TYPE=' ) .
L_TABNAME = L_OREF_DESCR_SOURCE->ABSOLUTE_NAME+SY-FDPOS.
L_TABNAME_STRING = L_TABNAME.
CALL FUNCTION 'LOAN_CHECK_STRUCTURE_INIT'
EXPORTING
I_STRUCTURE_TABNAME = L_TABNAME
TABLES
IT_DFIES            = L_TAB_DFIES
EXCEPTIONS
OTHERS              = 4.
IF VAR_TYPE_NAME IS INITIAL.
VAR_TYPE_NAME = L_TABNAME_STRING.
ENDIF.
ENDIF.

ENDFORM.                          " get_variable_type_fields

*---------------------------------------------------------------------*
*       FORM add_structure_to_xml                                     *
*---------------------------------------------------------------------*
FORM ADD_STRUCTURE_TO_XML TABLES L_TAB_DFIES STRUCTURE DFIES
USING VALUE(L_IREF_ELEM)   TYPE REF TO IF_IXML_ELEMENT
VALUE(L_OREF_DESCR_SOURCE) TYPE REF TO CL_ABAP_STRUCTDESCR
VALUE(FS_TEMP_DATA)        TYPE ANY.

IF NOT L_TAB_DFIES IS INITIAL.
PERFORM DFIES_TO_XML TABLES L_TAB_DFIES
USING G_IREF_PDOCUMENT L_IREF_ELEM
FS_TEMP_DATA SKIP_EMPTY_TAGS.
ELSE.
PERFORM DESCR_TO_XML USING L_OREF_DESCR_SOURCE->COMPONENTS
G_IREF_PDOCUMENT L_IREF_ELEM
FS_TEMP_DATA SKIP_EMPTY_TAGS.
ENDIF.

ENDFORM.                          " add_structure_to_xml

*---------------------------------------------------------------------*
*       FORM descr_to_xml                                             *
*---------------------------------------------------------------------*
FORM DESCR_TO_XML USING VALUE(PI_TAB_DESCR) TYPE ABAP_COMPDESCR_TAB
VALUE(PI_PDOCUMENT) TYPE REF TO IF_IXML_DOCUMENT
VALUE(PI_ELEM)      TYPE REF TO IF_IXML_ELEMENT
VALUE(PI_VALUE)     TYPE ANY
VALUE(PI_CONTENT)   TYPE BOOLEAN.

DATA:
L_FIELD LIKE LINE OF PI_TAB_DESCR,
L_SIMPLE_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_NAME  TYPE STRING,
L_VALUE TYPE STRING.
FIELD-SYMBOLS: <FS_VALUE>.

LOOP AT PI_TAB_DESCR INTO L_FIELD.
L_NAME = L_FIELD-NAME.
ASSIGN COMPONENT L_FIELD-NAME OF STRUCTURE PI_VALUE
TO <FS_VALUE>.
IF SY-SUBRC <> 0.
CLEAR L_VALUE.
ELSE.
L_VALUE = <FS_VALUE>.
ENDIF.

*   If the value of the current attribute is initial and empty
*   attributes should not be written - skip this field
*   Initial value for numeric data types doesn't is not skipped
IF <FS_VALUE> IS INITIAL AND NOT PI_CONTENT IS INITIAL AND
NOT ( L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_NUM OR
L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_PACKED OR
L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_HEX OR
L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_FLOAT OR
L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_INT OR
L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_INT1 OR
L_FIELD-TYPE_KIND = CL_ABAP_STRUCTDESCR=>TYPEKIND_INT2 OR
L_FIELD-TYPE_KIND = '%' ).
CONTINUE.
ENDIF.

*   Replace login name to XXX
IF SHOW_LOGIN_NAME IS INITIAL AND ( L_NAME = 'CREATED_BY' OR
L_NAME = 'CHANGED_BY' OR L_NAME = 'AS4USER' OR L_NAME =
'USERNAME' OR
L_NAME = 'UNAM' OR L_NAME = 'CNAM' OR L_NAME = 'ANAM' OR
L_NAME = 'GENUSER' OR L_NAME = 'AUTHOR' OR L_NAME = 'MOD_USER' OR
L_NAME = 'MODBE' OR L_NAME = 'CREATE_USR' OR L_NAME =
'CHANGE_USR' OR
L_NAME = 'CHANGEUSER' OR L_NAME = 'CREATEDBY' OR L_NAME =
'CHANGEDBY' OR
L_NAME = 'CWBUSER' OR L_NAME = 'RESPUSER' OR L_NAME = 'LASTUSER' OR
L_NAME = 'RESPONSIBL' OR L_NAME = 'FIRSTUSER' OR
L_NAME = 'UNAME' OR L_NAME = 'USERNAME' OR L_NAME = 'BNAME'
OR L_NAME = 'RFCUSER' ).

L_VALUE = 'XXX'.
ENDIF.

IF SHOW_SERVERS_NAME IS INITIAL AND
( L_NAME = 'RFCHOST').
L_VALUE = 'XXX'.
ENDIF.
CALL METHOD PI_ELEM->SET_ATTRIBUTE
EXPORTING
NAME  = L_NAME
VALUE = L_VALUE.
ENDLOOP.

ENDFORM.                               " DESCR_TO_XML

*---------------------------------------------------------------------*
*       FORM dfies_to_xml                                             *
*---------------------------------------------------------------------*
FORM DFIES_TO_XML TABLES   PI_TAB_DFIES STRUCTURE DFIES
USING VALUE(PI_PDOCUMENT) TYPE REF TO IF_IXML_DOCUMENT
VALUE(PI_ELEM)      TYPE REF TO IF_IXML_ELEMENT
VALUE(PI_VALUE)     TYPE ANY
VALUE(PI_CONTENT)   TYPE BOOLEAN.

DATA:
L_DFIES TYPE DFIES,
L_SIMPLE_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_ELEM  TYPE REF TO IF_IXML_ELEMENT,
L_NAME  TYPE STRING,
L_VALUE TYPE STRING.
FIELD-SYMBOLS: <FS_VALUE>.

LOOP AT PI_TAB_DFIES INTO L_DFIES.

L_NAME = L_DFIES-FIELDNAME.
ASSIGN COMPONENT L_DFIES-FIELDNAME OF STRUCTURE PI_VALUE
TO <FS_VALUE>.
IF SY-SUBRC <> 0.
CLEAR L_VALUE.
ELSE.
L_VALUE = <FS_VALUE>.
ENDIF.

*   If the value of the current attribute is initial and empty
*   attributes should not be written - skip this field
*   Initial value for numeric data types doesn't is not skipped
IF <FS_VALUE> IS INITIAL AND NOT PI_CONTENT IS INITIAL AND
NOT ( L_DFIES-INTTYPE = 'X' OR L_DFIES-INTTYPE = 'I' OR
L_DFIES-INTTYPE = 'b' OR L_DFIES-INTTYPE = 's' OR
L_DFIES-INTTYPE = 'P' OR L_DFIES-INTTYPE = 'F' OR
L_DFIES-INTTYPE = 'N' ).
CONTINUE.
ENDIF.

CALL METHOD PI_ELEM->SET_ATTRIBUTE
EXPORTING
NAME  = L_NAME
VALUE = L_VALUE.

ENDLOOP.

ENDFORM.                               " dfies_to_xml

*---------------------------------------------------------------------*
*       FORM add_attribute_to_node                                    *
*---------------------------------------------------------------------*
FORM ADD_ATTRIBUTE_TO_NODE USING
VALUE(PI_ELEM)      TYPE REF TO IF_IXML_ELEMENT
VALUE(PI_ATTR_NAME) TYPE STRING
VALUE(PI_VALUE)     TYPE ANY.

DATA: L_VALUE TYPE STRING.

L_VALUE = PI_VALUE.

IF L_VALUE IS INITIAL AND NOT SKIP_EMPTY_TAGS IS INITIAL.
EXIT.
ENDIF.

CALL METHOD PI_ELEM->SET_ATTRIBUTE
EXPORTING
NAME  = PI_ATTR_NAME
VALUE = L_VALUE.

ENDFORM.                    "add_attribute_to_node

*---------------------------------------------------------------------*
*       FORM xml_header                                               *
*---------------------------------------------------------------------*
FORM XML_HEADER USING VALUE(PI_PDOCUMENT) TYPE REF TO IF_IXML_DOCUMENT
VALUE(PI_XML_ROOT)  TYPE C
CHANGING VALUE(PC_ELEM)   TYPE REF TO IF_IXML_ELEMENT.

DATA:
L_SIMPLE_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_RESULT  TYPE I,
L_NAME  TYPE STRING.

L_NAME = PI_XML_ROOT .
L_ELEM = PI_PDOCUMENT->CREATE_ELEMENT( NAME = L_NAME ).
L_RESULT = PI_PDOCUMENT->APPEND_CHILD( L_ELEM ).
PC_ELEM = L_ELEM.

ENDFORM.                          " xml_header

*---------------------------------------------------------------------*
*       FORM create_xml_node                                          *
*---------------------------------------------------------------------*
FORM CREATE_XML_NODE USING
VALUE(PI_PDOCUMENT)   TYPE REF TO IF_IXML_DOCUMENT
VALUE(PARENT_ELEMENT) TYPE REF TO IF_IXML_ELEMENT
VALUE(PI_XML_NODE)    TYPE STRING
CHANGING VALUE(PC_ELEM) TYPE REF TO IF_IXML_ELEMENT.

PC_ELEM = PI_PDOCUMENT->CREATE_SIMPLE_ELEMENT(
NAME   = PI_XML_NODE
PARENT = PARENT_ELEMENT ).

ENDFORM.                          " create_xml_node

**---------------------------------------------------------------------*
**       FORM create_xml_node_value                                    *
**---------------------------------------------------------------------*
*FORM CREATE_XML_NODE_VALUE USING
*                     VALUE(PI_PDOCUMENT)   TYPE REF TO IF_IXML_DOCUMENT
*                     VALUE(PARENT_ELEMENT) TYPE REF TO IF_IXML_ELEMENT
*                     VALUE(PI_XML_NODE)    TYPE STRING
*                     VALUE(PI_VALUE)       TYPE ANY.
*
*  DATA: CDATA_ELEM TYPE REF TO IF_IXML_ELEMENT.
*
*  PERFORM CREATE_XML_NODE_VALUE_CDATA USING  PI_PDOCUMENT
*                                             PARENT_ELEMENT
*                                             PI_XML_NODE
*                                             PI_VALUE
*                                             SPACE
*                                      CHANGING CDATA_ELEM.
*
*ENDFORM.                          " create_xml_node_value

*---------------------------------------------------------------------*
*       FORM create_xml_node_value_cdata                              *
*---------------------------------------------------------------------*
FORM CREATE_XML_NODE_VALUE_CDATA USING
VALUE(PI_PDOCUMENT)   TYPE REF TO IF_IXML_DOCUMENT
VALUE(PARENT_ELEMENT) TYPE REF TO IF_IXML_ELEMENT
VALUE(PI_XML_NODE)    TYPE STRING
VALUE(PI_VALUE)       TYPE ANY
VALUE(PI_WITH_CDATA)  TYPE C
CHANGING
VALUE(PC_ELEM)        TYPE REF TO IF_IXML_ELEMENT.

DATA: L_VALUE TYPE STRING.

IF PI_WITH_CDATA = 'X'.

DATA: RVAL TYPE REF TO IF_IXML_CDATA_SECTION.
L_VALUE = PI_VALUE.
CALL METHOD PI_PDOCUMENT->CREATE_CDATA_SECTION
EXPORTING
CDATA = L_VALUE
RECEIVING
RVAL  = RVAL.

PC_ELEM =  PI_PDOCUMENT->CREATE_SIMPLE_ELEMENT(
NAME   = PI_XML_NODE
*                                    value  = l_value
PARENT = PARENT_ELEMENT ).

CALL METHOD PC_ELEM->APPEND_CHILD
EXPORTING
NEW_CHILD = RVAL.

ELSE.
L_VALUE = PI_VALUE.
PC_ELEM =  PI_PDOCUMENT->CREATE_SIMPLE_ELEMENT(
NAME   = PI_XML_NODE
VALUE  = L_VALUE
PARENT = PARENT_ELEMENT ).
ENDIF.

ENDFORM.                          " create_xml_node_value

*---------------------------------------------------------------------*
*       FORM add_etl_error_messages                                   *
*---------------------------------------------------------------------*
FORM ADD_ETL_ERROR_MESSAGES.

DATA: ETL_MESSAGES_NODE TYPE XML_ELEMENT.

SORT GT_ETL_MESSAGE BY ORDER.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'ETL_MESSAGES'
CHANGING ETL_MESSAGES_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_ETL_MESSAGE
USING G_IREF_PDOCUMENT
ETL_MESSAGES_NODE
'ETL_MESSAGE'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING ETL_MESSAGES_NODE 'X'.

ENDFORM.                    "add_etl_error_messages

*---------------------------------------------------------------------*
*       FORM add_etl_joblog                                           *
*---------------------------------------------------------------------*
FORM ADD_ETL_JOBLOG.

DATA: ETL_JOBLOG_NODE TYPE XML_ELEMENT.

SORT GT_ETL_JOBLOG BY ORDER.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'ETL_JOBLOG'
CHANGING ETL_JOBLOG_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_ETL_JOBLOG
USING G_IREF_PDOCUMENT
ETL_JOBLOG_NODE
'ETL_JOBLOG'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING ETL_JOBLOG_NODE 'X'.

ENDFORM.                    "add_etl_error_messages


*---------------------------------------------------------------------*
*       FORM add_servers_list                                         *
*---------------------------------------------------------------------*
FORM ADD_SERVERS_LIST.

DATA: ETL_SERVERS_LIST_NODE TYPE XML_ELEMENT.

IF NOT SERVERS IS INITIAL.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'SERVERS_LIST'
CHANGING ETL_SERVERS_LIST_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES SERVERS
USING G_IREF_PDOCUMENT
ETL_SERVERS_LIST_NODE
'SERVER'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING ETL_SERVERS_LIST_NODE 'X'.
FREE SERVERS.

ENDIF.

ENDFORM.                    "add_etl_error_messages

*---------------------------------------------------------------------*
*       FORM add_time_stats                                           *
*---------------------------------------------------------------------*
FORM ADD_TIME_STATS.

DATA: TIME_STATS_NODE TYPE XML_ELEMENT.

* Insert the total execution of ETL time
PERFORM ADD_TIME_STAT USING 'Total ETL execution time' STARTTIME.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'TIME_STATS'
CHANGING TIME_STATS_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_ETL_TIME_STAT
USING G_IREF_PDOCUMENT
TIME_STATS_NODE
'TIME_STAT'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING TIME_STATS_NODE 'X'.

ENDFORM.                    "add_etl_error_messages


*---------------------------------------------------------------------*
*       FORM extract_modifications                                    *
*---------------------------------------------------------------------*
FORM EXTRACT_MODIFICATIONS.

DATA: BEGIN OF CWBNTHEAD_ITAB OCCURS 0,
NUMM(10) TYPE N,
VERSNO(4) TYPE N,
THEMK(24),
INSTA(10),
MNUMM(10),
MYEAR(4) TYPE N,
INCOMPLETE,
END OF CWBNTHEAD_ITAB.

DATA: BEGIN OF CWBNTCUST_ITAB OCCURS 0,
NUMM(10) TYPE N,
NTSTATUS,
PRSTATUS,
CWBUSER(12),
END OF CWBNTCUST_ITAB.

DATA: MOD_ITAB TYPE TABLE OF SMODILOG,
E07T_ITAB TYPE TABLE OF E07T,
E070_ITAB TYPE TABLE OF E070,
E071_ITAB TYPE TABLE OF E071,
TEMP_DD02L TYPE DD02L,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting modifications'.

* extract smodilog
PERFORM APPEND_STRING_TO_FILE USING '<MODIFICATIONS>'.

SELECT * FROM SMODILOG
INTO TABLE MOD_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES MOD_ITAB
USING G_IREF_PDOCUMENT
'SMODILOG'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</MODIFICATIONS>'.

FREE MOD_ITAB.

* extract Change Request texts ( E070 )
PERFORM APPEND_STRING_TO_FILE USING '<CRS>'.

SELECT * FROM E070
INTO TABLE E070_ITAB PACKAGE SIZE PAC_SIZE
WHERE NOT TRKORR LIKE 'SAPK%'
AND   AS4USER <> 'SAP'
AND   AS4USER <> 'SAPUSER'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E070_ITAB
USING G_IREF_PDOCUMENT
'E070'.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</CRS>'.

* extract Change Request texts ( E071 )
PERFORM APPEND_STRING_TO_FILE USING '<CRS_OBJECTS>'.
IF NOT E070_ITAB[] IS INITIAL.
SELECT * FROM E071
INTO TABLE E071_ITAB PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN E070_ITAB
WHERE TRKORR = E070_ITAB-TRKORR.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E071_ITAB
USING G_IREF_PDOCUMENT
'E071'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</CRS_OBJECTS>'.

FREE E070_ITAB.
FREE E071_ITAB.

* extract Change Request texts ( E07T )
PERFORM APPEND_STRING_TO_FILE USING '<CR_TEXTS>'.

SELECT * FROM E07T
INTO TABLE E07T_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E07T_ITAB
USING G_IREF_PDOCUMENT
'E07T'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</CR_TEXTS>'.

FREE E07T_ITAB.

PERFORM GET_CR_FROM_PROD.

* extract Notest header data ( CWBNTHEAD )

* First check that table CWBNTHEAD and CWBNTCUST exist
SELECT SINGLE *
FROM DD02L
INTO TEMP_DD02L
WHERE TABNAME = 'CWBNTHEAD'.

IF SY-SUBRC IS INITIAL.
PERFORM APPEND_STRING_TO_FILE USING '<NOTES_HEADER>'.

SELECT * FROM ('CWBNTHEAD')
INTO CORRESPONDING FIELDS OF TABLE CWBNTHEAD_ITAB
PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES CWBNTHEAD_ITAB
USING G_IREF_PDOCUMENT
'CWBNTHEAD'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</NOTES_HEADER>'.

FREE CWBNTHEAD_ITAB.

ENDIF.

* extract Notest status data ( CWBNTCUST )

* First check that table CWBNTHEAD and CWBNTCUST exist
SELECT SINGLE *
FROM DD02L
INTO TEMP_DD02L
WHERE TABNAME = 'CWBNTCUST'.

IF SY-SUBRC IS INITIAL.
PERFORM APPEND_STRING_TO_FILE USING '<NOTES_STATUS>'.

SELECT * FROM ('CWBNTCUST')
INTO CORRESPONDING FIELDS OF TABLE CWBNTCUST_ITAB
PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES CWBNTCUST_ITAB
USING G_IREF_PDOCUMENT
'CWBNTCUST'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</NOTES_STATUS>'.

FREE CWBNTCUST_ITAB.

ENDIF.

PERFORM ADD_TIME_STAT USING 'Extract modifications' L_STARTTIME.

ENDFORM.                    "extract_modification

*&---------------------------------------------------------------------*
*&      Form  get_cr_from_prod
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM GET_CR_FROM_PROD.

DATA: DATE TYPE D,
E070_ITAB TYPE TABLE OF E070,
TAB_DATA TYPE TABLE OF TAB512,
SEL TYPE TABLE OF RFC_DB_OPT,
SEL_LINE LIKE LINE OF SEL,
FIELDS_TAB TYPE TABLE OF RFC_DB_FLD.


* extract Change Request ( E070 )
PERFORM APPEND_STRING_TO_FILE USING '<PROD_CRS>'.

DATE = SY-DATUM.

DO 6 TIMES.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].

CONCATENATE 'AS4DATE <= ''' DATE ''' AND' INTO SEL_LINE.
APPEND SEL_LINE TO SEL.

CALL FUNCTION 'CALCULATE_DATE'
EXPORTING
*       DAYS              = '0'
MONTHS            = '-6'
START_DATE        = DATE
IMPORTING
RESULT_DATE       = DATE
.

CONCATENATE 'AS4DATE > ''' DATE '''' INTO SEL_LINE.
APPEND SEL_LINE TO SEL.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'E070'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod CR: RFC_READ_TABLE of E070.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY
SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

E070_ITAB[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES E070_ITAB
USING G_IREF_PDOCUMENT
'PROD_E070'.

ENDDO.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_CRS>'.


ENDFORM.                    " get_cr_from_prod

*---------------------------------------------------------------------*
*       FORM extract_authorizations                                   *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTHORIZATIONS.

DATA: BEGIN OF AGR_DEFINE_REC.
INCLUDE STRUCTURE AGR_DEFINE.
DATA:   SOURCE_SYSTEM_ID TYPE SYSYSID,
END OF AGR_DEFINE_REC.

DATA: BEGIN OF AGR_NAME_REC,
AGR_NAME TYPE AGR_NAME,
END OF AGR_NAME_REC.

DATA: USOBX_C_ITAB TYPE TABLE OF USOBX_C,
USR12_ITAB TYPE TABLE OF USR12,
AGR1016_ITAB TYPE TABLE OF AGR_1016,
AGR_AGRS_ITAB TYPE TABLE OF AGR_AGRS,
AGR_TEXTS_ITABS TYPE TABLE OF AGR_TEXTS,
AGR_DEFINE_ITAB LIKE TABLE OF AGR_DEFINE_REC,
AGR_NAME_ITAB LIKE TABLE OF AGR_NAME_REC,
OPTIONS TYPE TABLE OF RFC_DB_OPT,
FIELDS TYPE TABLE OF RFC_DB_FLD,
AGR_USERS_ITAB TYPE TABLE OF AGR_USERS,
L_STARTTIME LIKE SY-UZEIT,
AGR_DEFINE_FROM_PROD_ITAB LIKE TABLE OF AGR_DEFINE_REC,
AGR1252_ITAB TYPE TABLE OF AGR_1252,
TAB_DATA TYPE TABLE OF TAB512,
TAB_REC LIKE LINE OF TAB_DATA.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting authorizations'.

PERFORM APPEND_STRING_TO_FILE USING '<AUTHORIZATIONS>'.

* export 'USR12' data
PERFORM APPEND_STRING_TO_FILE USING '<PROFILE_AUTHORIZATIONS>'.

SELECT * FROM USR12
INTO TABLE USR12_ITAB PACKAGE SIZE PAC_SIZE
WHERE MODBE <> 'SAP'
AND   MODBE <> 'DDIC'.

MESSAGE S000(CONV) WITH '*** profile auth. (USR12) packet'.
PERFORM ADD_MESSAGE USING '*** profile auth. (USR12) packet'
ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES USR12_ITAB
USING G_IREF_PDOCUMENT
'USR12'.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</PROFILE_AUTHORIZATIONS>'.
FREE USR12_ITAB.

* export AGR_DEFINE data
PERFORM APPEND_STRING_TO_FILE USING '<ROLES>'.

SELECT * FROM AGR_DEFINE
INTO CORRESPONDING FIELDS OF TABLE AGR_DEFINE_ITAB
PACKAGE SIZE PAC_SIZE
WHERE CREATE_USR <> 'SAP'
AND CREATE_USR <> 'DDIC'.

MESSAGE S000(CONV) WITH '*** role def. (AGR_DEFINE) packet'.
PERFORM ADD_MESSAGE USING '*** role def. (AGR_DEFINE) packet'
ABAP_TRUE.
PERFORM ADD_USED_MEMORY_TO_LOG.

* Fill system id and AGR_DEFINE
LOOP AT AGR_DEFINE_ITAB INTO AGR_DEFINE_REC.
AGR_DEFINE_REC-SOURCE_SYSTEM_ID = SY-SYSID.
MODIFY AGR_DEFINE_ITAB FROM AGR_DEFINE_REC.
ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_DEFINE_ITAB
USING G_IREF_PDOCUMENT
'AGR_DEFINE'.
ENDSELECT.

FREE AGR_DEFINE_ITAB.

* Get roles definitions from RFC destination ( only if it is
* different than current system )
IF ( RFC_SYSID <> SY-SYSID ).
CLEAR ERROR.

APPEND 'CREATE_USR <> ''SAP'' AND CREATE_USR <> ''DDIC''' TO OPTIONS.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'AGR_DEFINE'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = OPTIONS
FIELDS               = FIELDS
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC IS INITIAL AND
NOT TAB_DATA IS INITIAL.

*     Add lines of AGR_DEFINE from production
*     Because there are fields with DEC data type, MOVE-CORRESPONDING is
*     not working and the fields are read one by one
LOOP AT TAB_DATA INTO TAB_REC.
CLEAR AGR_DEFINE_REC.
AGR_DEFINE_REC-MANDT = TAB_REC(3).
AGR_DEFINE_REC-AGR_NAME = TAB_REC+3(30).
AGR_DEFINE_REC-PARENT_AGR = TAB_REC+33(30).
AGR_DEFINE_REC-CREATE_USR = TAB_REC+63(12).
AGR_DEFINE_REC-CREATE_DAT = TAB_REC+75(8).
AGR_DEFINE_REC-CREATE_TIM = TAB_REC+83(6).
AGR_DEFINE_REC-CHANGE_DAT = TAB_REC+116(8).
AGR_DEFINE_REC-CHANGE_TIM = TAB_REC+124(6).
AGR_DEFINE_REC-ATTRIBUTES = TAB_REC+157(10).
AGR_DEFINE_REC-SOURCE_SYSTEM_ID = RFC_SYSID.
APPEND AGR_DEFINE_REC TO AGR_DEFINE_FROM_PROD_ITAB.
ENDLOOP.
FREE TAB_DATA.

ELSE.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extraction of AGR_DEFINE from ' P_RFCDES
' failed. Error: ' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

ENDIF.

ENDIF.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_DEFINE_FROM_PROD_ITAB
USING G_IREF_PDOCUMENT
'AGR_DEFINE'.
FREE AGR_DEFINE_FROM_PROD_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</ROLES>'.

* export AGR_TEXTS data
PERFORM APPEND_STRING_TO_FILE USING '<ROLE_TEXTS>'.

SELECT AGR_NAME FROM AGR_DEFINE
INTO TABLE AGR_NAME_ITAB
PACKAGE SIZE PAC_SIZE
WHERE CREATE_USR <> 'SAP'
AND CREATE_USR <> 'DDIC'.

IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

SELECT * FROM AGR_TEXTS
INTO TABLE AGR_TEXTS_ITABS PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN AGR_NAME_ITAB
WHERE AGR_NAME = AGR_NAME_ITAB-AGR_NAME
AND LINE = '0000'.

MESSAGE S000(CONV) WITH '*** role text packet'.
PERFORM ADD_MESSAGE USING '*** role text packet' ABAP_TRUE.
PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_TEXTS_ITABS
USING G_IREF_PDOCUMENT
'AGR_TEXTS'.
ENDSELECT.

ENDIF.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</ROLE_TEXTS>'.
FREE AGR_TEXTS_ITABS.

* export AGR_1016 data
PERFORM APPEND_STRING_TO_FILE USING '<ROLE_PROFILE>'.

SELECT AGR_NAME FROM AGR_DEFINE
INTO TABLE AGR_NAME_ITAB
PACKAGE SIZE PAC_SIZE
WHERE CREATE_USR <> 'SAP'
AND CREATE_USR <> 'DDIC'.

IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

SELECT * FROM AGR_1016
INTO TABLE AGR1016_ITAB PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN AGR_NAME_ITAB
WHERE AGR_NAME = AGR_NAME_ITAB-AGR_NAME.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR1016_ITAB
USING G_IREF_PDOCUMENT
'AGR_1016'.
ENDSELECT.
ENDIF.

ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</ROLE_PROFILE>'.
FREE AGR1016_ITAB.

* export AGR_1252 data
PERFORM APPEND_STRING_TO_FILE USING '<ROLE_ORG_UNIT_FIELDS>'.

SELECT AGR_NAME FROM AGR_DEFINE
INTO TABLE AGR_NAME_ITAB
PACKAGE SIZE PAC_SIZE
WHERE CREATE_USR <> 'SAP'
AND CREATE_USR <> 'DDIC'.

IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

SELECT * FROM AGR_1252
INTO TABLE AGR1252_ITAB PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN AGR_NAME_ITAB
WHERE AGR_NAME = AGR_NAME_ITAB-AGR_NAME.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR1252_ITAB
USING G_IREF_PDOCUMENT
'AGR_1252'.
ENDSELECT.
ENDIF.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</ROLE_ORG_UNIT_FIELDS>'.
FREE AGR1252_ITAB.

* export composite roles AGR_AGRS data
PERFORM APPEND_STRING_TO_FILE USING '<COMPOSITE_ROLES>'.

SELECT AGR_NAME FROM AGR_DEFINE
INTO TABLE AGR_NAME_ITAB
PACKAGE SIZE PAC_SIZE
WHERE CREATE_USR <> 'SAP'
AND CREATE_USR <> 'DDIC'.

IF ( NOT AGR_NAME_ITAB[] IS INITIAL ).

SELECT * FROM AGR_AGRS
INTO TABLE AGR_AGRS_ITAB PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN AGR_NAME_ITAB
WHERE CHILD_AGR = AGR_NAME_ITAB-AGR_NAME.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_AGRS_ITAB
USING G_IREF_PDOCUMENT
'AGR_AGRS'.
ENDSELECT.

ENDIF.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</COMPOSITE_ROLES>'.

FREE AGR_NAME_ITAB.

* Export AGR_USERS data ( from production )
PERFORM EXTRACT_AUTHORIZATIONS_USAGE.

PERFORM APPEND_STRING_TO_FILE USING '</AUTHORIZATIONS>'.

PERFORM ADD_TIME_STAT USING 'Extract authorization' L_STARTTIME.

ENDFORM.                    "EXTRACT_AUTHORIZATIONS
*---------------------------------------------------------------------*
*       FORM extract_authorizations_usage                             *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTHORIZATIONS_USAGE.

DATA: AGR_USERS_ITAB TYPE TABLE OF AGR_USERS,
AGR_USERS_ITAB_BACKUP TYPE TABLE OF AGR_USERS,
OPTIONS TYPE TABLE OF RFC_DB_OPT,
OPTIONS_WA LIKE LINE OF OPTIONS,
FIELDS TYPE TABLE OF RFC_DB_FLD,
FIRST_AGR_NAME LIKE AGR_USERS-AGR_NAME,
LAST_AGR_NAME LIKE AGR_USERS-AGR_NAME,
LAST_AGR_USERS_ITAB LIKE AGR_USERS_ITAB,
WA_AGR_USERS_ITAB LIKE LINE OF AGR_USERS_ITAB,
CALL_RC LIKE SY-SUBRC,
CALL_NUM_ROWS TYPE I,
IS_FIRST TYPE C,
IS_LAST TYPE C,
AGR_USERS_ITAB_TEST TYPE TABLE OF AGR_USERS,
TEST,
LS_OPTIONS LIKE LINE OF OPTIONS,
AGR_USERS_SIZE TYPE SY-TFILL,
STR_AGR_SIZE TYPE STRING,
MESS_STR TYPE STRING,
STR_SUBRC TYPE STRING,
DATA_TAB TYPE TABLE OF TAB512,
DATA_WA TYPE TAB512,
EXTRACTED_USERS_NUM TYPE I VALUE 0,
EX_USERS_NUM_STR    TYPE STRING,
USERS_COUNT_NODE_STR TYPE STRING.


CHECK NOT GET_AGR_USERS IS INITIAL.

* export AGR_USERS data ( from production )
PERFORM APPEND_STRING_TO_FILE USING '<PROFILE_USERS>'.

* If the prod system is the current, there is
* no need to go through the RFC
IF ( RFC_SYSID = SY-SYSID ).

SELECT * FROM AGR_USERS
INTO TABLE AGR_USERS_ITAB PACKAGE SIZE PAC_SIZE
WHERE COL_FLAG <> 'X'.

MESSAGE S000(CONV) WITH '*** role usage (agr_users) packet'.
PERFORM ADD_MESSAGE USING '*** role usage (agr_users) packet'
ABAP_TRUE.
PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_USERS_ITAB
USING G_IREF_PDOCUMENT
'AGR_USERS'.
ENDSELECT.

ELSE.
CLEAR ERROR.
CLEAR OPTIONS.
CLEAR FIELDS.

*   Get the size of the agr users table in the rfc destination
*   before starting the iterations, and writing it to the log.
CALL FUNCTION 'SRTT_GET_TABLE_SIZE_RFC' DESTINATION P_RFCDES
EXPORTING
TABLE_NAME               = 'AGR_USERS'
IMPORTING
TABLE_SIZE               = AGR_USERS_SIZE
EXCEPTIONS
CLIENT_NOT_FOUND         = 1
TABLE_NOT_FOUND          = 2
TABLE_INKONSISTENT       = 3
PROTECTED                = 4
WRONG_TYPE               = 5
OTHERS                   = 6.
STR_SUBRC = SY-SUBRC.
IF STR_SUBRC <> 0.
CONCATENATE 'WARNING!! SY-SUBRC =' STR_SUBRC
'when calling SRTT_GET_TABLE_SIZE_RFC for AGR_USERS'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ELSE.
STR_AGR_SIZE = AGR_USERS_SIZE.
CONCATENATE 'AGR_USERS size in system' P_RFCDES 'is'  STR_AGR_SIZE
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED
BY SPACE.
ENDIF.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
CLEAR GT_ETL_MESSAGE.
PERFORM ADD_USED_MEMORY_TO_LOG.

*   No inherited users from composite roles needed
LS_OPTIONS-TEXT = 'COL_FLAG <> ''X'''.
APPEND LS_OPTIONS TO OPTIONS .

DO.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'AGR_USERS'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = AGR_USERS_ROW_COUNT
TABLES
OPTIONS              = OPTIONS
FIELDS               = FIELDS
DATA                 = AGR_USERS_ITAB
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

CALL_RC = SY-SUBRC.


IF CALL_RC IS INITIAL.
DESCRIBE TABLE AGR_USERS_ITAB LINES CALL_NUM_ROWS.
EXTRACTED_USERS_NUM = EXTRACTED_USERS_NUM + CALL_NUM_ROWS.

IF CALL_NUM_ROWS > 0.
FREE AGR_USERS_ITAB_BACKUP.

*       Remove the last role's data (will be fetched in the next round)
LOOP AT AGR_USERS_ITAB INTO WA_AGR_USERS_ITAB.
AT FIRST.
IS_FIRST = 'X'.
ENDAT.
IF IS_FIRST = 'X'.
CLEAR IS_FIRST.
FIRST_AGR_NAME = WA_AGR_USERS_ITAB-AGR_NAME.
ENDIF.

AT LAST.
IS_LAST = 'X'.
ENDAT.
IF IS_LAST = 'X'.
CLEAR IS_LAST.
LAST_AGR_NAME = WA_AGR_USERS_ITAB-AGR_NAME.
CLEAR: OPTIONS, OPTIONS_WA.

*           All records are the same role. Next fetch will be from the
*           following role
IF FIRST_AGR_NAME = LAST_AGR_NAME.
CONCATENATE 'AGR_NAME > ''' LAST_AGR_NAME ''''
INTO OPTIONS_WA-TEXT.
ELSE.
CONCATENATE 'AGR_NAME >= ''' LAST_AGR_NAME ''''
INTO OPTIONS_WA-TEXT.

*           Remove the last role's data
LOOP AT AGR_USERS_ITAB INTO WA_AGR_USERS_ITAB
WHERE AGR_NAME = LAST_AGR_NAME.
DELETE AGR_USERS_ITAB INDEX SY-TABIX.
APPEND WA_AGR_USERS_ITAB TO AGR_USERS_ITAB_BACKUP.
ENDLOOP.

ENDIF.
APPEND OPTIONS_WA TO OPTIONS.
ENDIF.
ENDLOOP.

MESSAGE S000(CONV) WITH '*** roles usage packet'.
PERFORM ADD_MESSAGE USING '*** roles usage packet' ABAP_TRUE.
PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_USERS_ITAB
USING G_IREF_PDOCUMENT
'AGR_USERS'.
FREE AGR_USERS_ITAB.
ENDIF.
ELSE.
CASE CALL_RC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extraction of AGR_USERS from ' P_RFCDES
' failed. Error: ' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

*   Failed to fetch records OR read all table content
IF CALL_RC <> 0 OR CALL_NUM_ROWS < AGR_USERS_ROW_COUNT.
MESSAGE S000(CONV) WITH '*** roles usage packet'.
PERFORM ADD_MESSAGE USING '*** roles usage packet' ABAP_TRUE.
PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AGR_USERS_ITAB_BACKUP
USING G_IREF_PDOCUMENT
'AGR_USERS'.

EXIT.
ENDIF.

ENDDO.
EX_USERS_NUM_STR = EXTRACTED_USERS_NUM.
CONCATENATE '<PROFILE_USERS_COUNT EXISTING="' STR_AGR_SIZE
'" EXTRACTED="' EX_USERS_NUM_STR '"/>'
INTO USERS_COUNT_NODE_STR.
PERFORM APPEND_STRING_TO_FILE USING USERS_COUNT_NODE_STR.

ENDIF. " IF ( RFC_SYSID <> SY-SYSID ).

PERFORM APPEND_STRING_TO_FILE USING '</PROFILE_USERS>'.

ENDFORM.                    "EXTRACT_AUTHORIZATIONS_USAGE

*---------------------------------------------------------------------*
*       FORM extract_auth_usage_only                                  *
*---------------------------------------------------------------------*
FORM EXTRACT_AUTH_USAGE_ONLY.

DATA:  L_STARTTIME LIKE SY-UZEIT.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting authorizations usage'.

PERFORM APPEND_STRING_TO_FILE USING '<AUTHORIZATIONS>'.

* Export AGR_USERS data ( from production )
PERFORM EXTRACT_AUTHORIZATIONS_USAGE.

PERFORM APPEND_STRING_TO_FILE USING '</AUTHORIZATIONS>'.

PERFORM ADD_TIME_STAT USING 'Extract authorizations usage'
L_STARTTIME.

ENDFORM.                    "EXTRACT_AUTH_USAGE_ONLY

*---------------------------------------------------------------------*
*       FORM extract_idocs                                   *
*---------------------------------------------------------------------*
FORM EXTRACT_IDOCS.

TYPES: BEGIN OF MLINK_WITH_USAGE.
INCLUDE TYPE BDI_MLINK.
TYPES:
USED TYPE XFELD,
END OF MLINK_WITH_USAGE.

DATA:
TAB_DATA TYPE TABLE OF TAB512,
SEL TYPE TABLE OF RFC_DB_OPT,
SEL_WA LIKE LINE OF SEL,
FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
FIELDS_WA LIKE LINE OF FIELDS_TAB,
ITAB_VIEW TYPE TABLE OF  BDI_VIEW,
ITAB_LSYS TYPE TABLE OF  BDI_LSYS,
ITAB_BLINK TYPE TABLE OF  BDI_BLINK,
ITAB_MLINK TYPE TABLE OF  BDI_MLINK,
WA_MLINK LIKE LINE OF ITAB_MLINK,
ITAB_MLINK_USAGE TYPE TABLE OF MLINK_WITH_USAGE,
WA_MLINK_USAGE LIKE LINE OF ITAB_MLINK_USAGE,
ITAB_MTYP TYPE TABLE OF  BDI_MTYP,
EDIMSGT_ITAB TYPE TABLE OF EDIMSGT,
TBD52_ITAB TYPE TABLE OF TBD52,
TBDBA_ITAB TYPE TABLE OF TBDBA,
TBDBE_ITAB TYPE TABLE OF TBDBE,
TBDME_ITAB TYPE TABLE OF TBDME.


CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting IDocs'.

PERFORM APPEND_STRING_TO_FILE USING '<IDOCS>'.

PERFORM APPEND_STRING_TO_FILE USING '<DISTRIBUTION_MODEL>'.

* Get the idoc distribution model
CALL FUNCTION 'MODEL_GET'
EXPORTING
LANGUAGE = SY-LANGU
TABLES
T_VIEW   = ITAB_VIEW
T_LSYS   = ITAB_LSYS
T_BLINK  = ITAB_BLINK
T_MLINK  = ITAB_MLINK
T_MTYP   = ITAB_MTYP.
*     T_BFLT         =
*     T_MFLT         =
*     T_BPRM         =
*     T_FOBJT        =
*     T_FOBJV        =

FIELDS_WA-FIELDNAME = 'IDOCTP'.
APPEND FIELDS_WA TO FIELDS_TAB.
FIELDS_WA-FIELDNAME = 'MESTYP'.
APPEND FIELDS_WA TO FIELDS_TAB.

LOOP AT ITAB_MLINK INTO WA_MLINK.
WA_MLINK_USAGE = WA_MLINK.
REFRESH TAB_DATA.
REFRESH SEL.
CONCATENATE 'MESTYP =''' WA_MLINK-MESTYP '''' INTO SEL_WA-TEXT.
*      separated by space .
APPEND SEL_WA TO SEL.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'EDIDC'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 5
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.
IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract idocs: RFC_READ_TABLE, message:'
WA_MLINK-MESTYP 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

IF TAB_DATA IS INITIAL.
CLEAR WA_MLINK_USAGE-USED.
ELSE.
WA_MLINK_USAGE-USED = 'X'.
ENDIF.
APPEND WA_MLINK_USAGE TO ITAB_MLINK_USAGE.

ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_VIEW
USING G_IREF_PDOCUMENT
'MODEL_VIEW'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_LSYS
USING G_IREF_PDOCUMENT
'LOGICAL_SYSTEM'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_BLINK
USING G_IREF_PDOCUMENT
'BAPI_LINK'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_MLINK_USAGE
USING G_IREF_PDOCUMENT
'MESSAGE_LINK'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB_MTYP
USING G_IREF_PDOCUMENT
'MESSAGE_TYPE'.

PERFORM APPEND_STRING_TO_FILE USING '</DISTRIBUTION_MODEL>'.
FREE: ITAB_VIEW, ITAB_LSYS, ITAB_BLINK, ITAB_MLINK, ITAB_MTYP.

* export EDIMSGT data
PERFORM APPEND_STRING_TO_FILE USING '<IDOC_MESSAGE_DESC>'.

* Extract all the message type description (not only of the model)
SELECT * FROM EDIMSGT
INTO TABLE EDIMSGT_ITAB PACKAGE SIZE PAC_SIZE
WHERE LANGUA = 'E'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES EDIMSGT_ITAB
USING G_IREF_PDOCUMENT
'EDIMSGT'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</IDOC_MESSAGE_DESC>'.

* export TBD52 data
PERFORM APPEND_STRING_TO_FILE USING '<EVENT_FUNCTION>'.

SELECT * FROM TBD52
INTO TABLE TBD52_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBD52_ITAB
USING G_IREF_PDOCUMENT
'TBD52'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</EVENT_FUNCTION>'.

* export TBDBA data
PERFORM APPEND_STRING_TO_FILE USING '<BAPI_MESSAGE>'.

SELECT * FROM TBDBA
INTO TABLE TBDBA_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBDBA_ITAB
USING G_IREF_PDOCUMENT
'TBDBA'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</BAPI_MESSAGE>'.

* export TBDBE data
PERFORM APPEND_STRING_TO_FILE USING '<BAPI_INBOUND>'.

SELECT * FROM TBDBE
INTO TABLE TBDBE_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBDBE_ITAB
USING G_IREF_PDOCUMENT
'TBDBE'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</BAPI_INBOUND>'.

* export TBDME data
PERFORM APPEND_STRING_TO_FILE USING '<MESS_SUPP_DATA>'.

SELECT * FROM TBDME
INTO TABLE TBDME_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TBDME_ITAB
USING G_IREF_PDOCUMENT
'TBDME'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</MESS_SUPP_DATA>'.

PERFORM EXTRACT_PARTNERS_WITH_USAGE.

PERFORM APPEND_STRING_TO_FILE USING '</IDOCS>'.

PERFORM ADD_TIME_STAT USING 'Extract IDOCs' L_STARTTIME.

ENDFORM.                    "EXTRACT_IDOCS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PARTNERS_WITH_USAGE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_PARTNERS_WITH_USAGE .


TYPES: BEGIN OF TY_IDOC_USAGE_KEY,
DIRECTION TYPE EDI_DIRECT,
MESSAGE_TYPE TYPE EDIPMESTYP,
PARTNER TYPE EDIPRCVPRN,
PARTNER_TYPE TYPE EDIPRCVPRT,
END OF TY_IDOC_USAGE_KEY,
BEGIN OF TY_IDOC_USAGE,
INCLUDE TYPE TY_IDOC_USAGE_KEY,
COUNT TYPE NUMC10,
LAST_USED TYPE DATUM,
*           In an Inbound message we don't have idoc type in the
*           partner profile metadata
IDOC_TYPE TYPE EDIPIDOCTP,
END OF TY_IDOC_USAGE.

DATA:
TAB_DATA TYPE TABLE OF TAB512,
SEL TYPE TABLE OF RFC_DB_OPT,
FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
PP_OUT_ITAB TYPE TABLE OF EDP13,
PP_OUT_WA LIKE LINE OF PP_OUT_ITAB,
PP_IN_ITAB TYPE TABLE OF EDP21,
PP_IN_WA LIKE LINE OF PP_IN_ITAB,
L_STARTTIME LIKE SY-UZEIT,
LT_USAGE_PARTNER_IDOC TYPE TT_USAGE_CALLER,
LS_USAGE_PARTNER_IDOC TYPE TY_USAGE_CALLER,
LT_IDOC_USAGE_KEY TYPE STANDARD TABLE OF TY_IDOC_USAGE_KEY,
LS_IDOC_USAGE_KEY TYPE TY_IDOC_USAGE_KEY,
LT_IDOC_USAGE TYPE STANDARD TABLE OF TY_IDOC_USAGE,
LS_IDOC_USAGE TYPE TY_IDOC_USAGE,
LV_LINES TYPE I,
LV_STR TYPE STRING,
LV_MAX_IDOC_USAGE_PAIRS_STR TYPE STRING,
LV_MAX_IDOC_USAGE_TIME_STR(8) TYPE C,
IS_USAGE_AGGREGATED TYPE C,
LV_USAGE_END_DATE TYPE SY-DATUM,
LV_USAGE_END_TIME TYPE SY-UZEIT.

CLEAR: SEL, FIELDS_TAB, TAB_DATA.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'EDP13'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract idocs: RFC_READ_TABLE of EDP13.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '<PARTNER_PROFILE_OUTBOUND>'.

PP_OUT_ITAB[] = TAB_DATA[].
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES PP_OUT_ITAB
USING G_IREF_PDOCUMENT
'EDP13'.

* Get the idoc partner usage of the last three months
IF NOT EXTRACT_IDOCS_USAGE IS INITIAL.
CLEAR LV_LINES.
DESCRIBE TABLE PP_OUT_ITAB LINES LV_LINES.
LV_STR = LV_LINES.

CONCATENATE 'Outbound Idoc partner messages: ' LV_STR
INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.

*   We collect the usage according to partner and Message type
*   (A few EDP13 records can be accomulated to one usage)
SORT PP_OUT_ITAB BY RCVPRN RCVPRT MESTYP.
DELETE ADJACENT DUPLICATES FROM PP_OUT_ITAB COMPARING RCVPRN
RCVPRT MESTYP.

LOOP AT PP_OUT_ITAB INTO PP_OUT_WA.
LS_IDOC_USAGE_KEY-DIRECTION = '1'. " Direction = outbound
LS_IDOC_USAGE_KEY-MESSAGE_TYPE = PP_OUT_WA-MESTYP.
LS_IDOC_USAGE_KEY-PARTNER = PP_OUT_WA-RCVPRN.
LS_IDOC_USAGE_KEY-PARTNER_TYPE = PP_OUT_WA-RCVPRT.

APPEND LS_IDOC_USAGE_KEY TO LT_IDOC_USAGE_KEY.
ENDLOOP.
ENDIF.

FREE PP_OUT_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</PARTNER_PROFILE_OUTBOUND>'.

CLEAR: SEL, FIELDS_TAB, TAB_DATA.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'EDP21'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract idocs: RFC_READ_TABLE of EDP21.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '<PARTNER_PROFILE_INBOUND>'.

PP_IN_ITAB[] = TAB_DATA[].
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES PP_IN_ITAB
USING G_IREF_PDOCUMENT
'EDP21'.

* Get the idoc partner usage of the last three months
IF NOT EXTRACT_IDOCS_USAGE IS INITIAL.

CLEAR LV_LINES.
DESCRIBE TABLE PP_IN_ITAB LINES LV_LINES.
LV_STR = LV_LINES.

CONCATENATE 'Inbound Idoc partner messages: ' LV_STR
INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.

*   We collect the usage according to partner and Message type
*   (A few EDP21 records can be accomulated to one usage)
SORT PP_IN_ITAB BY SNDPRN SNDPRT MESTYP.
DELETE ADJACENT DUPLICATES FROM PP_IN_ITAB COMPARING SNDPRN SNDPRT
MESTYP.

LOOP AT PP_IN_ITAB INTO PP_IN_WA.
LS_IDOC_USAGE_KEY-DIRECTION = '2'. " Direction = inbound
LS_IDOC_USAGE_KEY-MESSAGE_TYPE = PP_IN_WA-MESTYP.
LS_IDOC_USAGE_KEY-PARTNER = PP_IN_WA-SNDPRN.
LS_IDOC_USAGE_KEY-PARTNER_TYPE = PP_IN_WA-SNDPRT.

APPEND LS_IDOC_USAGE_KEY TO LT_IDOC_USAGE_KEY.
ENDLOOP.
ENDIF.

FREE PP_IN_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</PARTNER_PROFILE_INBOUND>'.

** Extract IDoc Usage

* If there are too many Partner-IDoc pairs for fetching the usage
* for each pair, we fetch it for each IDoc message.
CLEAR LV_LINES.
DESCRIBE TABLE LT_IDOC_USAGE_KEY LINES LV_LINES.
LV_STR = LV_LINES.

IF LV_LINES > MAX_IDOC_USAGE_PAIRS.
LV_MAX_IDOC_USAGE_PAIRS_STR = MAX_IDOC_USAGE_PAIRS.
CONCATENATE 'IDoc pairs: ' LV_STR '(more than '
LV_MAX_IDOC_USAGE_PAIRS_STR '). '
'Aggregated Usage data will be fetched.'
INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.

*   Make the IDoc key table distinct according to
*   direction and message type
SORT LT_IDOC_USAGE_KEY BY DIRECTION MESSAGE_TYPE.
DELETE ADJACENT DUPLICATES FROM LT_IDOC_USAGE_KEY
COMPARING DIRECTION MESSAGE_TYPE.
IS_USAGE_AGGREGATED = 'X'.

DESCRIBE TABLE LT_IDOC_USAGE_KEY LINES LV_LINES.
LV_STR = LV_LINES.

CONCATENATE 'Extract Idoc Usage of: ' LV_STR
' IDoc messages.' INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
ELSE.
LV_STR = LV_LINES.

CONCATENATE 'Extract Idoc Usage of: ' LV_STR
' partner messages.' INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
ENDIF.

CONCATENATE '<PARTNER_IDOCS_USAGE IS_USAGE_AGRREGATED="'
IS_USAGE_AGGREGATED '"> ' INTO LV_STR.
PERFORM APPEND_STRING_TO_FILE USING LV_STR.

* Calc the max time the IDoc Usage should take.
CALL FUNCTION 'C14B_ADD_TIME'
EXPORTING
I_STARTTIME = SY-UZEIT
I_STARTDATE = SY-DATUM
I_ADDTIME   = MAX_IDOC_USAGE_TIME
IMPORTING
E_ENDTIME   = LV_USAGE_END_TIME
E_ENDDATE   = LV_USAGE_END_DATE.

LOOP AT LT_IDOC_USAGE_KEY INTO LS_IDOC_USAGE_KEY.

*   Make sure the IDoc usage doesn't take too much time
*   (more than 45 min)
IF ( SY-DATUM > LV_USAGE_END_DATE OR
SY-UZEIT > LV_USAGE_END_TIME ).

WRITE MAX_IDOC_USAGE_TIME TO LV_MAX_IDOC_USAGE_TIME_STR.
LV_STR = SY-TABIX.
CONCATENATE 'Extract Idoc Usage takes more than '
LV_MAX_IDOC_USAGE_TIME_STR
'. Stopping extraction at row: ' LV_STR
INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.

EXIT.
ENDIF.

*   Fetch usage only according to direction and message type
*   when there are too many pairs
IF ( IS_USAGE_AGGREGATED = 'X' ).
CLEAR LS_IDOC_USAGE_KEY-PARTNER.
CLEAR LS_IDOC_USAGE_KEY-PARTNER_TYPE.
ENDIF.

CLEAR LT_USAGE_PARTNER_IDOC[].

PERFORM GET_USAGE_BY_MONTHS_BACK
USING LS_IDOC_USAGE_KEY-DIRECTION
LS_IDOC_USAGE_KEY-MESSAGE_TYPE
LS_IDOC_USAGE_KEY-PARTNER
LS_IDOC_USAGE_KEY-PARTNER_TYPE
'IDOCS'
CHANGING LT_USAGE_PARTNER_IDOC.

IF ( NOT LT_USAGE_PARTNER_IDOC[] IS INITIAL ).
LOOP AT LT_USAGE_PARTNER_IDOC INTO LS_USAGE_PARTNER_IDOC.
MOVE-CORRESPONDING LS_IDOC_USAGE_KEY TO LS_IDOC_USAGE.
MOVE-CORRESPONDING LS_USAGE_PARTNER_IDOC TO LS_IDOC_USAGE.
*        In the case of an Inbound message we don't have the idoc type
*        in the profile metadata, only in the usage
LS_IDOC_USAGE-IDOC_TYPE = LS_USAGE_PARTNER_IDOC-CALLER.
APPEND LS_IDOC_USAGE TO LT_IDOC_USAGE.
ENDLOOP.
ENDIF.

ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_IDOC_USAGE
USING G_IREF_PDOCUMENT
'IDOC_USAGE'.

PERFORM APPEND_STRING_TO_FILE USING '</PARTNER_IDOCS_USAGE>'.

FREE : LT_IDOC_USAGE, LT_IDOC_USAGE_KEY.

ENDFORM.                    " EXTRACT_PARTNERS_WITH_USAGE

*---------------------------------------------------------------------*
*       FORM EXTRACT_IDOCS_USAGE_ONLY                                 *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_IDOCS_USAGE_ONLY.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting IDocs'.

PERFORM APPEND_STRING_TO_FILE USING '<IDOCS>'.
PERFORM EXTRACT_PARTNERS_WITH_USAGE.
PERFORM APPEND_STRING_TO_FILE USING '</IDOCS>'.

PERFORM ADD_TIME_STAT USING 'Extract IDOCs' L_STARTTIME.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  GET_IDOCS_USAGE_BY_DATES
*&---------------------------------------------------------------------*
FORM GET_IDOCS_USAGE_BY_DATES
USING DIRECTION
MESSAGE_TYPE
PARTNER
PARTNER_TYPE
START_DATE TYPE DATUM
END_DATE TYPE DATUM
CHANGING IDOC_PARTNER_USAGE TYPE TT_USAGE_CALLER.

DATA:
TAB_DATA TYPE TABLE OF TAB512,
SEL TYPE TABLE OF RFC_DB_OPT,
SEL_WA LIKE LINE OF SEL,
FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
FIELDS_WA LIKE LINE OF FIELDS_TAB,
LS_IDOC_PARTNER_USAGE TYPE TY_USAGE_CALLER,
LV_SUBRC TYPE STRING,
LV_LINES TYPE I,
LV_IDOCTY TYPE EDIPIDOCTP.

CONCATENATE 'Idoc Usage m:' MESSAGE_TYPE  ' p:' PARTNER
' d:' END_DATE INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.

FIELDS_WA-FIELDNAME = 'IDOCTP'.
APPEND FIELDS_WA TO FIELDS_TAB.

REFRESH TAB_DATA.
REFRESH SEL.
CONCATENATE ' DIRECT = ''' DIRECTION '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.
CONCATENATE ' AND MESTYP = ''' MESSAGE_TYPE '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.
CONCATENATE ' AND CREDAT >= ''' START_DATE '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.
CONCATENATE ' AND CREDAT <= ''' END_DATE '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.

* Partner will be initial when there are lots of IDoc Partner pair,
* and we get aggrigated data per IDoc message.
IF NOT PARTNER IS INITIAL.
IF ( DIRECTION = '1' ). " Outbound
CONCATENATE ' AND RCVPRN = ''' PARTNER '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.
CONCATENATE ' AND RCVPRT = ''' PARTNER_TYPE '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.
ELSE. " Inbound
CONCATENATE ' AND SNDPRN = ''' PARTNER '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.
CONCATENATE ' AND SNDPRT = ''' PARTNER_TYPE '''' INTO SEL_WA-TEXT.
APPEND SEL_WA TO SEL.
ENDIF.
ENDIF.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'EDIDC'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR LV_SUBRC.
CASE SY-SUBRC.
WHEN 1. LV_SUBRC = 'TABLE_NOT_AVAILABLE'.
WHEN 2. LV_SUBRC = 'TABLE_WITHOUT_DATA'.
WHEN 3. LV_SUBRC = 'OPTION_NOT_VALID'.
WHEN 4. LV_SUBRC = 'FIELD_NOT_VALID'.
WHEN 5. LV_SUBRC = 'NOT_AUTHORIZED'.
WHEN 6. LV_SUBRC = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. LV_SUBRC = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extract idocs usage: RFC_READ_TABLE, Error:'
LV_SUBRC 'Idoc:' MESSAGE_TYPE 'Partner:' PARTNER
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
*   Check how many messages returned
DESCRIBE TABLE TAB_DATA LINES LV_LINES.
IF LV_LINES > 0.
*     Get the iDoc type
*     (in an Inbound we don't have it in the profile metadata)
READ TABLE TAB_DATA INDEX 1 INTO LV_IDOCTY.
LS_IDOC_PARTNER_USAGE-CALLER = LV_IDOCTY.
LS_IDOC_PARTNER_USAGE-COUNT = LV_LINES.
LS_IDOC_PARTNER_USAGE-LAST_USED = END_DATE.
APPEND LS_IDOC_PARTNER_USAGE TO IDOC_PARTNER_USAGE.
ENDIF.
ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
*       FORM EXTRACT_NAMESPACES                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_NAMESPACES.

DATA: TRNSPACE_ITAB TYPE TABLE OF TRNSPACE,
TRNSPACET_ITAB TYPE TABLE OF TRNSPACET,
TRNSPACETT_ITAB TYPE TABLE OF TRNSPACETT,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting namespaces'.

PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACES>'.

* export 'TRNSPACE' data
PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACE_RUNTIME>'.

SELECT * FROM TRNSPACE
INTO TABLE TRNSPACE_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TRNSPACE_ITAB
USING G_IREF_PDOCUMENT
'TRNSPACE'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACE_RUNTIME>'.
FREE TRNSPACE_ITAB.

* export 'TRNSPACET' data
PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACE_TRANSPORTABLE>'.

SELECT * FROM TRNSPACET
INTO TABLE TRNSPACET_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TRNSPACET_ITAB
USING G_IREF_PDOCUMENT
'TRNSPACET'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACE_TRANSPORTABLE>'.
FREE TRNSPACET_ITAB.

* export 'TRNSPACETT' data
PERFORM APPEND_STRING_TO_FILE USING '<NAMESPACE_TEXTS>'.

SELECT * FROM TRNSPACETT
INTO TABLE TRNSPACETT_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TRNSPACETT_ITAB
USING G_IREF_PDOCUMENT
'TRNSPACETT'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACE_TEXTS>'.
FREE TRNSPACETT_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</NAMESPACES>'.

PERFORM ADD_TIME_STAT USING 'Extract namespaces' L_STARTTIME.

ENDFORM.                    "EXTRACT_NAMESPACES

*&---------------------------------------------------------------------*
*&      Form  period_to_montes
*&---------------------------------------------------------------------*
FORM PERIOD_TO_MONTES USING BEGDA
ENDDA
CHANGING PTMONTH TYPE TABLE.

DATA: DATE TYPE DATUM,
LAST_MONTH(2) TYPE N,
CURR_MONTH(2) TYPE N.

DATE = BEGDA.

WHILE DATE < ENDDA.
APPEND DATE TO PTMONTH.
CALL FUNCTION 'RE_ADD_MONTH_TO_DATE'
EXPORTING
MONTHS  = '1'
OLDDATE = DATE
IMPORTING
NEWDATE = DATE.
ENDWHILE.

* Add handle last date: only if the monthes equal, add it.
* There are cases when the last month will be higher than current month,
* in these cases we wouldn't like to add the last month.
LAST_MONTH = DATE+4(2).
CURR_MONTH = BEGDA+4(2).
IF ( LAST_MONTH = CURR_MONTH ).
APPEND DATE TO PTMONTH.
ENDIF.

ENDFORM.                    " period_to_montes

*---------------------------------------------------------------------*
*       FORM PERIOD_TO_WEEKS                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  BEGDA                                                         *
*  -->  ENDDA                                                         *
*  -->  PTWEEK                                                        *
*---------------------------------------------------------------------*
FORM PERIOD_TO_WEEKS USING  BEGDA
ENDDA
CHANGING PTWEEK TYPE TABLE.

DATA: DATE TYPE DATUM.

DATE = BEGDA.

WHILE DATE < ENDDA.
DATE = DATE + 7.
APPEND DATE TO PTWEEK.
ENDWHILE.

ENDFORM.                    "PERIOD_TO_WEEKS

*---------------------------------------------------------------------*
*       FORM PERIOD_TO_DAYS                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  BEGDA                                                         *
*  -->  ENDDA                                                         *
*  -->  PTDAY                                                         *
*---------------------------------------------------------------------*
FORM PERIOD_TO_DAYS USING  BEGDA
ENDDA
CHANGING PTDAY TYPE TABLE.

DATA: DATE TYPE DATUM.

DATE = BEGDA.

WHILE DATE < ENDDA.
DATE = DATE + 1.
APPEND DATE TO PTDAY.
ENDWHILE.

ENDFORM.                    "PERIOD_TO_DAYS

*&---------------------------------------------------------------------*
*&      Form  extract_usage
*&---------------------------------------------------------------------*
FORM EXTRACT_USAGE .

TYPES: BEGIN OF T_USAGE_ENTRIES,
TOTAL_ENTRIES TYPE I,
END OF T_USAGE_ENTRIES.

DATA: LS_USAGE_ENTRIES TYPE T_USAGE_ENTRIES,
LT_USAGE_ENTRIES TYPE TABLE OF T_USAGE_ENTRIES.

DATA: TCODESTAT  TYPE TABLE OF SAPWLUSTCX,
RFC_STAT   TYPE TABLE OF SAPWLRFCS,
RFC_STAT_REC LIKE LINE OF RFC_STAT,
TCODE_LINE LIKE LINE OF TCODESTAT.

DATA: BEGIN OF ENTRY_ID_TYPE,
TCODE_OR_REPORT LIKE SAPWLPFNRM-REPORT,
JOBNAME         LIKE SAPWLPFBTC-JOBNAME,
TYPE,           "T)code or R)eport F)unction?
END OF ENTRY_ID_TYPE.

DATA: TWO_YEARS_BACK TYPE BEGDA.

DATA: USAGE_NODE TYPE XML_ELEMENT,
LV_LAYOUTS_USAGE_NODE TYPE XML_ELEMENT,
USERS_NODE TYPE XML_ELEMENT,
CALLERS_NODE TYPE XML_ELEMENT,
LT_USAGE_TCODE_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
LT_USAGE_USERS_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE.

DATA: SAPWLSERV_TAB TYPE TABLE OF SAPWLSERV,
SAPWLSERV_REC LIKE LINE OF SAPWLSERV_TAB,
OPTIONS TYPE TABLE OF RFC_DB_OPT,
FIELDS TYPE TABLE OF RFC_DB_FLD,
INSTANCE_NAME LIKE SAPWLSERV-NAME,
L_STARTTIME LIKE SY-UZEIT,
IS_DATA.

DATA: FULL_TCODESTAT TYPE TABLE OF SAPWLUSTCX.

DATA: LT_MONTH   TYPE TABLE OF SY-DATUM,
LT_WEEK    TYPE TABLE OF SY-DATUM,
LT_DAY     TYPE TABLE OF SY-DATUM.

DATA: DATATAB TYPE TABLE OF OUTREC.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting Usage'.

* Get the servers for instances
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE = 'SAPWLSERV'
DELIMITER   = SPACE
NO_DATA     = SPACE
ROWSKIPS    = 0
ROWCOUNT    = 0
TABLES
OPTIONS     = OPTIONS
FIELDS      = FIELDS
DATA        = SAPWLSERV_TAB.

* Create a child node for the Usage node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'USAGE'
CHANGING USAGE_NODE.

PERFORM APPEND_STRING_TO_FILE USING '<USAGE>'.

PERFORM EXTRACT_WEB_USAGE_CONFIG USING USAGE_NODE.

* // Convert Date Range To Table Of Months
* // e.g: 20071201 - 20080201 => 20071201
* //                             20080101
* //                             20080201
TWO_YEARS_BACK = SY-DATUM - 730.
PERFORM PERIOD_TO_MONTES USING TWO_YEARS_BACK
SY-DATUM
CHANGING LT_MONTH.

* // Retrieve From All Application Servers in The SAP Landscape The
* // Tcode & Report
* // Usage Statistics Per Each Month In The Table
PERFORM EXTRACT_USAGE_FOR_PERIOD TABLES LT_MONTH
SAPWLSERV_TAB
FULL_TCODESTAT
USING 'M'
CHANGING IS_DATA.


* If no monthly data was found - get weekly data
IF IS_DATA IS INITIAL.

*   Get weeks two years back
PERFORM PERIOD_TO_WEEKS USING TWO_YEARS_BACK
SY-DATUM
CHANGING LT_WEEK.

PERFORM EXTRACT_USAGE_FOR_PERIOD TABLES LT_WEEK
SAPWLSERV_TAB
FULL_TCODESTAT
USING 'W'
CHANGING IS_DATA.
ENDIF.

* If no monthly and weekly data was found - get daily data
IF IS_DATA IS INITIAL.

*   Get days two years back
PERFORM PERIOD_TO_DAYS USING TWO_YEARS_BACK
SY-DATUM
CHANGING LT_DAY.

PERFORM EXTRACT_USAGE_FOR_PERIOD TABLES LT_DAY
SAPWLSERV_TAB
FULL_TCODESTAT
USING 'D'
CHANGING IS_DATA.
ENDIF.

* If no usage was found at all, throw error message
DATA: MSG1 TYPE STRING,
MSG2 TYPE STRING.

IF IS_DATA IS INITIAL.
NO_USAGE = 'X'.
ENDIF.

* Read infotype statistics
PERFORM READ_INFOTYPE_STATISCTICS CHANGING DATATAB.

IF NOT DATATAB[] IS INITIAL.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES DATATAB
USING G_IREF_PDOCUMENT
'USAGE_TCODE'.
ENDIF.

* Create a child node for the layouts usage node
*  perform create_xml_node using g_iref_pdocument g_iref_root_elem
*                                'LAYOUTS_USAGE'
*                          changing lv_layouts_usage_node.
*  perform append_string_to_file using '<LAYOUTS_USAGE>'.
*
** Read layouts usage
*  perform add_layouts_usage using two_years_back
*                                  lv_layouts_usage_node.
*  perform append_string_to_file using '</LAYOUTS_USAGE>'.

* Extract full usage data
IF NOT EXTRACT_FULL_USAGE IS INITIAL AND
NO_SUET_DATA IS INITIAL.
*   Full usage entries count
DESCRIBE TABLE FULL_TCODESTAT LINES LS_USAGE_ENTRIES-TOTAL_ENTRIES.
APPEND LS_USAGE_ENTRIES TO LT_USAGE_ENTRIES.

PERFORM APPEND_STRING_TO_FILE USING '<ST03N_ENTRIES>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_USAGE_ENTRIES
USING G_IREF_PDOCUMENT
'ST03N_ENTRIES'.
PERFORM APPEND_STRING_TO_FILE USING '</ST03N_ENTRIES>'.

*   Full usage data
PERFORM APPEND_STRING_TO_FILE USING '<FULL_ST03N>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES FULL_TCODESTAT
USING G_IREF_PDOCUMENT
'ST03N'.
PERFORM APPEND_STRING_TO_FILE USING '</FULL_ST03N>'.
ENDIF.

FREE: DATATAB, FULL_TCODESTAT[].

IF NOT EXTRACT_PROXY_DATA IS INITIAL.
PERFORM EXTRACT_PROXIES_USAGE.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '</USAGE>'.

PERFORM ADD_TIME_STAT USING 'Extract usage' L_STARTTIME.

ENDFORM.                    " extract_usage

*---------------------------------------------------------------------*
*       FORM READ_INFOTYPE_STATISCTICS                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_DATATAB                                                     *
*---------------------------------------------------------------------*
FORM READ_INFOTYPE_STATISCTICS  CHANGING P_DATATAB TYPE TABLE.

TYPES: BEGIN OF T582A_TYPE,
INFTY(4) TYPE C,
END OF T582A_TYPE.

DATA: T582A_TAB TYPE TABLE OF T582A_TYPE,
T582A_REC LIKE LINE OF T582A_TAB,
DBTABLE LIKE DD02L-TABNAME,
NO_OF_ENTERIES TYPE I,
DUMMY_TABLE TYPE TABLE OF TAB512,
OPTIONS TYPE TABLE OF RFC_DB_OPT,
FIELDS TYPE TABLE OF RFC_DB_FLD,
FIELD_WA LIKE LINE OF FIELDS.

DATA: BEGIN OF RECORD,
PERIOD  TYPE CHAR6,
TCODE   TYPE SAPWLPFNRM-REPORT,
JOBNAME TYPE SY-CPROG,
TYPE    TYPE CHAR1,
USAGE   TYPE P,
USERS   TYPE P,
END OF RECORD.

DATA: OUTREC     TYPE OUTREC.

FIELD_WA-FIELDNAME = 'INFTY'.
APPEND FIELD_WA TO FIELDS.

* Select all Infotypes
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE = 'T582A'
DELIMITER   = SPACE
NO_DATA     = SPACE
ROWSKIPS    = 0
ROWCOUNT    = 0
TABLES
OPTIONS     = OPTIONS
FIELDS      = FIELDS
DATA        = T582A_TAB
EXCEPTIONS
TABLE_NOT_AVAILABLE        = 1
TABLE_WITHOUT_DATA         = 2
OPTION_NOT_VALID           = 3
FIELD_NOT_VALID            = 4
NOT_AUTHORIZED             = 5
DATA_BUFFER_EXCEEDED       = 6
OTHERS                     = 7.

IF SY-SUBRC <> 0.
EXIT.
ENDIF.

LOOP AT T582A_TAB INTO T582A_REC.

*   Derive the table name
CONCATENATE 'PA' T582A_REC-INFTY INTO DBTABLE.

*   Get the number of enteries for this table
CALL FUNCTION 'SRTT_GET_TABLE_SIZE_RFC'
DESTINATION P_RFCDES
EXPORTING
TABLE_NAME         = DBTABLE
IMPORTING
TABLE_SIZE         = NO_OF_ENTERIES
EXCEPTIONS
CLIENT_NOT_FOUND   = 1
TABLE_NOT_FOUND    = 2
TABLE_INKONSISTENT = 3
PROTECTED          = 4
WRONG_TYPE         = 5
OTHERS             = 6.

*    Continue only if no errors occurred. For instanceL if TABLE_EMPTY
*    exception was raised, this means that the infotype is not used
IF SY-SUBRC IS INITIAL.

*      Continue only if number of enteries greater than 0
CHECK NO_OF_ENTERIES > 0.

RECORD-PERIOD = SY-DATUM(6).
CLEAR RECORD-JOBNAME.
RECORD-TCODE = T582A_REC-INFTY.
RECORD-TYPE = 'I'. " I)nfotype
RECORD-USAGE = 1.
RECORD-USERS = 1.
MOVE-CORRESPONDING RECORD TO OUTREC.
APPEND OUTREC TO P_DATATAB.

ENDIF.

ENDLOOP.

ENDFORM.                    " read_infotype_statisctics

*---------------------------------------------------------------------*
*       FORM extract_software_components                              *
*---------------------------------------------------------------------*
FORM EXTRACT_SOFTWARE_COMPONENTS.

DATA: SC_ITAB TYPE TABLE OF CVERS,
UP_ITAB TYPE TABLE OF UVERS,
UVERS_HIST_ITAB TYPE TABLE OF UVERS_HIST_REC_TYPE,
AVERS_ITAB TYPE TABLE OF AVERS,
L_STARTTIME LIKE SY-UZEIT,
TAB_DATA TYPE TABLE OF TAB512,
*        ls_data LIKE LINE OF TAB_DATA,
SEL TYPE TABLE OF RFC_DB_OPT,
FIELDS_TAB TYPE TABLE OF RFC_DB_FLD.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting software components'.

PERFORM APPEND_STRING_TO_FILE USING '<SOFTWARE_COMPONENTS>'.
SELECT * FROM CVERS
INTO TABLE SC_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SC_ITAB
USING G_IREF_PDOCUMENT
'SOFTWARE_COMPONENT'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</SOFTWARE_COMPONENTS>'.

FREE SC_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '<PROD_SOFTWARE_COMPONENTS>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'CVERS'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of CVERS.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

SC_ITAB[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SC_ITAB
USING G_IREF_PDOCUMENT
'PROD_SOFTWARE_COMPONENT'.
FREE SC_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_SOFTWARE_COMPONENTS>'.

PERFORM APPEND_STRING_TO_FILE USING '<PROD_UPGRADES>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'UVERS'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of UVERS.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

UP_ITAB[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES UP_ITAB
USING G_IREF_PDOCUMENT
'PROD_UVERS'.
FREE UP_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_UPGRADES>'.

PERFORM APPEND_STRING_TO_FILE USING '<PROD_UPGRADES_HISTORY>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'UVERS_HIST'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of UVERS_HIST.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

UVERS_HIST_ITAB[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES UVERS_HIST_ITAB
USING G_IREF_PDOCUMENT
'PROD_UVERS_HIST'.
FREE UVERS_HIST_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_UPGRADES_HISTORY>'.

PERFORM APPEND_STRING_TO_FILE USING '<PROD_UPGRADES_ADDONS>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'AVERS'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of AVERS.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

AVERS_ITAB[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES AVERS_ITAB
USING G_IREF_PDOCUMENT
'PROD_AVERS'.
FREE AVERS_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_UPGRADES_ADDONS>'.

PERFORM ADD_TIME_STAT USING 'Extract software components' L_STARTTIME.


ENDFORM.                    "EXTRACT_SOFTWARE_COMPONENTS

*---------------------------------------------------------------------*
*       FORM extract_support_packages                                 *
*---------------------------------------------------------------------*
FORM EXTRACT_SUPPORT_PACKAGES.

TYPES: BEGIN OF TY_PAT03,
PATCH TYPE PATCH,
SHORT_TEXT TYPE PATCHTXT,
STATUS TYPE PATCHSTAT,
DELIV_DATE TYPE PATDELDATE,
DELIV_TIME TYPE PATDELTIME,
RESPONSIBL TYPE PATCH_USER,
IMPLE_DATE TYPE PATIMPDATE,
IMPLE_TIME TYPE PATIMPTIME,
L_IMPL_REL TYPE SYSAPRL,
CONFLICTS TYPE PAT_CONFL,
CONFIRMED TYPE CONFIRMED,
BACKUP TYPE TRKORR,
FROM_REL TYPE SYSAPRL,
TO_REL TYPE SYSAPRL,
OS TYPE SYOPSYS,
DB TYPE SYDBSYS,
PATCH_TYPE TYPE PATCH_TYPE,
ANCESTOR TYPE PAT_ANCEST,
STRICT_SEQ TYPE PAT_STRICT,
NO_GEN TYPE PAT_NOGEN,
SPAMFIX TYPE PAT_SPAMFX,
ADDON_ID TYPE ADDONID,
ADDON_REL TYPE ADDONRL,
IGN_CONFLI TYPE IGN_CONFLI,
AP_ANCEST TYPE AP_ANCEST,
EPSFILSIZ TYPE CHAR10,                      "int4
HI_ANCEST TYPE PAT_HIAN,
COMP_REL TYPE PAT_COREL,
COMPONENT TYPE PAT_COMP,
END OF TY_PAT03.

DATA: SP_ITAB TYPE TABLE OF PAT03,
L_STARTTIME LIKE SY-UZEIT,
TAB_DATA TYPE TABLE OF TAB512,
SEL TYPE TABLE OF RFC_DB_OPT,
FIELDS_TAB TYPE TABLE OF RFC_DB_FLD,
LT_RFC_PAT03 TYPE STANDARD TABLE OF TY_PAT03.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting support packages'.

PERFORM APPEND_STRING_TO_FILE USING '<SUPPORT_PACKAGES>'.

SELECT * FROM PAT03
INTO TABLE SP_ITAB PACKAGE SIZE PAC_SIZE.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SP_ITAB
USING G_IREF_PDOCUMENT
'SUPPORT_PACKAGE'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</SUPPORT_PACKAGES>'.

FREE SP_ITAB.

**Extract Prod SPs
PERFORM APPEND_STRING_TO_FILE USING '<PROD_SUPPORT_PACKAGES>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[].
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'PAT03'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of PAT03.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

LT_RFC_PAT03[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RFC_PAT03
USING G_IREF_PDOCUMENT
'PROD_SUPPORT_PACKAGE'.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_SUPPORT_PACKAGES>'.

FREE LT_RFC_PAT03.

PERFORM ADD_TIME_STAT USING 'Extract support packages' L_STARTTIME.

ENDFORM.                    "EXTRACT_SUPPORT_PACKAGES

*&---------------------------------------------------------------------*
*&      Form  add_ldb_includes
*&---------------------------------------------------------------------*
FORM ADD_LDB_INCLUDES USING LDB_NAME
NAMESPACE
LDP_PROG_NAME.

DATA: BEGIN OF INCLUDES OCCURS 50.
INCLUDE STRUCTURE RSEUINC.
DATA: END OF INCLUDES.
DATA: CURR_INCLUDE LIKE LINE OF INCLUDES.
DATA: SEL_INCLUDE LIKE TRDIR-NAME,
OBJ_NAME    LIKE RSEUI_SET-OBJ_NAME,
FLAG.

REFRESH INCLUDES.

SELECT * FROM D010INC
APPENDING CORRESPONDING FIELDS OF TABLE INCLUDES
WHERE MASTER = LDP_PROG_NAME.

IF SY-SUBRC <> 0.
SELECT * FROM RSEUINC
APPENDING CORRESPONDING FIELDS OF TABLE INCLUDES
WHERE MASTER = LDP_PROG_NAME.
ENDIF.

* Add selection screen include
CONCATENATE NAMESPACE 'DB' LDB_NAME 'SEL' INTO SEL_INCLUDE.
SELECT SINGLE NAME FROM TRDIR
INTO OBJ_NAME
WHERE NAME = SEL_INCLUDE.

IF SY-SUBRC IS INITIAL.
CURR_INCLUDE-MASTER  = LDP_PROG_NAME.
CURR_INCLUDE-INCLUDE = OBJ_NAME.
APPEND CURR_INCLUDE TO INCLUDES.
ENDIF.

SORT INCLUDES.
DELETE ADJACENT DUPLICATES FROM INCLUDES.

GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
LOOP AT INCLUDES.

*   Check if this is customer include. Only if yes - add it
PERFORM IS_CUSTOMER_DEV_INCLUDE USING INCLUDES-INCLUDE
CHANGING FLAG.

IF ( FLAG NE VANILLA ).
GS_OBJECTLIST-OBJ_NAME = INCLUDES-INCLUDE.
APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
ENDIF.
ENDLOOP.

ENDFORM.                    "add_ldb_objects

*&---------------------------------------------------------------------*
*&      Form  get_fugr_from_fugr_prog
*&---------------------------------------------------------------------*
* Given a function group program name, return the function group name
*----------------------------------------------------------------------*
FORM GET_FUGR_FROM_FUGR_PROG USING FUNCTION_GROUP_PROG
CHANGING FUNCTION_GROUP_NAME.

DATA: NAME LIKE RS38L-INCLUDE,
NAMESPACE LIKE RS38L-NAMESPACE,
FUGR_PROG_NAME LIKE  RS38L-INCLUDE.

FUGR_PROG_NAME = FUNCTION_GROUP_PROG.
CALL FUNCTION 'RS_NAME_SPLIT_NAMESPACE'
EXPORTING
NAME_WITH_NAMESPACE    = FUGR_PROG_NAME
IMPORTING
NAMESPACE              = NAMESPACE
NAME_WITHOUT_NAMESPACE = NAME
EXCEPTIONS
DELIMITER_ERROR        = 1
OTHERS                 = 2.
IF SY-SUBRC <> 0.
NAMESPACE = ''.
ENDIF.

IF NAME CP 'SAPL*'.
CONCATENATE NAMESPACE NAME+4 INTO FUNCTION_GROUP_NAME.
ELSE.
CONCATENATE NAMESPACE NAME INTO FUNCTION_GROUP_NAME.
ENDIF.

ENDFORM.                    "get_fugr_from_fugr_prog

*&---------------------------------------------------------------------*
*&      Form  is_customer_dev_include
*&---------------------------------------------------------------------*
* Check if the given include is a customer development
*(Z*, Y*, customer namespace *, function include 'LZ*';'LY*';'/NS/L*' ,
* LDB include 'DBZ*;'DBY*';'/NS/DB*' )
*----------------------------------------------------------------------*
FORM IS_CUSTOMER_DEV_INCLUDE USING VALUE(INCLUDE_NAME)
CHANGING FLAG TYPE BOOLEAN.

CLEAR FLAG.

DATA: NAME LIKE RS38L-INCLUDE,
NAMESPACE LIKE RS38L-NAMESPACE,
INC_NAME LIKE  RS38L-INCLUDE,
FIRST_CHAR TYPE C,
SECOND_CHAR TYPE C.

FIRST_CHAR = INCLUDE_NAME(1).
SECOND_CHAR = INCLUDE_NAME+1(1).

IF FIRST_CHAR = 'L'.
INCLUDE_NAME = INCLUDE_NAME+1.
ENDIF.

IF FIRST_CHAR = 'D' AND SECOND_CHAR = 'B'.
INCLUDE_NAME = INCLUDE_NAME+2.
ENDIF.

IF INCLUDE_NAME IN CUSTOMER_OBJECTS.
FLAG = 'X'.
ENDIF.

ENDFORM.                    "is_customer_dev_include

*&---------------------------------------------------------------------*
*&      Form  add_ldb_to_obj_list
*&---------------------------------------------------------------------*
*       Add LDB to object list
*----------------------------------------------------------------------*
*      -->LDB_NAME  LDB name
*      -->OBJ_REC   Object record
*----------------------------------------------------------------------*
FORM ADD_LDB_TO_OBJ_LIST  USING    LDB_NAME TYPE SOBJ_NAME
OBJ_REC TYPE RSEUI_SET.

DATA: CURR_NAMESPACE   LIKE LINE OF CUSTOMER_OBJECTS,
NAMESPACE        LIKE DD03L-PRECFIELD,
LLDB_NAME     TYPE SOBJ_NAME,
ASTERIX(1)       TYPE C,
NAMESPACE_LENGTH TYPE I.


* Find if there is customer namespace in the LDB name.
*  (no need to check in case of vanilla extraction)
CLEAR NAMESPACE.
LLDB_NAME = LDB_NAME.
IF VANILLA = ''.
LOOP AT CUSTOMER_OBJECTS INTO CURR_NAMESPACE.
IF CURR_NAMESPACE-LOW = 'Z*' OR
CURR_NAMESPACE-LOW = 'Y*'.
CONTINUE.
ENDIF.

IF LLDB_NAME CP CURR_NAMESPACE-LOW.

*       Get the namespace value
SPLIT CURR_NAMESPACE-LOW AT '*' INTO NAMESPACE ASTERIX.

*       Get the value of DB without the namespace
NAMESPACE_LENGTH = STRLEN( NAMESPACE ).

SHIFT LLDB_NAME BY NAMESPACE_LENGTH PLACES.
EXIT.
ENDIF.
ENDLOOP.
ENDIF.

* Add the program name to objects list
CONCATENATE NAMESPACE 'SAPDB' LLDB_NAME INTO OBJ_REC-OBJ_NAME.
OBJ_REC-OBJ_TYPE = 'PROG'.
APPEND OBJ_REC TO GT_OBJ_PROG.

* Add LDB includes
PERFORM ADD_LDB_INCLUDES USING LLDB_NAME
NAMESPACE
OBJ_REC-OBJ_NAME.

ENDFORM.                    " add_ldb_to_obj_list


*&---------------------------------------------------------------------*
*&      Form  CHECK_SOURCE_EXT_SUPPORT
*&---------------------------------------------------------------------*
*       Checks whether the function module RPY_PROGRAM_READ has a
*       parameter of SOURCE_EXTENDED
*----------------------------------------------------------------------*
*      <--P_LV_IS_WITH_SOUCE_EXT  Flag
*----------------------------------------------------------------------*
FORM CHECK_SOURCE_EXT_SUPPORT  CHANGING P_IS_WITH_SOUCE_EXT.
DATA:
LV_GLOBAL_FLAG        LIKE RS38L-GLOBAL,
LV_REMOTE_CALL        LIKE RS38L-REMOTE,
LV_UPDATE_TASK        LIKE RS38L-UTASK,
LV_SHORT_TEXT         LIKE TFTIT-STEXT,
LV_FUNCTION_POOL      LIKE RS38L-AREA,
LT_IMPORT_PARAMETER   TYPE TABLE OF RSIMP,
LT_CHANGING_PARAMETER TYPE TABLE OF RSCHA,
LT_EXPORT_PARAMETER   TYPE TABLE OF RSEXP,
LT_TABLES_PARAMETER   TYPE TABLE OF RSTBL,
LT_EXCEPTION_LIST     TYPE TABLE OF RSEXC,
LT_DOCUMENTATION      TYPE TABLE OF RSFDO,
LT_SOURCE             TYPE TABLE OF RSSOURCE WITH HEADER LINE,
RC                    LIKE  SY-SUBRC,
WA                    LIKE LINE OF LT_TABLES_PARAMETER.

CLEAR P_IS_WITH_SOUCE_EXT.
PERFORM READ_FUNCTION_MODULE_INTERFACE
TABLES
LT_IMPORT_PARAMETER
LT_CHANGING_PARAMETER
LT_EXPORT_PARAMETER
LT_TABLES_PARAMETER
LT_EXCEPTION_LIST
LT_DOCUMENTATION
LT_SOURCE
USING
'RPY_PROGRAM_READ'
CHANGING
LV_GLOBAL_FLAG
LV_REMOTE_CALL
LV_UPDATE_TASK
LV_SHORT_TEXT
LV_FUNCTION_POOL
RC.

READ TABLE LT_TABLES_PARAMETER WITH KEY PARAMETER = 'SOURCE_EXTENDED'
INTO WA.
IF SY-SUBRC IS INITIAL.
P_IS_WITH_SOUCE_EXT = 'X'.
ENDIF.

ENDFORM.                    " CHECK_SOURCE_EXT_SUPPORT
*&---------------------------------------------------------------------*
*&      Form  check_rfc_dest_existance
*&---------------------------------------------------------------------*
FORM CHECK_RFC_DEST_EXISTANCE .

DATA: RFC_ERROR TYPE RFCLOG_D,
ERR_MSG TYPE STRING,
AGR_USERS_ITAB TYPE TABLE OF AGR_USERS,
OPTIONS TYPE TABLE OF RFC_DB_OPT,
FIELDS TYPE TABLE OF RFC_DB_FLD,
TABLE_SIZE LIKE  SY-TFILL,
MSG1 TYPE RFCLOG_D,
MSG2 TYPE RFCLOG_D,
MSG3 TYPE RFCLOG_D,
MSG4 TYPE STRING,
SELECTED,
T000_ITAB TYPE TABLE OF T000,
T000_REC LIKE T000,
IS_PROD.

CALL FUNCTION 'RFC_READ_R3_DESTINATION'
EXPORTING
DESTINATION             = P_RFCDES
IMPORTING
CLIENT                  = RFC_MANDT
EXCEPTIONS
AUTHORITY_NOT_AVAILABLE = 1
DESTINATION_NOT_EXIST   = 2
INFORMATION_FAILURE     = 3
INTERNAL_FAILURE        = 4
OTHERS                  = 5.

IF SY-SUBRC <> 0.
CONCATENATE 'RFC destination' P_RFCDES
'does not exist or is not R/3 connection' INTO ERR_MSG
SEPARATED BY SPACE.                                   "#EC NOTEXT
MESSAGE E208(00) WITH ERR_MSG.
ENDIF.

* Check that the client in the RFC system is not '000'
IF RFC_MANDT = '000'.
CONCATENATE 'The client of the RFC destination' P_RFCDES
INTO MSG1 SEPARATED BY SPACE.
MSG2 = ' is 000. Please choose an RFC destination'.
MSG3 = ' with a different client number.'.
MESSAGE E000(CONV) WITH MSG1 MSG2 MSG3.
ENDIF.

CALL FUNCTION 'RFC_SYSTEM_INFO' DESTINATION P_RFCDES
EXCEPTIONS
SYSTEM_FAILURE        = 1  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE = 2  MESSAGE RFC_ERROR.

IF SY-SUBRC <> 0.
CONCATENATE 'Could not connect to RFC destination' P_RFCDES
INTO ERR_MSG
SEPARATED BY SPACE.                         "#EC NOTEXT
*    PERFORM display_message USING err_msg rfc_error '' show_error.
MESSAGE E208(00) WITH ERR_MSG RFC_ERROR.
LEAVE TO SCREEN SY-DYNNR.
ENDIF.

* -------------------------------------------------------------------
CALL FUNCTION 'PARTNER_LOGICAL_SYSTEM_GET' DESTINATION P_RFCDES
IMPORTING
P_LOGSYS = GV_LOGSYS
EXCEPTIONS
OWN_LOGICAL_SYSTEM_NOT_DEFINED = 1
SYSTEM_FAILURE                 = 2  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE          = 3  MESSAGE RFC_ERROR
OTHERS                         = 4.

IF SY-SUBRC = 2 OR SY-SUBRC = 3.
MSG1 = RFC_ERROR(50).
MSG2 = RFC_ERROR+50.
MESSAGE E000(CONV) WITH MSG1 MSG2.
ENDIF.


PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'AGR_USERS' P_RFCDES.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'EDIDC' P_RFCDES.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'EDP13' P_RFCDES.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'EDP21' P_RFCDES.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'SAPWLSERV' P_RFCDES.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'T582A' P_RFCDES.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'T000' P_RFCDES.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'V_USR_NAME' P_RFCDES.

PERFORM TEST_AUTH_READ_SOURCE
USING 'SAPLS38E' P_RFCDES ''.

CALL FUNCTION 'SAPWL_WORKLOAD_GET_STATISTIC' DESTINATION P_RFCDES
EXCEPTIONS
NO_DATA_FOUND         = 2
SYSTEM_FAILURE        = 3  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE = 4  MESSAGE RFC_ERROR
OTHERS                = 5.

IF SY-SUBRC = 3 OR SY-SUBRC = 4.
MSG1 = RFC_ERROR(50).
MSG2 = RFC_ERROR+50.
MESSAGE E000(CONV) WITH MSG1 MSG2.
ENDIF.

CALL FUNCTION 'SRTT_GET_TABLE_SIZE_RFC' DESTINATION P_RFCDES
EXPORTING
TABLE_NAME            = 'T001'
IMPORTING
TABLE_SIZE            = TABLE_SIZE
EXCEPTIONS
CLIENT_NOT_FOUND      = 1
TABLE_NOT_FOUND       = 2
TABLE_INKONSISTENT    = 3
PROTECTED             = 4
WRONG_TYPE            = 5
SYSTEM_FAILURE        = 6  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE = 7  MESSAGE RFC_ERROR
OTHERS                = 8.

IF SY-SUBRC = 6 OR SY-SUBRC = 7.
MSG1 = RFC_ERROR(50).
MSG2 = RFC_ERROR+50.
MESSAGE E000(CONV) WITH MSG1 MSG2.
ENDIF.

* Get the RFC system
CALL FUNCTION 'RFC_SYSTEM_INFO' DESTINATION P_RFCDES
IMPORTING
RFCSI_EXPORT = RFC_DATA.
RFC_SYSID = RFC_DATA-RFCSYSID.
RFC_SAPRL = RFC_DATA-RFCSAPRL.

PERFORM CHECK_AUTH_WORKLOAD_STATISTIC.

* Check that in table T000 of the system that the RFC points on
* there is a Prodution client except client 00
CLEAR IS_PROD.
IF DONT_SHOW_ERROR_ON_RFC IS INITIAL.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'T000'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = OPTIONS
FIELDS               = FIELDS
DATA                 = T000_ITAB
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC IS INITIAL AND
NOT T000_ITAB IS INITIAL.

*       Find a Client that is not 000 and its role is Production.
LOOP AT T000_ITAB INTO T000_REC WHERE
MANDT <> '000' AND CCCATEGORY = 'P'.
IS_PROD = 'X'.
ENDLOOP.

*       If no such Client was found - this is not Production system!
IF IS_PROD IS INITIAL.
CONCATENATE 'RFC destination' P_RFCDES
'does not point to ' INTO MSG1 SEPARATED BY SPACE.
MSG2 = ' Production system. Please choose another '.
MSG3 = ' RFC destination that points to Production.'.
MESSAGE E000(CONV) WITH MSG1 MSG2 MSG3.
ENDIF.
ELSE.
DATA: ERR(2) TYPE N.
ERR = SY-SUBRC.
MSG1 = 'Error when retreiving information on clients '.
CONCATENATE ' of RFC destination ' P_RFCDES '. RC: ' ERR
INTO MSG2 SEPARATED BY SPACE.
MESSAGE E000(CONV) WITH MSG1 MSG2 MSG3.
ENDIF.

*  Perform the following check only if Production client was not found.
IF IS_PROD IS INITIAL.

*   Check if the system id of the rfc is the same as current system id.
*     If yes - raise a warning
IF (  RFC_SYSID = SY-SYSID ).
CONCATENATE 'The system id of the RFC destination' RFC_SYSID
'is the ' INTO MSG1 SEPARATED BY SPACE.
MSG2 = ' same as the current system. Please make sure your RFC'.
MSG3 = 'destination points to the Production system.'.
*        MESSAGE I000(CONV) WITH MSG1 MSG2 MSG3.
CONCATENATE MSG1 MSG2 MSG3 INTO MSG4 SEPARATED BY SPACE.

CALL FUNCTION 'POPUP_TO_CONFIRM'
EXPORTING
TEXT_QUESTION         = MSG4
TEXT_BUTTON_1         = 'Continue'
TEXT_BUTTON_2         = 'Abort'
DEFAULT_BUTTON        = '2'
DISPLAY_CANCEL_BUTTON = ' '
IMPORTING
ANSWER                = SELECTED.
CASE SELECTED.
WHEN '1'.                  "Continue selected
WHEN '2'.                  "Abort selected
MSG1 = 'Program aborted. Please check you RFC destination.'.
MESSAGE E000(CONV) WITH MSG1.
ENDCASE.
ENDIF.
ENDIF.
ENDIF.

* -------------------------------------------------------------------

* To get a logon screen at the next 'normal' RFC call, it is required
* to close the connection opend by RFC_SYSTEM_INFO.
CALL FUNCTION 'RFC_CONNECTION_CLOSE'
EXPORTING
DESTINATION = P_RFCDES
EXCEPTIONS
OTHERS      = 1.

ENDFORM.                    " check_rfc_dest_existance

*&---------------------------------------------------------------------*
*&      Form  find_view_with_astrix
*&---------------------------------------------------------------------*
FORM FIND_VIEW_WITH_ASTRIX.

TYPES: BEGIN OF DD27S_INT_TYPE,
TABNAME LIKE DD27S-TABNAME,
END OF DD27S_INT_TYPE.
DATA: CURR_TAB LIKE LINE OF G_APP_STRUC,
VIEWS_TAB LIKE DD27S OCCURS 0,
VIEW_DATA LIKE DD27S,
PROCESS_VIEW TYPE C,
L_TABLES TYPE TABLE OF DD27S_INT_TYPE WITH HEADER LINE,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING
'Searching for SAP views with customer changes to its tables'.

* Check if there is a view that includes this table with *
* in fields field ( this means that all fields of current
* table should be included into the view )
IF NOT G_APP_STRUC[] IS INITIAL.
CLEAR L_TABLES. REFRESH L_TABLES.
LOOP AT G_APP_STRUC.
L_TABLES-TABNAME = G_APP_STRUC-LOW.
APPEND L_TABLES.
ENDLOOP.

IF NOT L_TABLES[] IS INITIAL.
SELECT *
FROM DD27S
INTO TABLE VIEWS_TAB
FOR ALL ENTRIES IN L_TABLES
WHERE TABNAME = L_TABLES-TABNAME AND
FIELDNAME = '*' AND
AS4LOCAL  = 'A'.
ENDIF.
ENDIF.
IF NOT G_INC_STRUC[] IS INITIAL.
CLEAR L_TABLES. REFRESH L_TABLES.
LOOP AT G_INC_STRUC.
L_TABLES-TABNAME = G_INC_STRUC-LOW.
APPEND L_TABLES.
ENDLOOP.

IF NOT L_TABLES[] IS INITIAL.
SELECT *
FROM DD27S
APPENDING TABLE VIEWS_TAB
FOR ALL ENTRIES IN L_TABLES
WHERE TABNAME = L_TABLES-TABNAME AND
FIELDNAME = '*' AND
AS4LOCAL  = 'A'.
ENDIF.
ENDIF.

SORT VIEWS_TAB BY VIEWNAME.

LOOP AT VIEWS_TAB INTO VIEW_DATA.
AT END OF VIEWNAME. PROCESS_VIEW = 'X'. ENDAT.

IF PROCESS_VIEW = 'X'.
CLEAR PROCESS_VIEW.

G_VIEW_WITH_AST-SIGN   = 'I'.
G_VIEW_WITH_AST-OPTION = 'EQ'.
G_VIEW_WITH_AST-LOW    = VIEW_DATA-VIEWNAME.
APPEND G_VIEW_WITH_AST.

ENDIF.
ENDLOOP.

PERFORM ADD_TIME_STAT USING 'Extract views with astrixes' L_STARTTIME.

ENDFORM.                    " find_view_with_astrix

*---------------------------------------------------------------------*
*       FORM EXTRACT_DEV_CLASSES                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_DEV_CLASSES.

DATA: TDEVC_ITAB TYPE TABLE OF TDEVC,
TDEVCT_ITAB TYPE TABLE OF TDEVCT,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting full dev. classes'.

SELECT * FROM TDEVC
INTO TABLE TDEVC_ITAB.

SELECT * FROM TDEVCT
INTO TABLE TDEVCT_ITAB.

PERFORM APPEND_STRING_TO_FILE USING '<DEV_CLASSES>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TDEVC_ITAB
USING G_IREF_PDOCUMENT
'TDEVC_FULL'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TDEVCT_ITAB
USING G_IREF_PDOCUMENT
'TDEVCT_FULL'.
PERFORM APPEND_STRING_TO_FILE USING '</DEV_CLASSES>'.

FREE TDEVC_ITAB.
FREE TDEVCT_ITAB.

PERFORM ADD_TIME_STAT USING 'Extract full dev. classes' L_STARTTIME.

ENDFORM.                    "EXTRACT_DEV_CLASSES

*---------------------------------------------------------------------*
*       FORM EXTRACT_FUGR_INCLUDES_STATUS                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_FUGR_INCLUDES_STATUS.

DATA: D010SINF_ITAB TYPE TABLE OF D010SINF,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting fugr inc. status (DEBUG)'.

PERFORM APPEND_STRING_TO_FILE USING '<FUGR_INCLUDES_DEBUG>'.
SELECT * FROM D010SINF
INTO TABLE D010SINF_ITAB PACKAGE SIZE PAC_SIZE
WHERE PROG LIKE 'LZ%'
OR    PROG LIKE 'LY%'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES D010SINF_ITAB
USING G_IREF_PDOCUMENT
'D010SINF'.
ENDSELECT.
PERFORM APPEND_STRING_TO_FILE USING '</FUGR_INCLUDES_DEBUG>'.

FREE D010SINF_ITAB.

PERFORM ADD_TIME_STAT USING 'Extract fugr inc. status' L_STARTTIME.

ENDFORM.                    "EXTRACT_FUGR_INCLUDES_STATUS

*---------------------------------------------------------------------*
*       FORM EXTRACT_FORMS                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_FORMS.

DATA: LT_STXFADM  TYPE TABLE OF STXFADM,
LT_STXFADMT  TYPE TABLE OF STXFADMT,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_FORMNAME FOR STXFADM-FORMNAME.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting forms'.

LOOP AT GT_OBJ_SSFO INTO GS_OBJECTLIST.
CLEAR R_FORMNAME.
R_FORMNAME-SIGN   = 'I'.
R_FORMNAME-OPTION = 'EQ'.
R_FORMNAME-LOW    = GS_OBJECTLIST-OBJ_NAME.
APPEND R_FORMNAME.
ENDLOOP.
FREE GT_OBJ_SSFO.

PERFORM APPEND_STRING_TO_FILE USING '<FORMS>'.

* Get header data of smart forms
PERFORM APPEND_STRING_TO_FILE USING '<SMART_FORMS>'.

IF NOT R_FORMNAME[] IS INITIAL.
SELECT * FROM STXFADM
INTO TABLE LT_STXFADM PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_FORMNAME
WHERE  FORMNAME = R_FORMNAME-LOW.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STXFADM
USING G_IREF_PDOCUMENT
'SMART_FORM'.
ENDSELECT.

SELECT * FROM STXFADMT
INTO TABLE LT_STXFADMT PACKAGE SIZE PAC_SIZE
FOR ALL ENTRIES IN R_FORMNAME
WHERE  FORMNAME = R_FORMNAME-LOW.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STXFADMT
USING G_IREF_PDOCUMENT
'SMART_FORM_TEXT'.
ENDSELECT.
ENDIF.
PERFORM APPEND_STRING_TO_FILE USING '</SMART_FORMS>'.
FREE LT_STXFADM.

PERFORM APPEND_STRING_TO_FILE USING '</FORMS>'.

PERFORM ADD_TIME_STAT USING 'Extract forms' L_STARTTIME.

ENDFORM.                    "EXTRACT_FORMS

*---------------------------------------------------------------------*
*       FORM EXTRACT_USERS_DATA                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM EXTRACT_USERS_DATA.

DATA: P_TABNAME LIKE DD02L-TABNAME,
ITAB TYPE TABLE OF V_USR_NAME,
OPTIONS TYPE TABLE OF RFC_DB_OPT,
FIELDS TYPE TABLE OF RFC_DB_FLD,
ERROR TYPE STRING.

IF EXTRACT_USER_DATA = 'X'.

CHECK VANILLA =''.

PERFORM APPEND_STRING_TO_FILE USING '<USERS_DATA>'.

P_TABNAME = 'V_USR_NAME'.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE           = P_TABNAME
DELIMITER             = SPACE
NO_DATA               = SPACE
ROWSKIPS              = 0
ROWCOUNT              = 0
TABLES
OPTIONS               = OPTIONS
FIELDS                = FIELDS
DATA                  = ITAB
EXCEPTIONS
TABLE_NOT_AVAILABLE   = 1
TABLE_WITHOUT_DATA    = 2
OPTION_NOT_VALID      = 3
FIELD_NOT_VALID       = 4
NOT_AUTHORIZED        = 5
DATA_BUFFER_EXCEEDED  = 6
SYSTEM_FAILURE        = 7
COMMUNICATION_FAILURE = 8
OTHERS                = 9.


IF SY-SUBRC IS INITIAL AND NOT ITAB IS INITIAL.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES ITAB
USING G_IREF_PDOCUMENT
'USER_DETAILS'.

ELSE.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extraction of V_USR_NAME from ' P_RFCDES
' failed. Error: ' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '</USERS_DATA>'.

ENDIF.

ENDFORM.                    "EXTRACT_USERS_DATA

*---------------------------------------------------------------------*
*       FORM INIT                                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM INIT.
DATA: SYSUBRC_CHAR(02) TYPE N.

* Set the package size for data selections.

* In foreground mode, the size is set very high so that each
* select..end select will fetch all the records once - this is
* because writing to file (locally) during select..end select
* closes the DB cursor
IF NOT R_FORE IS INITIAL.
PAC_SIZE = 10000000.
ELSE.
* In background mode, the selection will fetch pac_size records
* in each round trip
PAC_SIZE = 10000.
ENDIF.

* Set the start time
STARTTIME = SY-UZEIT.

IF NOT SHOW_SERVERS_NAME IS INITIAL.
*   Get the production system landscape
PERFORM GET_RFC_SERVER_LIST CHANGING SYSUBRC_CHAR.
ENDIF.

ENDFORM.                    "INIT

*---------------------------------------------------------------------*
*       FORM GET_RFC_SERVER_LIST                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM GET_RFC_SERVER_LIST CHANGING P_SYSUBRC_CHAR TYPE N.

DATA: LT_MSXXLIST_46 TYPE MSXXLIST_46_TAB_TYPE,
LS_MSXXLIST_46 LIKE LINE OF LT_MSXXLIST_46,
LS_SERVER TYPE MSXXLIST.

* The server name and host were lengthened in struct msxxlist in
* versions higer than 4.6C. So if the RFC system is 4.6C, the data needs
* to be converted from the old struct to the new one.
IF RFC_SAPRL = SAPRL_46C.

*   Get the production system landscape into the old struct
CALL FUNCTION 'TH_SERVER_LIST' DESTINATION P_RFCDES
TABLES
LIST           = LT_MSXXLIST_46
EXCEPTIONS
NO_SERVER_LIST = 1
OTHERS         = 2.

IF SY-SUBRC <> 0.
P_SYSUBRC_CHAR = SY-SUBRC.
CONCATENATE 'Did not get list of servers from RFC destination '
' exception ' P_SYSUBRC_CHAR INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

CLEAR SERVERS[].

*   Move into the new struct.
LOOP AT LT_MSXXLIST_46 INTO LS_MSXXLIST_46.
MOVE-CORRESPONDING LS_MSXXLIST_46 TO LS_SERVER.
APPEND LS_SERVER TO SERVERS.
ENDLOOP.

ELSE.

*   Get the production system landscape without struct conversion
CALL FUNCTION 'TH_SERVER_LIST' DESTINATION P_RFCDES
TABLES
LIST           = SERVERS
EXCEPTIONS
NO_SERVER_LIST = 1
OTHERS         = 2.

IF SY-SUBRC <> 0.
P_SYSUBRC_CHAR = SY-SUBRC.
CONCATENATE 'Did not get list of servers from RFC destination '
' exception ' P_SYSUBRC_CHAR INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

ENDIF.

ENDFORM.                    "GET_RFC_SERVER_LIST

*---------------------------------------------------------------------*
*       FORM INIT_THIRD_PARTY_RANGE                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM INIT_THIRD_PARTY_RANGE.

CLEAR THIRD_PARTY_NS.
THIRD_PARTY_NS-SIGN = 'I'.
THIRD_PARTY_NS-OPTION = 'EQ'.

* Fill all the known third party namespaces

THIRD_PARTY_NS-LOW = '/AEB/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/ALOGIS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/APPLICON/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/ARINSO/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/BEE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/BETASYS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/BGADDON/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/BKC/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/BMC/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/BMCCTRLM/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/BMCCTRLS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CAUNI/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIDEON/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIRRUS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVBB/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVBL/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVBR/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVBS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVHF/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVIN/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVKD/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVMD/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CIVWD/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/COCKPIT/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/CWLD/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/DSN/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/DVSREPRO/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/EHR/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/EPIUSE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/ERPSOLUT/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/IBBJ/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/IBMMON/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/INPUNCTO/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/IRM/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/IRMGLB/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/IRMIPM/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/IXOS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/KCP/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/KERN/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/KINTANA/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/LUMINATE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/MRSS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/NEXTEVO/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/ODT9/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PANAYA/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PATROL/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PBS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PDO/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PEC/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PRECISE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PSI/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PSIIC/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/PSYNG/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/REALTIME/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/ROMANIA/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/RSC/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/RTC/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/RWD/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/SBB/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/SEAL/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/SER/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/SIE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/SPMEAT/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/SUNW/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/SYSLINK/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/TCX/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/TECCOM/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/THE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/USE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/WSW/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/WSWAEB/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/WSWBASE/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/WSWERP/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/WSWERPA/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/WSWGTS/'. APPEND THIRD_PARTY_NS.
THIRD_PARTY_NS-LOW = '/YAMBS/'. APPEND THIRD_PARTY_NS.

ENDFORM.                    "INIT_THIRD_PARTY_RANGE

*---------------------------------------------------------------------*
*       FORM TEST_AUTH_READ_SOURCE                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_TABNAME                                                     *
*---------------------------------------------------------------------*
FORM TEST_AUTH_READ_SOURCE USING P_SOURCE_NAME TYPE PROGNAME
P_RFC_DEST TYPE RFCDEST
P_SHOW_NAME_IN_MSG.
* 'NONE'

DATA: LT_SOURCE TYPE TABLE OF ABAPSOURCE WITH HEADER LINE,
LT_SOURCE_EXT TYPE TABLE OF ABAPTXT255 WITH HEADER LINE,
RFC_ERROR TYPE RFCLOG_D,
MSG1 TYPE RFCLOG_D,
MSG2 TYPE RFCLOG_D.

CALL FUNCTION 'RPY_PROGRAM_READ' DESTINATION P_RFC_DEST
EXPORTING
LANGUAGE              = 'E'
PROGRAM_NAME          = P_SOURCE_NAME
ONLY_SOURCE           = 'X'
TABLES
SOURCE                = LT_SOURCE
SOURCE_EXTENDED       = LT_SOURCE_EXT
EXCEPTIONS
CANCELLED             = 1
NOT_FOUND             = 2
PERMISSION_ERROR      = 3
SYSTEM_FAILURE        = 4  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE = 5  MESSAGE RFC_ERROR
OTHERS                = 6.

* An authorization error
IF SY-SUBRC = 3.
IF NOT P_SHOW_NAME_IN_MSG IS INITIAL.
CONCATENATE 'The user has no authorizations reading source '
P_SOURCE_NAME
INTO MSG1 SEPARATED BY SPACE.
ELSE.
MSG1 = 'The user has no authorizations reading source'.
ENDIF.

IF P_RFC_DEST = 'NONE'.
MSG2 = ' in your current system.'.
ELSE.
CONCATENATE ' in system ' P_RFC_DEST '.'
INTO MSG2 SEPARATED BY SPACE.
ENDIF.

MESSAGE E000(CONV) WITH MSG1 MSG2.

* An RFC error
ELSEIF SY-SUBRC = 4 OR SY-SUBRC = 5.
MSG1 = RFC_ERROR(50).
MSG2 = RFC_ERROR+50.
MESSAGE E000(CONV) WITH MSG1 MSG2.

* Other problems reading the source
ELSEIF NOT SY-SUBRC IS INITIAL.
IF NOT P_SHOW_NAME_IN_MSG IS INITIAL.
CONCATENATE 'There is a problem reading source ' P_SOURCE_NAME
INTO MSG1 SEPARATED BY SPACE.
ELSE.
MSG1 = 'There is a problem reading source'.
ENDIF.

IF P_RFC_DEST = 'NONE'.
MSG2 = ' in your current system.'.
ELSE.
CONCATENATE ' in system ' P_RFC_DEST '.'
INTO MSG2 SEPARATED BY SPACE.
ENDIF.

MESSAGE E000(CONV) WITH MSG1 MSG2.
ENDIF.

ENDFORM.                    "TEST_AUTH_READ_SOURCE

*---------------------------------------------------------------------*
*       FORM ADD_TIME_STAT                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_STEP                                                        *
*  -->  P_STARTTIME                                                   *
*---------------------------------------------------------------------*
FORM ADD_TIME_STAT USING P_STEP P_STARTTIME.
*----------------------------------------------------------------------*
* Begin change 13 made on 01/05/2013                                   *
*----------------------------------------------------------------------*
DATA: SUBRC TYPE I,
TABIX TYPE I.
* Check if there is already an entry in the time stat
READ TABLE GT_ETL_TIME_STAT WITH KEY STEP = P_STEP.
SUBRC = SY-SUBRC.
TABIX = SY-TABIX.

GT_ETL_TIME_STAT-ENDTIME = SY-UZEIT.
GT_ETL_TIME_STAT-ENDDATE = SY-DATUM.

IF SUBRC IS INITIAL.
MODIFY GT_ETL_TIME_STAT INDEX TABIX.
ELSE.
GT_ETL_TIME_STAT-STEP = P_STEP.
GT_ETL_TIME_STAT-STARTTIME = P_STARTTIME.
GT_ETL_TIME_STAT-STARTDATE = SY-DATUM.
APPEND GT_ETL_TIME_STAT.
ENDIF.
*----------------------------------------------------------------------*
* End change 13 made on 01/05/2013                                     *
*----------------------------------------------------------------------*
ENDFORM.                    "ADD_TIME_STAT

*---------------------------------------------------------------------*
*       FORM CREATE_POPUP_TEXT                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_QUESTION                                                    *
*---------------------------------------------------------------------*
FORM CREATE_POPUP_TEXT CHANGING P_QUESTION.

DATA:
DIAG_TEXT1 TYPE STRING,
DIAG_TEXT2 TYPE STRING,
DIAG_TEXT3 TYPE STRING,
TEXT_LINE1 TYPE STRING,
ANSWER(1)  TYPE C.

DIAG_TEXT1 = 'You are about to extract the following:'.

CONCATENATE 'Technical objects from SAP system - ' SY-SYSID
'(' SY-MANDT ')' INTO DIAG_TEXT2 SEPARATED BY SPACE.

CONCATENATE 'Usage statistics from SAP system - '
RFC_DATA-RFCSYSID '(' RFC_MANDT ')'
INTO DIAG_TEXT3 SEPARATED BY SPACE.

TEXT_LINE1 = 'Do you wish to proceed?'.


IF USAGEONL IS INITIAL.
CONCATENATE DIAG_TEXT1 DIAG_TEXT2 DIAG_TEXT3 TEXT_LINE1
INTO QUESTION SEPARATED BY SPACE.
ELSE.
CONCATENATE DIAG_TEXT1 DIAG_TEXT3 TEXT_LINE1
INTO QUESTION SEPARATED BY SPACE.
ENDIF.

ENDFORM.                     " CREATE_POPUP_TEXT

*---------------------------------------------------------------------*
*       FORM BUILD_LOCAL_FILE_NAME                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_FILEN                                                       *
*  -->  P_PATH                                                        *
*  -->  P_FULLPATH                                                    *
*---------------------------------------------------------------------*
FORM BUILD_LOCAL_FILE_NAME USING
P_FILEN
CHANGING P_PATH
P_FULLPATH.
DATA:
LAST_CHAR TYPE I.
*  Check if the user enterde a directory with '\' at the end
LAST_CHAR = STRLEN( P_PATH ).
LAST_CHAR = LAST_CHAR - 1.


IF P_PATH+LAST_CHAR = '\'.
CONCATENATE P_PATH DEFAULT_FILENAME INTO P_FULLPATH.
ELSE.
CONCATENATE P_PATH '\' INTO P_PATH.
CONCATENATE P_PATH DEFAULT_FILENAME
INTO P_FULLPATH.
ENDIF.

ENDFORM.                     "BUILD_LOCAL_FILE_NAME

*---------------------------------------------------------------------*
*       FORM CORRECT_SERVER_PATH                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_PATH                                                        *
*---------------------------------------------------------------------*
FORM CORRECT_SERVER_PATH CHANGING P_PATH.
DATA:
FILE_SEPARATOR TYPE C,
LAST_CHAR TYPE I.

IF NOT P_PATH IS INITIAL.

LAST_CHAR = STRLEN( P_PATH ).
LAST_CHAR = LAST_CHAR - 1.

SEARCH P_PATH FOR '/'.
IF SY-SUBRC IS INITIAL.
FILE_SEPARATOR = '/'.
ELSE.
FILE_SEPARATOR = '\'.
ENDIF.

IF P_PATH+LAST_CHAR NE FILE_SEPARATOR.
CONCATENATE P_PATH FILE_SEPARATOR INTO P_PATH.
ENDIF.
ENDIF.

ENDFORM.                      "CORRECT_SERVER_PATH

*---------------------------------------------------------------------*
*       FORM GET_LAST_CHAR                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_DIRECTORY                                                   *
*  -->  P_LAST_CHAR                                                   *
*---------------------------------------------------------------------*
FORM GET_LAST_CHAR USING P_DIRECTORY
P_LAST_CHAR.
DATA:
ERROR_MSG TYPE STRING,
LAST_CHAR_PLACE TYPE I.
*       Check if the user entered a directory at all
IF NOT P_DIRECTORY IS INITIAL.
*         Check if the user entered a directory with '\' at the end
LAST_CHAR_PLACE = STRLEN( P_DIRECTORY ).
LAST_CHAR_PLACE = LAST_CHAR_PLACE - 1.
P_LAST_CHAR = P_DIRECTORY+LAST_CHAR_PLACE.
ELSE.
CLEAR P_LAST_CHAR.
ENDIF.
ENDFORM.                    "GET_LAST_CHAR

*---------------------------------------------------------------------*
*       FORM GET_KERNEL_DATA                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  EV_KRELEASE                                                   *
*  -->  EV_KLEVEL                                                     *
*---------------------------------------------------------------------*
FORM GET_KERNEL_DATA CHANGING EV_KRELEASE
EV_KLEVEL.

TYPES: BEGIN OF T_KERNEL_VERSION,
KEY(21) TYPE C,
DATA(69) TYPE C,
END OF T_KERNEL_VERSION.

DATA: LT_KERNEL_VERSION TYPE TABLE OF T_KERNEL_VERSION
WITH HEADER LINE,
LS_KERNEL_VERSION TYPE T_KERNEL_VERSION.

CALL 'SAPCORE' ID 'ID' FIELD 'VERSION'
ID 'TABLE' FIELD LT_KERNEL_VERSION-*SYS*.

READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 12.
EV_KRELEASE = LS_KERNEL_VERSION-DATA.
READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 15.
EV_KLEVEL = LS_KERNEL_VERSION-DATA.

ENDFORM.                    "GET_KERNEL_DATA
*&---------------------------------------------------------------------*
*&      Form  add_rfcs_list
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM ADD_RFCS_LIST.

DATA: LT_RFC_LIST_NODE TYPE XML_ELEMENT.

IF NOT GT_RFCS[] IS INITIAL.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'RFC_LIST'
CHANGING LT_RFC_LIST_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES GT_RFCS
USING G_IREF_PDOCUMENT
LT_RFC_LIST_NODE
'RFC'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LT_RFC_LIST_NODE 'X'.
FREE GT_RFCS.
ENDIF.

ENDFORM.                    " add_rfcs_list
*&---------------------------------------------------------------------*
*&      Form  extract_system_parameters
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_SYSTEM_PARAMETERS .
TYPES: BEGIN OF TY_SYSTEM_PARAMETER,
PARAMETER_NAME TYPE TPFET-PARNAME,
PARAMETER_VALUE TYPE TPFET-PVALUE,
END OF TY_SYSTEM_PARAMETER.

DATA : LT_SYS_PARAMS      TYPE STANDARD TABLE OF TY_SYSTEM_PARAMETER,
LS_SYS_PARAMS      LIKE LINE OF LT_SYS_PARAMS,
LT_SYS_PARAMS_OUT  TYPE STANDARD TABLE OF TY_SYSTEM_PARAMETER.
DATA : LV_SYS_PARAMS_NODE TYPE XML_ELEMENT.

* Set RZ11 / RZ10 system parameters names to be extracted
LS_SYS_PARAMS-PARAMETER_NAME = 'auth/tcodes_not_checked'.
APPEND LS_SYS_PARAMS TO LT_SYS_PARAMS.

* Get parameters values
LOOP AT LT_SYS_PARAMS INTO LS_SYS_PARAMS.
*   Get system parameter value
CALL 'C_SAPGPARAM' ID 'NAME'  FIELD LS_SYS_PARAMS-PARAMETER_NAME
ID 'VALUE' FIELD LS_SYS_PARAMS-PARAMETER_VALUE.

IF SY-SUBRC = 0.
APPEND LS_SYS_PARAMS TO LT_SYS_PARAMS_OUT.
ENDIF.
ENDLOOP.

* Set parameters data to ETL file
IF NOT LT_SYS_PARAMS_OUT[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'SYSTEM_PARAMETERS'
CHANGING LV_SYS_PARAMS_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_SYS_PARAMS_OUT
USING G_IREF_PDOCUMENT
LV_SYS_PARAMS_NODE
'SYSTEM_PARAMETER'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_SYS_PARAMS_NODE 'X'.
ENDIF.
ENDFORM.                    " extract_system_parameters
*&---------------------------------------------------------------------*
*&      Form  get_sm_data
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM GET_SM_DATA .

DATA : LT_TAB512 TYPE STANDARD TABLE OF TAB512,
LV_FAILED TYPE FLAG,
LV_STRING TYPE STRING.
DATA : LV_SM_DATA_NODE TYPE XML_ELEMENT,
LV_SM_SYSTEM_NODE TYPE XML_ELEMENT.
* Solution manager data
DATA : LT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T,
LT_SMSY_SYSTEM_SAP TYPE SMSY_SYSTEM_SAP_T,
LT_SMSY_SYST_CLIENT TYPE SMSY_SYST_CLIENT_T,
LT_SMSY_SYS_RELINST_FINAL TYPE SMSY_SYS_RELINST_T,
LT_SMSY_MAIN_INST_FINAL TYPE SMSY_MAIN_INST_SYST_T,
LT_SMSYPROCOM_FINAL TYPE SMSYPROCOM_T,
LT_PAT03_FINAL TYPE TY_SYST_PAT03_OUT_T,
LT_AISYSNR_BUFFER TYPE AISYSNR_BUFFER_T,
LT_SMSY_PROD_VERS TYPE SMSY_PROD_VERS_T,
LT_SMSY_PRODUCT TYPE SMSY_PRODUCT_T,
LT_SM_SYSTEM_PRODUCTS TYPE SM_SYSTEM_PRODUCTS_T.

* The SM rfc was entered and validated in selection screen
IF NOT P_SM_RFC IS INITIAL.

PERFORM READ_SOLMAN_FUNCTIONS TABLES LT_TAB512
USING  P_SM_RFC
ABAP_TRUE
CHANGING LV_FAILED.
IF NOT LV_FAILED IS INITIAL.
EXIT.
ENDIF.

*   Get all systems , sap_systems , system_clients
READ TABLE LT_TAB512 WITH KEY WA =
'SMSY_GET_ALL_SYSTEMS_INFO'
TRANSPORTING NO FIELDS.

IF SY-SUBRC IS INITIAL.

PERFORM READ_SMSY_SYSTEMS
USING  P_SM_RFC
CHANGING LV_FAILED
LT_SMSY_SYSTEM
LT_SMSY_SYSTEM_SAP
LT_SMSY_SYST_CLIENT.

IF LT_SMSY_SYSTEM[] IS INITIAL.
*       Message no systems extracted from Solution manager
CONCATENATE 'SM No systems are defined in'
P_SM_RFC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
LV_FAILED = ABAP_TRUE.
ENDIF.
ELSE.
"Message - function doesnt exist in SM
CONCATENATE
'SM Function SMSY_GET_ALL_SYSTEMS_INFO does not exist in'
P_SM_RFC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
LV_FAILED = ABAP_TRUE.
ENDIF.

IF LV_FAILED IS INITIAL.
*     SMSY functions exist in SM - extract SMSY data
*     Create a child node for the sm_data node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'SM_DATA'
CHANGING LV_SM_DATA_NODE.
PERFORM APPEND_STRING_TO_FILE USING '<SM_DATA>'.

*     Open current SM system xml tag
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT LV_SM_DATA_NODE
'SM_SYSTEM'
CHANGING LV_SM_SYSTEM_NODE.
CONCATENATE '<SM_SYSTEM RFC_DEST="' P_SM_RFC '">'
INTO LV_STRING.
PERFORM APPEND_STRING_TO_FILE USING LV_STRING.
CLEAR : LV_STRING.
ELSE.
*     Do not continue unable to read SM Systems data
EXIT.
ENDIF.

*   SM systems extracted - Get system leading product
READ TABLE LT_TAB512 WITH KEY WA =
'SMSY_GET_RELINST_TO_SYSTEM_RFC' TRANSPORTING NO FIELDS.
IF SY-SUBRC IS INITIAL AND
NOT LT_SMSY_SYSTEM[] IS INITIAL.

PERFORM GET_SYSTEM_LEADING_PRODUCTS
USING  P_SM_RFC
LT_SMSY_SYSTEM
CHANGING LT_SMSY_SYS_RELINST_FINAL.
ELSE.
*     Message - function doesnt exist in SM
CONCATENATE
'SM Function SMSY_GET_RELINST_TO_SYSTEM_RFC'
'does not exist in'
P_SM_RFC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

*   Get all system installed product instances
READ TABLE LT_TAB512 WITH KEY WA =
'SMSY_GET_INST_OF_PRODUCT_RFC' TRANSPORTING NO FIELDS.
IF SY-SUBRC IS INITIAL AND
NOT LT_SMSY_SYS_RELINST_FINAL[] IS INITIAL.

PERFORM READ_SYSTEM_PRODUCTS_INSTANCES
USING  P_SM_RFC
LT_SMSY_SYS_RELINST_FINAL
CHANGING LT_SMSY_MAIN_INST_FINAL.
ELSE.
*     Message - function doesnt exist in SM
CONCATENATE
'SM Function SMSY_GET_INST_OF_PRODUCT_RFC'
'does not exist in'
P_SM_RFC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

*   Get all systems components / release / patchlevel
READ TABLE LT_TAB512 WITH KEY WA = 'SMSY_GET_CVERS_INFO_RFC'
TRANSPORTING NO FIELDS.
IF SY-SUBRC IS INITIAL AND
NOT LT_SMSY_SYSTEM[] IS INITIAL.

PERFORM READ_SYSTEM_COMPONENTS
USING P_SM_RFC
LT_SMSY_SYSTEM
CHANGING LT_SMSYPROCOM_FINAL.
ELSE.
*     Message - function doesnt exist in SM
CONCATENATE
'SM Function SMSY_GET_CVERS_INFO_RFC'
'does not exist in'
P_SM_RFC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.


*   RFC_READ_TABLE data access
*   Get SMSY OSS system data - table AISYSNR_BUFFER
PERFORM READ_SYSTEM_OSS_DATA
USING  P_SM_RFC
CHANGING LT_AISYSNR_BUFFER.

*   Get SMSY product and product version system data
*   tables : SMSY_PRODUCT , SMSY_PROD_VERS
*   the data of system product version is
*   fetched in the systems call
*   if not use table SMSY_SYST_PRODVR
PERFORM READ_PRODUCTS
USING P_SM_RFC
LT_SMSY_SYSTEM
LT_AISYSNR_BUFFER
CHANGING LT_SMSY_PROD_VERS
LT_SMSY_PRODUCT
LT_SM_SYSTEM_PRODUCTS.

*   Append SM system data to output file
PERFORM ADD_SM_DATA_TO_XML
USING LV_SM_SYSTEM_NODE
LT_SMSY_SYSTEM
LT_SMSY_SYSTEM_SAP
LT_SMSY_SYST_CLIENT
LT_SM_SYSTEM_PRODUCTS
LT_SMSY_MAIN_INST_FINAL
LT_SMSYPROCOM_FINAL
LT_PAT03_FINAL
LT_AISYSNR_BUFFER.

*   Close current SM system data segment
PERFORM APPEND_STRING_TO_FILE USING '</SM_SYSTEM>'.
CLEAR : LS_RFCDES.

*   Append closing XML tag for SM data segment
PERFORM APPEND_STRING_TO_FILE USING '</SM_DATA>'.

*   Release SM data global tables - memory consumption
FREE : LT_SMSY_SYSTEM,
LT_SMSY_SYSTEM_SAP,
LT_SMSY_SYST_CLIENT,
LT_SM_SYSTEM_PRODUCTS,
LT_SMSY_MAIN_INST_FINAL,
LT_SMSYPROCOM_FINAL,
LT_PAT03_FINAL,
LT_AISYSNR_BUFFER.
ENDIF.

ENDFORM.                    " get_sm_data
*&---------------------------------------------------------------------*
*&      Form  get_solar_raw_data
*&---------------------------------------------------------------------*
*       Get the data for the business process projects
*----------------------------------------------------------------------*
FORM GET_SOLAR_RAW_DATA.

DATA:
SEL           TYPE TABLE OF RFC_DB_OPT,
SEL_WA        TYPE RFC_DB_OPT,
FIELDS        TYPE TABLE OF RFC_DB_FLD,
TPROJECT_TAB  TYPE TABLE OF SM_PROJECT_TYPE,
TPROJECT_WA   TYPE SM_PROJECT_TYPE,
TOBJECTP_TAB  TYPE TABLE OF TOBJECTP,
TOBJECT_WA    TYPE TOBJECTP,
TOBJECT       TYPE TOBJECTP,
TBOM_HEADER_TAB TYPE SM_AGS_TBOM_HEAD_TAB,
TBOM_HEADER_WA  TYPE SM_AGS_TBOM_HEAD,
TMP_BASE_TAB  TYPE TABLE OF SM_AGS_TBOM_BASE,
TBOM_BASE_TAB TYPE TABLE OF SM_AGS_TBOM_BASE,
TBOM_BASE_WA  TYPE SM_AGS_TBOM_BASE,
LS_FIELDS     LIKE LINE OF FIELDS,
STR_UZEIT     TYPE STRING,
IS_FIRST      TYPE C VALUE 'X',
MODIFY_TABIX  LIKE SY-TABIX.

DATA:
MESSAGE        TYPE  HIER_MESS,
HANDLES_TAB    TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
SOLAR_PROJECTS_NODE  TYPE XML_ELEMENT,
SOLAR_PROJECTS_TYPE TYPE XML_ELEMENT,
SOLAR_PROJ_NODE_TEXT  TYPE XML_ELEMENT,
BMTNODES       TYPE XML_ELEMENT,
SOLAR_TRANSACTIONS_NODE TYPE XML_ELEMENT,
SOLAR_URLS_NODE     TYPE XML_ELEMENT.

DATA:
ALL_NODES TYPE TABLE OF SM_PROJECT_TREE_NODE,
ALL_NODES_WA LIKE LINE OF ALL_NODES,
NODES     TYPE TABLE OF HIER_IFACE,
NODE_WA   LIKE LINE OF NODES,
ALL_TEXTS TYPE TABLE OF HIER_TEXTS,
TEXTS     TYPE TABLE OF HIER_TEXTS.

DATA:
BMT_TREE_REF TYPE TABLE OF BMTNODE01R,
TMP_BMT_REFS TYPE TABLE OF BMTNODE01R,
RES_BMTNODE_R TYPE TABLE OF BMTNODE01R,
RES_DFURLS TYPE TABLE OF SM_DFURLS,
DFURLS     TYPE TABLE OF SM_DFURLS,
BMT_TREE   TYPE TABLE OF SM_PROJECT_TREE,
COUNTER    TYPE I VALUE 0.

CHECK EXTRACT_SOLAR_DATA = 'X' AND NOT P_SM_RFC IS INITIAL.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING
'Extracting Solution Manager Projects'.

*------------------------------------------------------------------
PERFORM APPEND_STRING_TO_FILE USING '<SOLAR_DATA>'.

* Create a child node for the Project node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'SOLAR_PROJECTS'
CHANGING SOLAR_PROJECTS_TYPE.

CONCATENATE 'SOLAR:1.Getting SOLAR Projects'
'from tables TPROJECT and TOBJECTP'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

LS_FIELDS-FIELDNAME = 'PROJECT_ID'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'CLASS'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'BEGIN_DATE'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'END_DATE'.
APPEND LS_FIELDS TO FIELDS.

PERFORM RFC_READ_TABLE USING 'TPROJECT'
P_SM_RFC
SEL
FIELDS
CHANGING TPROJECT_TAB.
CLEAR: SEL, FIELDS, HANDLES_TAB[].

* Get the projects objects
APPEND 'OBJ_TYPE = `CUST`' TO SEL.

PERFORM RFC_READ_TABLE USING   'TOBJECTP'
P_SM_RFC
SEL
FIELDS
CHANGING TOBJECTP_TAB.

LOOP AT TPROJECT_TAB INTO TPROJECT_WA.
MODIFY_TABIX = SY-TABIX.
READ TABLE TOBJECTP_TAB WITH KEY PROJECT_ID = TPROJECT_WA-PROJECT_ID
INTO TOBJECT_WA .
TPROJECT_WA-GUID = TOBJECT_WA-OBJECT_ID.
MODIFY TPROJECT_TAB INDEX MODIFY_TABIX FROM TPROJECT_WA
TRANSPORTING GUID.
ENDLOOP.
*  Add the Project data to the current node
PERFORM ADD_ITAB_TO_XML TABLES TPROJECT_TAB HANDLES_TAB
USING G_IREF_PDOCUMENT SOLAR_PROJECTS_TYPE
'PROJECT_TYPE'.
CLEAR: SEL, FIELDS, HANDLES_TAB[].
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
SOLAR_PROJECTS_TYPE 'X'.

*-----------------------------------------------------------------------
* Create a child node for the Project node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'PROJECT_NODES'
CHANGING SOLAR_PROJECTS_NODE.

GT_ETL_MESSAGE-MESSAGE =
'SOLAR:2.Getting projects hierarchy using func SASAP_HIERARCHY_READ'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

* Getting the Solar data tree nodes
LOOP AT TPROJECT_TAB INTO TPROJECT_WA.

CONCATENATE 'SOLAR:3.Get hier of proj' TPROJECT_WA-PROJECT_ID
TPROJECT_WA-GUID
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

CALL FUNCTION 'SASAP_HIERARCHY_READ' DESTINATION P_SM_RFC
EXPORTING
STRUCTURE_ID                = TPROJECT_WA-GUID
READ_TEXTS                  = 'X'
INCLUDE_SUBSTRUCTURES       = 'X'
IMPORTING
MESSAGE                     = MESSAGE
TABLES
LIST_OF_NODES               = NODES
LIST_OF_TEXTS               = TEXTS.

IF NOT MESSAGE IS INITIAL.
CONCATENATE 'SOLAR:3.1' MESSAGE INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
ENDIF.

LOOP AT NODES INTO NODE_WA.
MOVE-CORRESPONDING NODE_WA TO ALL_NODES_WA.
APPEND ALL_NODES_WA TO ALL_NODES.
ENDLOOP.

APPEND LINES OF TEXTS TO ALL_TEXTS.
CLEAR: NODES, TEXTS.

ENDLOOP.

* Add the Project data to the current node
PERFORM ADD_ITAB_TO_XML TABLES ALL_NODES HANDLES_TAB
USING G_IREF_PDOCUMENT SOLAR_PROJECTS_NODE
'PROJECT_NODE'.
CLEAR HANDLES_TAB[].
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
SOLAR_PROJECTS_NODE 'X'.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'PROJECT_NODES_TEXTS'
CHANGING SOLAR_PROJ_NODE_TEXT.

PERFORM ADD_ITAB_TO_XML TABLES ALL_TEXTS HANDLES_TAB
USING G_IREF_PDOCUMENT SOLAR_PROJ_NODE_TEXT
'PROJECT_NODE_TEXT'.
CLEAR HANDLES_TAB[].
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
SOLAR_PROJ_NODE_TEXT 'X'.



CLEAR: ALL_TEXTS, SOLAR_PROJECTS_NODE.
*-----------------------------------------------------------------------

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'TRANSACTION_TREES'
CHANGING SOLAR_PROJECTS_NODE.

* Read from BMTNODE01R with nodes-REFNOD_ID.
* Get the business process trees
GT_ETL_MESSAGE-MESSAGE =
'SOLAR:4. Get business process trees-table BMTNODE01R'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

IS_FIRST = 'X'.
LOOP AT ALL_NODES INTO ALL_NODES_WA.
IF IS_FIRST = 'X'.
CLEAR IS_FIRST.
SEL_WA = 'REF_TYPE = `TREE`'.
APPEND SEL_WA TO SEL.
CONCATENATE 'AND  ( NODE_ID = `' ALL_NODES_WA-REFNODE_ID '`'
INTO SEL_WA.
ELSE.
CONCATENATE 'OR NODE_ID = `' ALL_NODES_WA-REFNODE_ID '`'
INTO SEL_WA.
ENDIF.


COUNTER = COUNTER + 1.
*   Select options are limited, we limit it to 1000 per query
IF COUNTER = MAX_SELECT_OPTIONS.
CONCATENATE SEL_WA ')' INTO SEL_WA.
APPEND SEL_WA TO SEL.

CONCATENATE 'SOLAR:4.1 Read tree for bulk with last tree'
ALL_NODES_WA-REFNODE_ID
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM RFC_READ_TABLE USING   'BMTNODE01R'
P_SM_RFC
SEL
FIELDS
CHANGING TMP_BMT_REFS.
APPEND LINES OF TMP_BMT_REFS TO BMT_TREE_REF.
COUNTER = 0.
CLEAR SEL.
IS_FIRST = 'X'.
ELSE.
AT LAST.
CONCATENATE SEL_WA ')' INTO SEL_WA.
APPEND SEL_WA TO SEL.

GT_ETL_MESSAGE-MESSAGE =
'SOLAR:4.1 Reading last batch of business process trees'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

*       Get the last bulk of the trees
PERFORM RFC_READ_TABLE USING   'BMTNODE01R'
P_SM_RFC
SEL
FIELDS
CHANGING TMP_BMT_REFS.
APPEND LINES OF TMP_BMT_REFS TO BMT_TREE_REF.
CLEAR TMP_BMT_REFS.
ENDAT.

APPEND SEL_WA TO SEL.
ENDIF.
ENDLOOP.
CLEAR: SEL, ALL_NODES, FIELDS.

* Create a node for the BMT nodes
* (all the nodes in the business process TREE)
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'BMT_TREES'
CHANGING BMTNODES.
* Get the BMT nodes
PERFORM ADD_ITAB_TO_XML TABLES BMT_TREE_REF HANDLES_TAB
USING G_IREF_PDOCUMENT BMTNODES
'BMT_TREE'.
CLEAR HANDLES_TAB[].
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
BMTNODES 'X'.


* Get all of the transactions
* (all of the objects in the transactions TAB OF SOLAR1)
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'SOLAR_TRANSACTIONS'
CHANGING SOLAR_TRANSACTIONS_NODE.
* Getting the transactions objects
PERFORM GET_SOLAR_TREE_NODES_AND_REFS TABLES BMT_TREE
BMT_TREE_REF
USING 'BMTA'
CHANGING SOLAR_TRANSACTIONS_NODE.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'SOLAR_URLS'
CHANGING SOLAR_URLS_NODE.
* Getting the other objects in the transaction tab.
PERFORM GET_SOLAR_TREE_NODES_AND_REFS TABLES BMT_TREE
BMT_TREE_REF
USING 'BMSO'
CHANGING SOLAR_URLS_NODE.

PERFORM ADD_ITAB_TO_XML TABLES BMT_TREE HANDLES_TAB
USING G_IREF_PDOCUMENT SOLAR_PROJECTS_NODE
'BMT_TREE_NODES'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING
SOLAR_PROJECTS_NODE 'X'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING
SOLAR_TRANSACTIONS_NODE 'X'.


PERFORM APPEND_XML_ELEMENT_TO_FILE USING
SOLAR_URLS_NODE 'X'.

CLEAR: BMT_TREE, BMT_TREE_REF.
*-----------------------------------------------------------------------
* Get the TBOM headers
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'TBOM_HEADS'
CHANGING SOLAR_PROJECTS_NODE.

GT_ETL_MESSAGE-MESSAGE =
'SOLAR:7. Getting TBOM headers AGS_TBOM_HEAD'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

* Since the line is too long - do not extract certain fields
LS_FIELDS-FIELDNAME = 'GUID'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'DESCRIPTION'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'DYNAMIC'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'E2ETRACE'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'STATIC'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'STATUS'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'ORIG_SYS'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'ORIG_CLIENT'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'CREATEDBY'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'CREATEDATE'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'CREATETIME'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'UPDATEDBY'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'UPDATEDATE'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'UPDATETIME'.
APPEND LS_FIELDS TO FIELDS.

PERFORM RFC_READ_TABLE USING 'AGS_TBOM_HEAD'
P_SM_RFC
SEL
FIELDS
CHANGING TBOM_HEADER_TAB[].
CLEAR: SEL, FIELDS.

PERFORM ADD_ITAB_TO_XML TABLES TBOM_HEADER_TAB HANDLES_TAB
USING G_IREF_PDOCUMENT SOLAR_PROJECTS_NODE
'TBOM_HEAD'.
CLEAR HANDLES_TAB[].
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
SOLAR_PROJECTS_NODE 'X'.

*----------------------------------------------------------------------
*  Get all of the TBOM entries
DATA:
LINES TYPE I,
SLINES TYPE STRING,
MAX_RFC_LINES TYPE I VALUE 10000,
KEEP_READING TYPE C VALUE 'X',
LAST_GUID TYPE STRING,
LAST_POS TYPE DDPOSITION.

PERFORM APPEND_STRING_TO_FILE USING '<DYNAMIC_TBOMS>'.

DATA:STRUCT_FIELDS TYPE TABLE OF RFC_FIELDS,
FIELD_WA LIKE LINE OF STRUCT_FIELDS,
BASE_NUMBER TYPE I,
STR_BASE_NUM TYPE STRING.

GT_ETL_MESSAGE-MESSAGE ='SOLAR:8. Start to read dyn TBOM'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM GET_RFC_STRUCTURE TABLES STRUCT_FIELDS
USING  'AGS_TBOM_BASE'
P_SM_RFC.

SORT STRUCT_FIELDS BY FIELDNAME.

LS_FIELDS-FIELDNAME = 'GUID'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'AS4POS'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'PGMID'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'OBJECT'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'OBJ_NAME'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'OBJ_SOURCE'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'OBJ_CLASS_TYPE'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'OBJ_CLASS_VALUE'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'DEVCLASS'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'DLVUNIT'.
APPEND LS_FIELDS TO FIELDS.
* Check if the field exists in the solman destination because there are
* differences between the different versions of solman
READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'PARENT_PGMID' BINARY
SEARCH
INTO FIELD_WA.
IF SY-SUBRC IS INITIAL.
LS_FIELDS-FIELDNAME = 'PARENT_PGMID'.
APPEND LS_FIELDS TO FIELDS.
ELSE.
GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field PARENT_PGMID not in solman AGS_TBOM_BASE'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
ENDIF.
READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'PARENT_OBJECT' BINARY
SEARCH
INTO FIELD_WA.
IF SY-SUBRC IS INITIAL.
LS_FIELDS-FIELDNAME = 'PARENT_OBJECT'.
APPEND LS_FIELDS TO FIELDS.
ELSE.
GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field PARENT_OBJECT not in solman AGS_TBOM_BASE'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
ENDIF.
READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'PARENT_OBJ_NAME' BINARY
SEARCH
INTO FIELD_WA.
IF SY-SUBRC IS INITIAL.
LS_FIELDS-FIELDNAME = 'PARENT_OBJ_NAME'.
APPEND LS_FIELDS TO FIELDS.
ELSE.
GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field PARENT_OBJ_NAME not in solman AGS_TBOM_BASE'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
ENDIF.
READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'SUB_OBJ_NAME' BINARY
SEARCH
INTO FIELD_WA.
IF SY-SUBRC IS INITIAL.
LS_FIELDS-FIELDNAME = 'SUB_OBJ_NAME'.
APPEND LS_FIELDS TO FIELDS.
ELSE.
GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field SUB_OBJ_NAME not in solman AGS_TBOM_BASE'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
ENDIF.
READ TABLE STRUCT_FIELDS WITH KEY FIELDNAME = 'TAB_HAS_KEY' BINARY
SEARCH
INTO FIELD_WA.
IF SY-SUBRC IS INITIAL.
LS_FIELDS-FIELDNAME = 'TAB_HAS_KEY'.
APPEND LS_FIELDS TO FIELDS.
ELSE.
GT_ETL_MESSAGE-MESSAGE =
'SOLAR:8.2 field TAB_HAS_KEY not in solman AGS_TBOM_BASE'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
ENDIF.

BASE_NUMBER = 0.
DESCRIBE TABLE TBOM_HEADER_TAB LINES LINES.
SLINES = LINES.
CONCATENATE 'SOLAR:8.2 number of TBOM headers read:'
SLINES
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

LOOP AT TBOM_HEADER_TAB INTO TBOM_HEADER_WA.
*   Get the number of entries in the base table for the header

CONCATENATE 'SOLAR:8.3 Read dyn tbom for header'
TBOM_HEADER_WA-GUID
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

IF TBOM_HEADER_WA-E2ETRACE IS INITIAL AND
TBOM_HEADER_WA-STATIC IS INITIAL.
*     In different versions of SOLMAN there are different fields.
*     Only TBOM for Dynamic or Semi-Dynamic are needed.
KEEP_READING = 'X'.
ELSE.
CLEAR KEEP_READING.
ENDIF.
*   Loop until finished reading all of the entries in the table
WHILE KEEP_READING = 'X'.
*     Set the options to read from the last record that was read
CONCATENATE 'GUID = `' TBOM_HEADER_WA-GUID '`' INTO SEL_WA.
APPEND SEL_WA TO SEL.
CONCATENATE ' AND AS4POS > `' LAST_POS '`' INTO SEL_WA.
APPEND SEL_WA TO SEL.

*     Read from the TBOM table with limit of lines
PERFORM RFC_READ_TABLE_WITH_ROWCOUNT USING 'AGS_TBOM_BASE'
P_SM_RFC
SEL
FIELDS
MAX_RFC_LINES
CHANGING TMP_BASE_TAB[].
*     Append the result of the current iteration to the global results
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TMP_BASE_TAB
USING G_IREF_PDOCUMENT
'DYN_TBOM'.

DESCRIBE TABLE TMP_BASE_TAB LINES LINES.
BASE_NUMBER = BASE_NUMBER + LINES.

*     If the number of lines read in the current iteration is less
*     than the maximum lines that we can read, it means that it reached
*     the end of the table.
IF LINES < MAX_RFC_LINES.
CLEAR KEEP_READING.
STR_BASE_NUM = BASE_NUMBER.
CONCATENATE 'SOLAR:8.4 Header'
TBOM_HEADER_WA-GUID
'has'
STR_BASE_NUM
'entries'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
CLEAR: BASE_NUMBER, LAST_POS, LAST_GUID.
ELSE.
*       Get the last record read in the current iteration and set the
*       key as the last read GUID and POS for the next iteration
READ TABLE TMP_BASE_TAB INTO TBOM_BASE_WA INDEX LINES.
LAST_GUID = TBOM_BASE_WA-GUID.
LAST_POS = TBOM_BASE_WA-AS4POS.
ENDIF.
CLEAR: SEL, TMP_BASE_TAB.
ENDWHILE.
ENDLOOP.

CLEAR: FIELDS, HANDLES_TAB[].
PERFORM APPEND_STRING_TO_FILE USING '</DYNAMIC_TBOMS>'.
*----------------------------------------------------------------------
PERFORM APPEND_STRING_TO_FILE USING '</SOLAR_DATA>'.
PERFORM ADD_TIME_STAT USING 'Extract Solution Manager Projects'
L_STARTTIME.

ENDFORM.                                         "GET_SOLAR_RAW_DATA.
*&---------------------------------------------------------------------*
*&      Form  GET_SOLAR_TREE_NODES_AND_REFS
*&---------------------------------------------------------------------*
*        Get solar tree nodes
*----------------------------------------------------------------------*
* BMT_TREE (OUT) - All of the nodes of the tree
* BMT_TREE_REF (IN) - The references for the trees to be read
* TYPE - The type of the node read (Transaction/other objects)
* P_XML_ELEMENT - the XML element for the references
*----------------------------------------------------------------------*

FORM GET_SOLAR_TREE_NODES_AND_REFS TABLES BMT_TREE_NODES
BMT_TREE_REF
USING TYPE
CHANGING P_XML_ELEMENT  TYPE
XML_ELEMENT.

DATA:
HANDLES_TAB    TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
BMTNODE_WA TYPE BMTNODE01,
FIELDS TYPE TABLE OF RFC_DB_FLD,
LS_FIELDS LIKE LINE OF FIELDS,
SEL TYPE TABLE OF RFC_DB_OPT,
SEL_WA TYPE RFC_DB_OPT,
COUNTER TYPE I VALUE 0,
IS_FIRST TYPE C VALUE 'X',
BMTNODE_REFS TYPE TABLE OF BMTNODE01R,
RES_BMTNODE_R TYPE TABLE OF BMTNODE01R,
RES_DFURLS TYPE TABLE OF SM_DFURLS.

* Read the nodes of the Business process tree
PERFORM GET_NODES TABLES BMT_TREE_REF
BMT_TREE_NODES
USING TYPE.



CONCATENATE 'SOLAR:6. Start reading node references for type'
TYPE
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

CLEAR: SEL, FIELDS.
COUNTER = 0.
IS_FIRST = 'X'.
LOOP AT BMT_TREE_NODES INTO BMTNODE_WA.
*   Create the select options
*   Only the first line does not start with 'OR'
IF IS_FIRST = 'X'.
CLEAR IS_FIRST.
CONCATENATE '( NODE_ID = `' BMTNODE_WA-NODE_ID '`'
INTO SEL_WA.
ELSE.
CONCATENATE 'OR NODE_ID = `' BMTNODE_WA-NODE_ID '`'
INTO SEL_WA.
ENDIF.

COUNTER = COUNTER + 1.
*   Limit the select option to 1000 rows
IF COUNTER = MAX_SELECT_OPTIONS.
*     Check if it runs for transactions or for the other objects
*     and read the relevant nodes

CONCATENATE SEL_WA ')' INTO SEL_WA SEPARATED BY SPACE.
APPEND SEL_WA TO SEL.

IF TYPE = 'BMTA'.

SEL_WA = 'AND ( REF_TYPE = `BMTA` OR REF_TYPE = `BMRE` )'.
APPEND SEL_WA TO SEL.

CONCATENATE
'SOLAR:6.1 trans batch with last node '
BMTNODE_WA-NODE_ID
'for type BMTA'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM READ_NODES_REF_TABLE TABLES RES_BMTNODE_R
USING SEL
FIELDS.
ELSEIF TYPE = 'BMSO'.

CONCATENATE
'SOLAR:6.1 Read Business Process URLS with last node '
BMTNODE_WA-NODE_ID
'for type BMSO'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM READ_NODES_URL_TABLE TABLES RES_DFURLS
USING SEL
FIELDS.
ENDIF.
*     Reset for new run
CLEAR SEL.
COUNTER = 0.
IS_FIRST = 'X'.
ELSE.
AT LAST.
CONCATENATE SEL_WA ')' INTO SEL_WA SEPARATED BY SPACE.
ENDAT.
APPEND SEL_WA TO SEL.
ENDIF.
ENDLOOP.

* If the counter is not reseted, it means that there are still
* records to read
IF COUNTER > 0.
*   Read the relevant nodes (Transactions or other objects)
*   BMTA = transacitons, read from bmtnode01r
*   BMSO = other objects, read from dfurls.
IF TYPE = 'BMTA'.
SEL_WA = 'AND ( REF_TYPE = `BMTA` OR REF_TYPE = `BMRE` )'.
APPEND SEL_WA TO SEL.

GT_ETL_MESSAGE-MESSAGE =
'SOLAR:6.1 Reading last batch of transactions (TYPE BMTA)'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM READ_NODES_REF_TABLE TABLES RES_BMTNODE_R
USING SEL
FIELDS.
ELSEIF TYPE = 'BMSO'.

GT_ETL_MESSAGE-MESSAGE =
'SOLAR:6.1 Reading last batch of business process URLS(TYPE BMSO)'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM READ_NODES_URL_TABLE TABLES RES_DFURLS
USING SEL
FIELDS.
ENDIF.
ENDIF.


* Add the nodes to the xml file
IF TYPE = 'BMTA'.
PERFORM ADD_ITAB_TO_XML TABLES RES_BMTNODE_R HANDLES_TAB
USING G_IREF_PDOCUMENT P_XML_ELEMENT
'BMTNODER'.
ELSEIF TYPE = 'BMSO'.
PERFORM ADD_ITAB_TO_XML TABLES RES_DFURLS HANDLES_TAB
USING G_IREF_PDOCUMENT P_XML_ELEMENT
'DFURLS'.
ENDIF.
CLEAR HANDLES_TAB[].
ENDFORM.                               "GET_SOLAR_TREE_NODES_AND_REFS
*&---------------------------------------------------------------------*
*&      Form  GET_NODES
*&---------------------------------------------------------------------*
*       Get tree nodes according to the type.
*----------------------------------------------------------------------*
* BMTNODE_REFS (IN) - Refrence to the trees to read
* ALL_BMTNODES (OUT) - all of the nodes of the trees
*----------------------------------------------------------------------*
FORM GET_NODES TABLES BMTNODE_REFS
ALL_BMTNODES
USING    TYPE.
DATA:
BMTNODE_R_WA TYPE BMTNODE01R,
BMTNODES TYPE TABLE OF SM_PROJECT_TREE,
FIELDS TYPE TABLE OF RFC_DB_FLD,
LS_FIELDS LIKE LINE OF FIELDS,
SEL TYPE TABLE OF RFC_DB_OPT,
SEL_WA TYPE RFC_DB_OPT,
COUNTER TYPE I VALUE 0,
IS_FIRST TYPE C VALUE 'X',
LINES TYPE I.

CLEAR: SEL, FIELDS.
* Since the line is too long get only the relevant fields
LS_FIELDS-FIELDNAME = 'TREE_ID'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'EXTENSION'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'NODE_ID'.
APPEND LS_FIELDS TO FIELDS.
LS_FIELDS-FIELDNAME = 'EXT_KEY'.
APPEND LS_FIELDS TO FIELDS.

CONCATENATE 'SOLAR:5 Start reading Business Process nodes for type '
TYPE
'from table BMTNODE01'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

IS_FIRST = 'X'.
LOOP AT BMTNODE_REFS INTO BMTNODE_R_WA.
IF IS_FIRST = 'X'.
*     At the first iteration append the type and format the
*     select option
CLEAR IS_FIRST.

IF TYPE = 'BMTA'.
SEL_WA = '( NODE_TYPE = `BMTA`'.
APPEND SEL_WA TO SEL.
SEL_WA = ' OR NODE_TYPE = `BMRE` )'.
APPEND SEL_WA TO SEL.
ELSE.
CONCATENATE 'NODE_TYPE = `' TYPE '`' INTO SEL_WA.
APPEND SEL_WA TO SEL.
ENDIF.

CONCATENATE 'AND  ( TREE_ID = `' BMTNODE_R_WA-REF_OBJECT '`'
INTO SEL_WA.
ELSE.
*     All other lines but the first, begin with 'OR'
CONCATENATE 'OR TREE_ID = `' BMTNODE_R_WA-REF_OBJECT '`'
INTO SEL_WA.
ENDIF.

COUNTER = COUNTER + 1.
*   Here the limit of the select option is 500 (and not 1000)
*   because of the mass of results that are expected back
IF COUNTER  = MAX_SEL_OPT_LARGE_DATA.
*     close the select options before executing
CONCATENATE SEL_WA ')' INTO SEL_WA.
APPEND SEL_WA TO SEL.

CONCATENATE 'SOLAR:5.1 read tree nodes- last tree'
BMTNODE_R_WA-REF_OBJECT
'for type'
TYPE
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM RFC_READ_TABLE USING   'BMTNODE01'
P_SM_RFC
SEL
FIELDS
CHANGING BMTNODES.
*     Append current iteration result to the final results
APPEND LINES OF BMTNODES TO ALL_BMTNODES.
*     Reset all for the next run
CLEAR: SEL.
COUNTER = 0.
IS_FIRST = 'X'.
ELSE.
AT LAST.
*       If this is the last row, so it needs to close the select option
CONCATENATE SEL_WA ')' INTO SEL_WA.
APPEND SEL_WA TO SEL.

CONCATENATE
'SOLAR:5.1 Reading nodes of trees for the last batch'
'for type'
TYPE
INTO GT_ETL_MESSAGE-MESSAGE .
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM ADD_USED_MEMORY_TO_LOG.

PERFORM RFC_READ_TABLE USING   'BMTNODE01'
P_SM_RFC
SEL
FIELDS
CHANGING BMTNODES.
APPEND LINES OF BMTNODES TO ALL_BMTNODES.
CLEAR: SEL, FIELDS.
ENDAT.
APPEND SEL_WA TO SEL.
ENDIF.

ENDLOOP.
CLEAR BMTNODE_REFS.
ENDFORM.                              "GET_NODES
*&---------------------------------------------------------------------*
*&      Form  READ_NODES_REF_TABLE
*&---------------------------------------------------------------------*
*       Read from BMTNODE01R
*----------------------------------------------------------------------*
* RESULTS (OUT) - the results from the table
* SEL (IN) - the select options to select by
* FIELDS (IN) - the list of field to read from the table
*----------------------------------------------------------------------*
FORM READ_NODES_REF_TABLE TABLES RESULTS
USING SEL TYPE TT_OPTIONS
FIELDS TYPE TT_FIELDS.
DATA:
BMTNODE_REFS TYPE TABLE OF BMTNODE01R.

GT_ETL_MESSAGE-MESSAGE =
'SOLAR:6.1.1 Get trnasactions from table BMTNODE01R'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM RFC_READ_TABLE USING 'BMTNODE01R'
P_SM_RFC
SEL
FIELDS
CHANGING BMTNODE_REFS.

APPEND LINES OF BMTNODE_REFS TO RESULTS.

ENDFORM.                               "READ_NODES_REF_TABLE
*&---------------------------------------------------------------------*
*&      Form  READ_URL_TABLE
*&---------------------------------------------------------------------*
*       Read from DFURLS
*----------------------------------------------------------------------*
* RESULTS (OUT) - the results from the table
* SEL (IN) - the select options to select by
* FIELDS (IN) - the list of field to read from the table
*----------------------------------------------------------------------*
FORM READ_NODES_URL_TABLE TABLES RESULTS
USING SEL TYPE TT_OPTIONS
FIELDS TYPE TT_FIELDS.
DATA:
URLS_REFS TYPE TABLE OF SM_DFURLS.


GT_ETL_MESSAGE-MESSAGE = 'SOLAR:6.1.1 Get URLS from table DFURLS'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

PERFORM RFC_READ_TABLE USING 'DFURLS'
P_SM_RFC
SEL
FIELDS
CHANGING URLS_REFS.

APPEND LINES OF URLS_REFS TO RESULTS.

ENDFORM.                               "READ_NODES_URL_TABLE

*&---------------------------------------------------------------------*
*&      Form  read_solman_functions
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*      <--P_LT_TAB512  text
*----------------------------------------------------------------------*
FORM READ_SOLMAN_FUNCTIONS
TABLES   CT_TAB512 STRUCTURE TAB512
USING    IV_RFCDEST TYPE RFCDEST
IV_VALIDATE TYPE FLAG
CHANGING EV_FAILED  TYPE FLAG.

DATA : LT_RFC_DB_OPT TYPE STANDARD TABLE OF RFC_DB_OPT,
LS_RFC_DB_OPT LIKE LINE OF LT_RFC_DB_OPT,
LT_RFC_DB_FLD TYPE STANDARD TABLE OF RFC_DB_FLD,
LS_RFC_DB_FLD LIKE LINE OF LT_RFC_DB_FLD,
LV_FUNC       TYPE STRING,
LV_SUBRC      TYPE C,
RFC_ERROR     TYPE RFCLOG_D,
LV_ERR_MSG    TYPE STRING.

* Check solman functions in the rfc system
CLEAR : LT_RFC_DB_OPT[] , LT_RFC_DB_FLD[] , CT_TAB512[].

* Set functions names to be checked
CLEAR : LS_RFC_DB_OPT .
LV_FUNC = 'SMSY_GET_ALL_SYSTEMS_INFO'.
CONCATENATE
'FUNCNAME =''' LV_FUNC ''''
' OR ' INTO LS_RFC_DB_OPT-TEXT.
APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

CLEAR : LS_RFC_DB_OPT.
LV_FUNC = 'SMSY_GET_RELINST_TO_SYSTEM_RFC'.
CONCATENATE
'FUNCNAME =''' LV_FUNC ''''
' OR ' INTO LS_RFC_DB_OPT-TEXT.
APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

CLEAR : LS_RFC_DB_OPT.
LV_FUNC = 'SMSY_GET_INST_OF_PRODUCT_RFC'.
CONCATENATE
'FUNCNAME =''' LV_FUNC ''''
' OR ' INTO LS_RFC_DB_OPT-TEXT.
APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

CLEAR : LS_RFC_DB_OPT.
LV_FUNC = 'SMSY_GET_CVERS_INFO_RFC'.
CONCATENATE 'FUNCNAME =''' LV_FUNC ''''
' OR ' INTO LS_RFC_DB_OPT-TEXT.
APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

CLEAR : LS_RFC_DB_OPT.
LV_FUNC = 'RSDRI_INFOPROV_READ_RFC'.
CONCATENATE 'FUNCNAME =''' LV_FUNC ''''
' OR ' INTO LS_RFC_DB_OPT-TEXT.
APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

CLEAR : LS_RFC_DB_OPT.
LV_FUNC = 'SASAP_HIERARCHY_READ'.
CONCATENATE 'FUNCNAME =''' LV_FUNC ''''
INTO LS_RFC_DB_OPT-TEXT.
APPEND LS_RFC_DB_OPT-TEXT TO LT_RFC_DB_OPT.

*  clear : ls_rfc_db_opt.
*  lv_func = 'SMSY_GET_SYSTEM_PAT03'.
*  concatenate 'FUNCNAME =''' lv_func ''''
*  into ls_rfc_db_opt-text.
*  append ls_rfc_db_opt-text to lt_rfc_db_opt.

* Set field name for validity check
CONCATENATE 'FUNCNAME' '' INTO LS_RFC_DB_FLD-FIELDNAME.
APPEND LS_RFC_DB_FLD TO LT_RFC_DB_FLD.

* Check that the fucntions exist in RFC system in TFDIR
CALL FUNCTION 'RFC_READ_TABLE'
DESTINATION IV_RFCDEST
EXPORTING
QUERY_TABLE                = 'TFDIR'
*     DELIMITER                  = ' '
*     NO_DATA                    = ' '
*     ROWSKIPS                   = 0
*     ROWCOUNT                   = 0
TABLES
OPTIONS                    = LT_RFC_DB_OPT
FIELDS                     = LT_RFC_DB_FLD
DATA                       = CT_TAB512
EXCEPTIONS
TABLE_NOT_AVAILABLE        = 1
TABLE_WITHOUT_DATA         = 2
OPTION_NOT_VALID           = 3
FIELD_NOT_VALID            = 4
NOT_AUTHORIZED             = 5
DATA_BUFFER_EXCEEDED       = 6
SYSTEM_FAILURE             = 7 MESSAGE RFC_ERROR
COMMUNICATION_FAILURE      = 8 MESSAGE RFC_ERROR
OTHERS                     = 9.

IF NOT SY-SUBRC IS INITIAL.
IF NOT IV_VALIDATE IS INITIAL.
IF SY-SUBRC = 5.
"Message - SM rfc user has no auth to read tfdir
CONCATENATE
'SM SM rfc user has no auth to read TFDIR table dat from'
IV_RFCDEST
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ELSE.
LV_SUBRC = SY-SUBRC.
"Message - function doesnt exist in SM
CONCATENATE 'SM Error reading SM functions from'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ENDIF.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
EV_FAILED = ABAP_TRUE.
ELSE.
IF SY-SUBRC = 7 OR SY-SUBRC = 8.
CONCATENATE
'RFC error for'
IV_RFCDEST
':'
RFC_ERROR
INTO LV_ERR_MSG
SEPARATED BY SPACE.
ELSE.
CONCATENATE 'Error reading Solution Manager functions from'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO LV_ERR_MSG
SEPARATED BY SPACE.
ENDIF.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ENDIF.
ENDIF.
ENDFORM.                    " read_solman_functions
*&---------------------------------------------------------------------*
*&      Form  read_smsy_systems
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSY_SYSTEM_SAP  text
*      -->P_LT_SMSY_SYST_CLIENT  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*      <--P_LV_FAILED  text
*----------------------------------------------------------------------*
FORM READ_SMSY_SYSTEMS  USING    IV_RFCDEST
CHANGING EV_FAILED
CT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T
CT_SMSY_SYSTEM_SAP TYPE
SMSY_SYSTEM_SAP_T
CT_SMSY_SYST_CLIENT TYPE
SMSY_SYST_CLIENT_T.
DATA : LV_SUBRC TYPE C.

* Remove each SM system data
CLEAR : CT_SMSY_SYSTEM[],
CT_SMSY_SYSTEM_SAP[],
CT_SMSY_SYST_CLIENT[].

CALL FUNCTION 'SMSY_GET_ALL_SYSTEMS_INFO'
DESTINATION IV_RFCDEST
*   EXPORTING
*     NO_KONZS            = ' '
*     IV_SYSTEMTYPE       =
IMPORTING
SYSTEMS             = CT_SMSY_SYSTEM
SYSTEMS_SAP         = CT_SMSY_SYSTEM_SAP
CLIENTS             = CT_SMSY_SYST_CLIENT
EXCEPTIONS
SYSTEM_FAILURE        = 1
COMMUNICATION_FAILURE = 2.

IF NOT SY-SUBRC IS INITIAL.
LV_SUBRC = SY-SUBRC.
"Message - function doesnt exist in SM
CONCATENATE 'SM Error executing SMSY_GET_ALL_SYSTEMS_INFO in'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

EV_FAILED = ABAP_TRUE.
ENDIF.
ENDFORM.                    " read_smsy_systems
*&---------------------------------------------------------------------*
*&      Form  read_poducts_instances
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSY_SYS_RELINST  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM GET_SYSTEM_LEADING_PRODUCTS USING  IV_RFCDEST TYPE RFCDEST
IT_SMSY_SYSTEM TYPE
SMSY_SYSTEM_T
CHANGING CT_SMSY_SYS_RELINST_FINAL
TYPE
SMSY_SYS_RELINST_T.

DATA : LS_SMSY_SYSTEM      LIKE LINE OF IT_SMSY_SYSTEM,
LT_SMSY_SYS_RELINST TYPE SMSY_SYS_RELINST_T,
LS_SMSY_SYS_RELINST LIKE LINE OF LT_SMSY_SYS_RELINST,
LV_NO_RIGHTS        TYPE FLAG,
LV_SUBRC            TYPE C.

LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
CLEAR : LT_SMSY_SYS_RELINST[] , LV_NO_RIGHTS.

CALL FUNCTION 'SMSY_GET_RELINST_TO_SYSTEM_RFC'
DESTINATION IV_RFCDEST
EXPORTING
SYSTEMNAME                  = LS_SMSY_SYSTEM-SYSTEMNAME
*     VERSION                     = 'ACTIVE'
*     IV_SYSTEMTYPE               =
IMPORTING
SYS_RELINST                 = LT_SMSY_SYS_RELINST
EV_NO_RIGHTS                = LV_NO_RIGHTS
EXCEPTIONS
SYSTEM_DOES_NOT_EXIST       = 1
ERROR                       = 2
SYSTEM_FAILURE              = 3
COMMUNICATION_FAILURE       = 4
OTHERS                      = 5.

IF SY-SUBRC <> 0 OR NOT LV_NO_RIGHTS IS INITIAL.
LV_SUBRC = SY-SUBRC.
*    Message auth. error running SMSY_GET_RELINST_TO_SYSTEM_RFC
CONCATENATE
'SM Error executing SMSY_GET_RELINST_TO_SYSTEM_RFC in'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSEIF NOT LT_SMSY_SYS_RELINST[] IS INITIAL.
*     Set only system relevant product for products fetch
LOOP AT LT_SMSY_SYS_RELINST INTO LS_SMSY_SYS_RELINST WHERE
FLG_RELEVANT = ABAP_TRUE.
APPEND LS_SMSY_SYS_RELINST TO CT_SMSY_SYS_RELINST_FINAL.
ENDLOOP.
ENDIF.
ENDLOOP.

ENDFORM.                    " read_poducts_instances
*&---------------------------------------------------------------------*
*&      Form  read_system_product_instances
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYS_RELINST_FINAL  text
*      -->P_LT_SMSY_MAIN_INST_FINAL  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_PRODUCTS_INSTANCES USING IV_RFCDEST TYPE RFCDEST
IT_SMSY_SYS_RELINST_FINAL
TYPE
SMSY_SYS_RELINST_T
CHANGING CT_SMSY_MAIN_INST_FINAL
TYPE SMSY_MAIN_INST_SYST_T.


DATA : LV_SUBRC                TYPE C,
LS_SMSY_SYS_RELINST     LIKE LINE OF
IT_SMSY_SYS_RELINST_FINAL,
LT_SMSY_MAIN_INST       TYPE SMSY_MAIN_INST_T,
LS_SMSY_MAIN_INST       LIKE LINE OF LT_SMSY_MAIN_INST,
LV_NO_RIGHTS            TYPE FLAG,
LS_SMSY_MAIN_INST_FINAL LIKE LINE OF CT_SMSY_MAIN_INST_FINAL.

LOOP AT IT_SMSY_SYS_RELINST_FINAL INTO LS_SMSY_SYS_RELINST.

CLEAR: LT_SMSY_MAIN_INST[] , LV_NO_RIGHTS.
CALL FUNCTION 'SMSY_GET_INST_OF_PRODUCT_RFC'
DESTINATION IV_RFCDEST
EXPORTING
PRODUCT                = LS_SMSY_SYS_RELINST-PRODUCT
READ_FROM_DB           = ABAP_TRUE
IMPORTING
MAIN_INSTANCES         = LT_SMSY_MAIN_INST
EV_NO_RIGHTS           = LV_NO_RIGHTS
EXCEPTIONS
PRODUCT_DOES_NOT_EXIST = 1
ERROR                  = 2
NO_INSTANCES           = 3
SYSTEM_FAILURE         = 4
COMMUNICATION_FAILURE  = 5
OTHERS                 = 6.

IF SY-SUBRC <> 0 OR NOT LV_NO_RIGHTS IS INITIAL.
LV_SUBRC = SY-SUBRC.
*     Message auth error running SMSY_GET_INST_OF_PRODUCT_RFC
CONCATENATE 'SM Error executing SMSY_GET_INST_OF_PRODUCT_RFC in'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSEIF NOT LT_SMSY_MAIN_INST[] IS INITIAL.
LOOP AT LT_SMSY_MAIN_INST INTO LS_SMSY_MAIN_INST.
MOVE-CORRESPONDING LS_SMSY_MAIN_INST TO
LS_SMSY_MAIN_INST_FINAL.
LS_SMSY_MAIN_INST_FINAL-SYSTEMNAME =
LS_SMSY_SYS_RELINST-SYSTEMNAME.
APPEND LS_SMSY_MAIN_INST_FINAL TO CT_SMSY_MAIN_INST_FINAL.
ENDLOOP.
ENDIF.
ENDLOOP.
ENDFORM.                    " read_system_product_instances
*&---------------------------------------------------------------------*
*&      Form  read_system_components
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSYPROCOM_FINAL  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_COMPONENTS USING    IV_RFCDEST TYPE RFCDEST
IT_SMSY_SYSTEM      TYPE
SMSY_SYSTEM_T
CHANGING CT_SMSYPROCOM_FINAL TYPE
SMSYPROCOM_T.

DATA : LS_SMSY_SYSTEM LIKE LINE OF IT_SMSY_SYSTEM,
LT_SMSYPROCOM  TYPE SMSYPROCOM_T,
LS_MSG         TYPE SYMSG,
LV_SUBRC       TYPE C,
LV_NO_RIGHTS   TYPE FLAG.

LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
CLEAR : LT_SMSYPROCOM[], LV_NO_RIGHTS, LS_MSG.
CALL FUNCTION 'SMSY_GET_CVERS_INFO_RFC'
DESTINATION IV_RFCDEST
EXPORTING
SYSTEMNAME            = LS_SMSY_SYSTEM-SYSTEMNAME
*       iv_systemtype         =
IMPORTING
ET_PROCOM             = LT_SMSYPROCOM
EV_NO_RIGHTS          = LV_NO_RIGHTS
ES_MSG                = LS_MSG
EXCEPTIONS
SYSTEM_DOES_NOT_EXIST = 1
ERROR                 = 2
SYSTEM_FAILURE        = 3
COMMUNICATION_FAILURE = 4
OTHERS                = 5.

IF SY-SUBRC <> 0 OR NOT LV_NO_RIGHTS IS INITIAL.
LV_SUBRC = SY-SUBRC.
*     Message auth error running SMSY_GET_CVERS_INFO_RFC
CONCATENATE 'SM Error executing SMSY_GET_CVERS_INFO_RFC in'
IV_RFCDEST
'from system'
LS_SMSY_SYSTEM-SYSTEMNAME
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSEIF NOT LS_MSG IS INITIAL.
*     Message error occured running SMSY_GET_CVERS_INFO_RFC
CONCATENATE 'SM Error executing SMSY_GET_CVERS_INFO_RFC in'
IV_RFCDEST
'for system'
LS_SMSY_SYSTEM-SYSTEMNAME
'error message:'
LS_MSG
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSEIF NOT LT_SMSYPROCOM[] IS INITIAL.
APPEND LINES OF LT_SMSYPROCOM TO CT_SMSYPROCOM_FINAL.
ENDIF.
ENDLOOP.
ENDFORM.                    " read_system_components
*&---------------------------------------------------------------------*
*&      Form  read_system_patches
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_PAT03_FINAL  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_PATCHES USING  IV_RFCDEST TYPE RFCDEST
IT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T
CHANGING CT_PAT03_FINAL TYPE
TY_SYST_PAT03_OUT_T.

DATA : LS_SMSY_SYSTEM LIKE LINE OF IT_SMSY_SYSTEM,
LT_PAT03       TYPE TY_SYST_PAT03_T,
LS_PAT03       LIKE LINE OF LT_PAT03,
LS_PAT03_FINAL LIKE LINE OF CT_PAT03_FINAL.

DATA : LV_HANDLE         TYPE BALLOGHNDL VALUE ''.

LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
CLEAR : LT_PAT03[].
CALL FUNCTION 'SMSY_GET_SYSTEM_PAT03'
DESTINATION IV_RFCDEST
EXPORTING
SYSTEM                = LS_SMSY_SYSTEM-SYSTEMNAME
IV_LOG_HANDLE         = LV_HANDLE
TABLES
ET_PAT03              = LT_PAT03
EXCEPTIONS
DESTINATION_ERROR     = 1
SYSTEM_FAILURE        = 2
COMMUNICATION_FAILURE = 3
OTHERS                = 4.

IF SY-SUBRC <> 0.
*     Message auth error running SMSY_GET_SYSTEM_PAT03
CONCATENATE 'SM Error executing SMSY_GET_SYSTEM_PAT03 in'
IV_RFCDEST
'for system'
LS_SMSY_SYSTEM-SYSTEMNAME
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSEIF NOT LT_PAT03[] IS INITIAL.
LOOP AT LT_PAT03 INTO LS_PAT03.
MOVE-CORRESPONDING LS_PAT03 TO LS_PAT03_FINAL.
LS_PAT03_FINAL-SYSTEMNAME = LS_SMSY_SYSTEM-SYSTEMNAME.
APPEND LS_PAT03_FINAL TO CT_PAT03_FINAL.
ENDLOOP.
ENDIF.
ENDLOOP.

ENDFORM.                    " read_system_patches
*&---------------------------------------------------------------------*
*&      Form  read_system_oss_data
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_AISYSNR_BUFFER  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_SYSTEM_OSS_DATA USING  IV_RFCDEST TYPE RFCDEST
CHANGING CT_AISYSNR_BUFFER TYPE
AISYSNR_BUFFER_T.

DATA : LV_SUBRC      TYPE C,
LT_RFC_DB_OPT TYPE STANDARD TABLE OF RFC_DB_OPT,
LT_RFC_DB_FLD TYPE STANDARD TABLE OF RFC_DB_FLD,
LT_TAB512     TYPE STANDARD TABLE OF TAB512.

CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].

CALL FUNCTION 'RFC_READ_TABLE'
DESTINATION IV_RFCDEST
EXPORTING
QUERY_TABLE                = 'AISYSNR_BUFFER'
*     DELIMITER                  = ' '
*     NO_DATA                    = ' '
*     ROWSKIPS                   = 0
*     ROWCOUNT                   = 0
TABLES
OPTIONS                    = LT_RFC_DB_OPT
FIELDS                     = LT_RFC_DB_FLD
DATA                       = LT_TAB512
EXCEPTIONS
TABLE_NOT_AVAILABLE        = 1
TABLE_WITHOUT_DATA         = 2
OPTION_NOT_VALID           = 3
FIELD_NOT_VALID            = 4
NOT_AUTHORIZED             = 5
DATA_BUFFER_EXCEEDED       = 6
SYSTEM_FAILURE             = 7
COMMUNICATION_FAILURE      = 8
OTHERS                     = 9.

IF SY-SUBRC <> 0.
IF SY-SUBRC = 5.
*     Message - SM rfc user has no auth to read AISYSNR_BUFFER
CONCATENATE
'SM SM rfc user has no auth to read AISYSNR_BUFFER'
'table data from'
IV_RFCDEST
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ELSE.
LV_SUBRC = SY-SUBRC.
*     Message - function doesnt exist in SM
CONCATENATE 'SM Error reading SMSY OSS data from'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ENDIF.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
CT_AISYSNR_BUFFER[] = LT_TAB512[].
ENDIF.

ENDFORM.                    " read_system_oss_data
*&---------------------------------------------------------------------*
*&      Form  read_products
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_AISYSNR_BUFFER  text
*      -->P_LT_SMSY_SYST_PRODVR  text
*      -->P_LT_SMSY_PROD_VERS  text
*      -->P_LT_SMSY_PRODUCT  text
*      -->P_LS_RFCDISPLAY_RFCDEST  text
*----------------------------------------------------------------------*
FORM READ_PRODUCTS USING  IV_RFCDEST        TYPE RFCDEST
IT_SMSY_SYSTEM    TYPE SMSY_SYSTEM_T
IT_AISYSNR_BUFFER TYPE AISYSNR_BUFFER_T
CHANGING CT_SMSY_PROD_VERS     TYPE
SMSY_PROD_VERS_T
CT_SMSY_PRODUCT       TYPE SMSY_PRODUCT_T
CT_SM_SYSTEM_PRODUCTS TYPE
SM_SYSTEM_PRODUCTS_T.

DATA: LV_SUBRC            TYPE C,
LT_RFC_DB_OPT       TYPE STANDARD TABLE OF RFC_DB_OPT,
LT_RFC_DB_FLD       TYPE STANDARD TABLE OF RFC_DB_FLD,
LT_TAB512           TYPE STANDARD TABLE OF TAB512,
LT_SMSY_SYST_PRODVR TYPE SMSY_SYST_PRODVR_T,
LS_SMSY_SYSTEM      LIKE LINE OF IT_SMSY_SYSTEM,
LS_SMSY_SYST_PRODVR LIKE LINE OF LT_SMSY_SYST_PRODVR,
LS_SMSY_PROD_VERS   LIKE LINE OF CT_SMSY_PROD_VERS,
LS_SMSY_PRODUCT     LIKE LINE OF CT_SMSY_PRODUCT,
LS_SM_SYSTEM_PRODUCTS LIKE LINE OF CT_SM_SYSTEM_PRODUCTS,
LS_AISYSNR_BUFFER   LIKE LINE OF IT_AISYSNR_BUFFER.

IF NOT IT_SMSY_SYSTEM[] IS INITIAL.
CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].

*   Fetch all data from SM
*   SMSY_SYST_PRODVR - product version for each system
CALL FUNCTION 'RFC_READ_TABLE'
DESTINATION IV_RFCDEST
EXPORTING
QUERY_TABLE                = 'SMSY_SYST_PRODVR'
*       DELIMITER                  = ' '
*       NO_DATA                    = ' '
*       ROWSKIPS                   = 0
*       ROWCOUNT                   = 0
TABLES
OPTIONS                    = LT_RFC_DB_OPT
FIELDS                     = LT_RFC_DB_FLD
DATA                       = LT_TAB512
EXCEPTIONS
TABLE_NOT_AVAILABLE        = 1
TABLE_WITHOUT_DATA         = 2
OPTION_NOT_VALID           = 3
FIELD_NOT_VALID            = 4
NOT_AUTHORIZED             = 5
DATA_BUFFER_EXCEEDED       = 6
SYSTEM_FAILURE             = 7
COMMUNICATION_FAILURE      = 8
OTHERS                     = 9.

IF SY-SUBRC <> 0.
IF SY-SUBRC = 5.
"Message - SM rfc user has no auth to read SMSY_SYST_PRODVR
CONCATENATE
'SM SM rfc user has no auth to read SMSY_SYST_PRODVR'
'table data from '
IV_RFCDEST
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ELSE.
LV_SUBRC = SY-SUBRC.
CONCATENATE
'SM Error reading SMSY systems to product versions data from'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ENDIF.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
LT_SMSY_SYST_PRODVR[] = LT_TAB512[].
ENDIF.

CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].
*   SMSY_PROD_VERS - product version , product , text
CALL FUNCTION 'RFC_READ_TABLE'
DESTINATION IV_RFCDEST
EXPORTING
QUERY_TABLE                = 'SMSY_PROD_VERS'
*       DELIMITER                  = ' '
*       NO_DATA                    = ' '
*       ROWSKIPS                   = 0
*       ROWCOUNT                   = 0
TABLES
OPTIONS                    = LT_RFC_DB_OPT
FIELDS                     = LT_RFC_DB_FLD
DATA                       = LT_TAB512
EXCEPTIONS
TABLE_NOT_AVAILABLE        = 1
TABLE_WITHOUT_DATA         = 2
OPTION_NOT_VALID           = 3
FIELD_NOT_VALID            = 4
NOT_AUTHORIZED             = 5
DATA_BUFFER_EXCEEDED       = 6
SYSTEM_FAILURE             = 7
COMMUNICATION_FAILURE      = 8
OTHERS                     = 9.

IF SY-SUBRC <> 0.
IF SY-SUBRC = 5.
*       Message - SM rfc user has no auth to read SMSY_PROD_VERS
CONCATENATE
'SM SM rfc user has no auth to read SMSY_PROD_VERS'
'table data from '
IV_RFCDEST
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ELSE.
LV_SUBRC = SY-SUBRC.
*       Message - function doesnt exist in SM
CONCATENATE
'SM Error reading SMSY products versions data from'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ENDIF.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
CT_SMSY_PROD_VERS[] = LT_TAB512[].
ENDIF.

CLEAR : LT_RFC_DB_OPT[], LT_RFC_DB_FLD[], LT_TAB512[].
*   SMSY_PRODUCT - product , text
CALL FUNCTION 'RFC_READ_TABLE'
DESTINATION IV_RFCDEST
EXPORTING
QUERY_TABLE                = 'SMSY_PRODUCT'
*       DELIMITER                  = ' '
*       NO_DATA                    = ' '
*       ROWSKIPS                   = 0
*       ROWCOUNT                   = 0
TABLES
OPTIONS                    = LT_RFC_DB_OPT
FIELDS                     = LT_RFC_DB_FLD
DATA                       = LT_TAB512
EXCEPTIONS
TABLE_NOT_AVAILABLE        = 1
TABLE_WITHOUT_DATA         = 2
OPTION_NOT_VALID           = 3
FIELD_NOT_VALID            = 4
NOT_AUTHORIZED             = 5
DATA_BUFFER_EXCEEDED       = 6
SYSTEM_FAILURE             = 7
COMMUNICATION_FAILURE      = 8
OTHERS                     = 9.

IF SY-SUBRC <> 0.
IF SY-SUBRC = 5.
"Message - SM rfc user has no auth to read SMSY_PRODUCT
CONCATENATE
'SM SM rfc user has no auth to read SMSY_PRODUCT'
'table data from'
IV_RFCDEST
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ELSE.
LV_SUBRC = SY-SUBRC.
"Message - function doesnt exist in SM
CONCATENATE 'SM Error reading SMSY products data from'
IV_RFCDEST
'RC:'
LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
ENDIF.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
CT_SMSY_PRODUCT[] = LT_TAB512[].
ENDIF.

*   For each system get system product version and product
LOOP AT IT_SMSY_SYSTEM INTO LS_SMSY_SYSTEM.
CLEAR : LS_SM_SYSTEM_PRODUCTS,
LS_SMSY_SYST_PRODVR,
LS_SMSY_PROD_VERS,
LS_SMSY_PRODUCT.

*     No product data fetched in systems data get from OSS or
*     SMSY_SYST_PRODVR
IF LS_SMSY_SYSTEM-PRODVERS IS INITIAL.
*       OSS data read
READ TABLE IT_AISYSNR_BUFFER
WITH KEY SYSNR = LS_SMSY_SYSTEM-SYSTEMNAME
INTO LS_AISYSNR_BUFFER.

IF SY-SUBRC IS INITIAL AND
NOT LS_AISYSNR_BUFFER-PRODVERS IS INITIAL.
LS_SMSY_SYSTEM-PRODVERS = LS_AISYSNR_BUFFER-PRODVERS.
ELSE.
*         SMSY settings - not always set
READ TABLE LT_SMSY_SYST_PRODVR
WITH KEY SYSTEMNAME = LS_SMSY_SYSTEM-SYSTEMNAME
VERSION = 'ACTIVE'
INTO LS_SMSY_SYST_PRODVR.
IF SY-SUBRC IS INITIAL AND
NOT LS_SMSY_SYST_PRODVR-PRODVERS IS INITIAL.
LS_SMSY_SYSTEM-PRODVERS = LS_SMSY_SYST_PRODVR-PRODVERS.
ENDIF.
ENDIF.
ENDIF.

*     Found the system product version
IF NOT LS_SMSY_SYSTEM-PRODVERS IS INITIAL.
*       Fetch product version text and product
LS_SM_SYSTEM_PRODUCTS-SYSTEMNAME = LS_SMSY_SYSTEM-SYSTEMNAME.
LS_SM_SYSTEM_PRODUCTS-PRODVERS = LS_SMSY_SYSTEM-PRODVERS.

READ TABLE CT_SMSY_PROD_VERS
WITH KEY PRODUCTVERSION = LS_SM_SYSTEM_PRODUCTS-PRODVERS
INTO LS_SMSY_PROD_VERS.
IF SY-SUBRC IS INITIAL.
LS_SM_SYSTEM_PRODUCTS-PRODVERSTXT =
LS_SMSY_PROD_VERS-PRODVERSTXT.
LS_SM_SYSTEM_PRODUCTS-PRODUCT = LS_SMSY_PROD_VERS-PRODUCT.

*         Get product text
READ TABLE CT_SMSY_PRODUCT
WITH KEY PRODUCT = LS_SM_SYSTEM_PRODUCTS-PRODUCT
INTO LS_SMSY_PRODUCT.
IF SY-SUBRC IS INITIAL.
LS_SM_SYSTEM_PRODUCTS-PRODUCTTXT =
LS_SMSY_PRODUCT-PRODUCTTXT.
ENDIF.
ENDIF.
APPEND LS_SM_SYSTEM_PRODUCTS TO CT_SM_SYSTEM_PRODUCTS.
ENDIF.
ENDLOOP.
ENDIF.

ENDFORM.                    " read_products
*&---------------------------------------------------------------------*
*&      Form  add_sm_data_to_xml
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_SMSY_SYSTEM  text
*      -->P_LT_SMSY_SYSTEM_SAP  text
*      -->P_LT_SMSY_SYST_CLIENT  text
*      -->P_LT_SM_SYSTEM_PRODUCTS  text
*      -->P_LT_SMSY_MAIN_INST_FINAL  text
*      -->P_LT_SMSYPROCOM_FINAL  text
*      -->P_LT_PAT03_FINAL  text
*      -->P_LT_AISYSNR_BUFFER  text
*      -->P_LT_SMSY_PRODUCT  text
*      -->P_LT_SMSY_PROD_VERS  text
*----------------------------------------------------------------------*
FORM ADD_SM_DATA_TO_XML USING IV_SM_SYSTEM_NODE TYPE XML_ELEMENT
IT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T
IT_SMSY_SYSTEM_SAP TYPE
SMSY_SYSTEM_SAP_T
IT_SMSY_SYST_CLIENT TYPE
SMSY_SYST_CLIENT_T
IT_SM_SYSTEM_PRODUCTS TYPE
SM_SYSTEM_PRODUCTS_T
IT_SMSY_MAIN_INST_FINAL TYPE
SMSY_MAIN_INST_SYST_T
IT_SMSYPROCOM_FINAL TYPE SMSYPROCOM_T
IT_PAT03_FINAL TYPE TY_SYST_PAT03_OUT_T
IT_AISYSNR_BUFFER TYPE AISYSNR_BUFFER_T.

DATA : LV_SMSY_SYSTEM_NODE TYPE XML_ELEMENT,
LV_SMSY_SYSTEM_SAP_NODE TYPE XML_ELEMENT,
LV_SMSY_SYST_CLIENT_NODE TYPE XML_ELEMENT,
LV_SMSY_MAIN_INST_FINAL_NODE TYPE XML_ELEMENT,
LV_SMSY_PRODUCTS_NODE TYPE XML_ELEMENT,
LV_SMSYPROCOM_FINAL_NODE TYPE XML_ELEMENT,
LV_PAT03_FINAL_NODE TYPE XML_ELEMENT,
LV_AISYSNR_BUFFER_NODE TYPE XML_ELEMENT.

IF NOT IT_SMSY_SYSTEM[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_DEFINED_SYSTEMS'
CHANGING LV_SMSY_SYSTEM_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_SYSTEM
USING G_IREF_PDOCUMENT
LV_SMSY_SYSTEM_NODE
'SM_DEFINED_SYSTEM'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_SMSY_SYSTEM_NODE 'X'.
ENDIF.
* !!!Add the products after systems the sm_defined systems
* !!!persisted in ETLloader on the system products proccessing
* !!!and the systems data is required for all the other SM proccessing
IF NOT IT_SM_SYSTEM_PRODUCTS[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_SYSTEMS_PRODUCTS'
CHANGING LV_SMSY_PRODUCTS_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SM_SYSTEM_PRODUCTS
USING G_IREF_PDOCUMENT
LV_SMSY_PRODUCTS_NODE
'SM_SYSTEMS_PRODUCT'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_SMSY_PRODUCTS_NODE 'X'.
ENDIF.

IF NOT IT_SMSY_SYSTEM_SAP[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_SAP_SYSTEMS'
CHANGING LV_SMSY_SYSTEM_SAP_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_SYSTEM_SAP
USING G_IREF_PDOCUMENT
LV_SMSY_SYSTEM_SAP_NODE
'SM_SAP_SYSTEM'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_SMSY_SYSTEM_SAP_NODE 'X'.
ENDIF.
IF NOT IT_SMSY_SYST_CLIENT[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_CLIENTS'
CHANGING LV_SMSY_SYST_CLIENT_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_SYST_CLIENT
USING G_IREF_PDOCUMENT
LV_SMSY_SYST_CLIENT_NODE
'SM_CLIENT'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_SMSY_SYST_CLIENT_NODE 'X'.
ENDIF.

IF NOT IT_SMSY_MAIN_INST_FINAL[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_PRODUCTS_INSTANCES'
CHANGING LV_SMSY_MAIN_INST_FINAL_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSY_MAIN_INST_FINAL
USING G_IREF_PDOCUMENT
LV_SMSY_MAIN_INST_FINAL_NODE
'SM_PRODUCTS_INSTANCE'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_SMSY_MAIN_INST_FINAL_NODE 'X'.
ENDIF.

IF NOT IT_SMSYPROCOM_FINAL[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_SYSTEMS_COMPONENTS'
CHANGING LV_SMSYPROCOM_FINAL_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_SMSYPROCOM_FINAL
USING G_IREF_PDOCUMENT
LV_SMSYPROCOM_FINAL_NODE
'SM_SYSTEM_COMPONENT'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_SMSYPROCOM_FINAL_NODE 'X'.
ENDIF.

IF NOT IT_PAT03_FINAL[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_SYSTEMS_PATCHES'
CHANGING LV_PAT03_FINAL_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_PAT03_FINAL
USING G_IREF_PDOCUMENT
LV_PAT03_FINAL_NODE
'SM_SYSTEM_PATCH'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_PAT03_FINAL_NODE 'X'.
ENDIF.

IF NOT IT_AISYSNR_BUFFER[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT IV_SM_SYSTEM_NODE
'SM_OSS_SETTINGS'
CHANGING LV_AISYSNR_BUFFER_NODE.
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES IT_AISYSNR_BUFFER
USING G_IREF_PDOCUMENT
LV_AISYSNR_BUFFER_NODE
'SM_SYSTEM_OSS'.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LV_AISYSNR_BUFFER_NODE 'X'.
ENDIF.

ENDFORM.                    " add_sm_data_to_xml
*&---------------------------------------------------------------------*
*&      Form  extract_layouts
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_LAYOUTS .

DATA : LV_LAYOUTS_NODE TYPE XML_ELEMENT,
LV_TNAPR_NODE TYPE XML_ELEMENT,
LV_T042E_NODE TYPE XML_ELEMENT,
LV_T042Z_NODE TYPE XML_ELEMENT,
LV_T390_NODE  TYPE XML_ELEMENT,
LV_TTXFP_NODE TYPE XML_ELEMENT,
LV_T001_NODE TYPE XML_ELEMENT,
LV_T001F_NODE TYPE XML_ELEMENT.

DATA : LT_TNAPR TYPE STANDARD TABLE OF TNAPR,
LT_T042E TYPE STANDARD TABLE OF T042E,
LT_T042Z TYPE STANDARD TABLE OF T042Z,
LT_T390  TYPE STANDARD TABLE OF T390,
LT_TTXFP TYPE STANDARD TABLE OF TTXFP,
LT_T001  TYPE STANDARD TABLE OF T001,
LT_T001F TYPE STANDARD TABLE OF T001F.

PERFORM UPDATE_PROGRESS USING 'Extracting layouts'.

* Create the layouts xml node
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
G_IREF_ROOT_ELEM
'LAYOUTS'
CHANGING LV_LAYOUTS_NODE.

PERFORM APPEND_STRING_TO_FILE USING '<LAYOUTS>'.

* Forms settings - tnapr table
SELECT *
FROM TNAPR
INTO CORRESPONDING FIELDS OF TABLE LT_TNAPR.

IF NOT LT_TNAPR[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LV_LAYOUTS_NODE
'TNAPR_TABLE'
CHANGING LV_TNAPR_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TNAPR
USING G_IREF_PDOCUMENT
LV_TNAPR_NODE
'TNAPR'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_TNAPR_NODE 'X'.
ENDIF.

* Forms settings - t042e , t042z tables
SELECT *
FROM T042E
INTO CORRESPONDING FIELDS OF TABLE LT_T042E.

IF NOT LT_T042E[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LV_LAYOUTS_NODE
'T042E_TABLE'
CHANGING LV_T042E_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T042E
USING G_IREF_PDOCUMENT
LV_T042E_NODE
'T042E'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T042E_NODE 'X'.
ENDIF.

SELECT *
FROM T042Z
INTO CORRESPONDING FIELDS OF TABLE LT_T042Z.

IF NOT LT_T042Z[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LV_LAYOUTS_NODE
'T042Z_TABLE'
CHANGING LV_T042Z_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T042Z
USING G_IREF_PDOCUMENT
LV_T042Z_NODE
'T042Z'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T042Z_NODE 'X'.
ENDIF.

* Forms settings - t390 , ttxfp , t001f tables
SELECT *
FROM T390
INTO CORRESPONDING FIELDS OF TABLE LT_T390.

IF NOT LT_T390[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LV_LAYOUTS_NODE
'T390_TABLE'
CHANGING LV_T390_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T390
USING G_IREF_PDOCUMENT
LV_T390_NODE
'T390'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T390_NODE 'X'.
ENDIF.

SELECT *
FROM TTXFP
INTO CORRESPONDING FIELDS OF TABLE LT_TTXFP.

IF NOT LT_TTXFP[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LV_LAYOUTS_NODE
'TTXFP_TABLE'
CHANGING LV_TTXFP_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_TTXFP
USING G_IREF_PDOCUMENT
LV_TTXFP_NODE
'TTXFP'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_TTXFP_NODE 'X'.
ENDIF.

* Get only company , company text , country
SELECT BUKRS BUTXT LAND1
FROM T001
INTO CORRESPONDING FIELDS OF TABLE LT_T001.

IF NOT LT_T001[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LV_LAYOUTS_NODE
'T001_TABLE'
CHANGING LV_T001_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T001
USING G_IREF_PDOCUMENT
LV_T001_NODE
'T001'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T001_NODE 'X'.
ENDIF.

SELECT *
FROM T001F
INTO CORRESPONDING FIELDS OF TABLE LT_T001F.

IF NOT LT_T001F[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LV_LAYOUTS_NODE
'T001F_TABLE'
CHANGING LV_T001F_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_T001F
USING G_IREF_PDOCUMENT
LV_T001F_NODE
'T001F'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_T001F_NODE 'X'.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '</LAYOUTS>'.

ENDFORM.                    " extract_layouts
*&---------------------------------------------------------------------*
*&      Form  add_layouts_usage
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TWO_YEARS_BACK  text
*----------------------------------------------------------------------*
FORM ADD_LAYOUTS_USAGE
USING IV_TWO_YEARS_BACK TYPE DATUM
IV_USAGE_NODE     TYPE XML_ELEMENT.

TYPES : BEGIN OF TY_NAST ,
KAPPL TYPE KAPPL,
KSCHL TYPE KSCHL,
NACHA TYPE NA_NACHA,
COUNT TYPE I,
END OF TY_NAST.
TYPES : BEGIN OF TY_PAYR ,
ZBUKR TYPE DZBUKR,
RZAWE TYPE DZLSCH,
COUNT TYPE I,
END OF TY_PAYR.
TYPES : BEGIN OF TY_REGUH,
ZBUKR TYPE DZBUKR,
RZAWE TYPE RZAWE,
COUNT TYPE I,
END OF TY_REGUH.

DATA : LT_T042E TYPE STANDARD TABLE OF T042E,
LS_T042E LIKE LINE OF LT_T042E,
LT_PAYR  TYPE STANDARD TABLE OF TY_PAYR,
LS_PAYR  LIKE LINE OF LT_PAYR,
LV_PAYR_NODE TYPE XML_ELEMENT.
DATA : LT_REGUH TYPE STANDARD TABLE OF TY_REGUH,
LS_REGUH LIKE LINE OF LT_REGUH,
LV_REGUH_NODE TYPE XML_ELEMENT.
DATA : LT_TNAPR TYPE STANDARD TABLE OF TNAPR,
LS_TNAPR LIKE LINE OF LT_TNAPR,
LV_WHERE1 TYPE SYCHAR72,
LV_WHERE2 TYPE SYCHAR72,
LV_WHERE3 TYPE SYCHAR72,
LV_WHERE4 TYPE SYCHAR72,
LV_VALUE  TYPE STRING,
LV_COUNT  TYPE SYDBCNT,
LT_NAST   TYPE STANDARD TABLE OF TY_NAST,
LS_NAST   LIKE LINE OF LT_NAST,
LV_NAST_NODE TYPE XML_ELEMENT,
LV_SIZE   TYPE I,
LV_TEXT   TYPE STRING.

* Layouts usage - nast table
SELECT *
FROM TNAPR
INTO CORRESPONDING FIELDS OF TABLE LT_TNAPR.
IF NOT SY-BATCH IS INITIAL.
DESCRIBE TABLE LT_TNAPR LINES LV_SIZE.
LV_TEXT = LV_SIZE.
CONCATENATE 'Layouts usage Number of layouts in TNAPR:'
LV_TEXT
INTO LV_TEXT SEPARATED BY SPACE.
MESSAGE S000(CONV) WITH LV_TEXT.
PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
ENDIF.

* Itterate per nast keys get usage two years back
LOOP AT LT_TNAPR INTO LS_TNAPR.
CLEAR : LV_WHERE1,
LV_WHERE2,
LV_WHERE3,
LV_WHERE4,
LV_VALUE.
IF NOT SY-BATCH IS INITIAL.
CONCATENATE 'Layouts usage Extracting TNAPR usage for:'
LS_TNAPR-KAPPL
LS_TNAPR-KSCHL
LS_TNAPR-NACHA
INTO LV_TEXT SEPARATED BY SPACE.
MESSAGE S000(CONV) WITH LV_TEXT.
PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
ENDIF.

*   Two years back
CONCATENATE 'ERDAT >'
IV_TWO_YEARS_BACK
'AND'
INTO LV_WHERE1 SEPARATED BY SPACE.

*   Get usage per tnapr key from nast
*   record key = kappl , kschl , nacha
CONCATENATE '''' LS_TNAPR-KAPPL  '''' INTO LV_VALUE.
CONCATENATE 'KAPPL ='
LV_VALUE
'AND'
INTO LV_WHERE2 SEPARATED BY SPACE.

CLEAR : LV_VALUE.
CONCATENATE '''' LS_TNAPR-KSCHL  '''' INTO LV_VALUE.
CONCATENATE 'KSCHL ='
LV_VALUE
'AND'
INTO LV_WHERE3 SEPARATED BY SPACE.

CLEAR : LV_VALUE.
CONCATENATE '''' LS_TNAPR-NACHA  '''' INTO LV_VALUE.
CONCATENATE 'NACHA ='
LV_VALUE
INTO LV_WHERE4 SEPARATED BY SPACE.

*   Get usage from prod two years back per record
CALL FUNCTION 'CATT_GET_TABLE_ENTRIES'
DESTINATION P_RFCDES
EXPORTING
TABLE         = 'NAST'
WHERE1        = LV_WHERE1
WHERE2        = LV_WHERE2
WHERE3        = LV_WHERE3
WHERE4        = LV_WHERE4
*       WHERE5        =
IMPORTING
ANZAHL        = LV_COUNT.

IF LV_COUNT > 0.
MOVE-CORRESPONDING LS_TNAPR TO LS_NAST.
LS_NAST-COUNT = LV_COUNT.
APPEND LS_NAST TO LT_NAST.
ENDIF.
ENDLOOP.

* Add nast to xml
IF NOT LT_NAST[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
IV_USAGE_NODE
'NAST_USAGE'
CHANGING LV_NAST_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_NAST
USING G_IREF_PDOCUMENT
LV_NAST_NODE
'NAST'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_NAST_NODE 'X'.
ENDIF.

* Get t042e - zbukr and zlsch = payr,reguh  - zbukr and rzawe
SELECT *
FROM T042E
INTO CORRESPONDING FIELDS OF TABLE LT_T042E.

IF NOT SY-BATCH IS INITIAL.
DESCRIBE TABLE LT_T042E LINES LV_SIZE.
LV_TEXT = LV_SIZE.
CONCATENATE 'Layouts usage Number of layouts in T042E:'
LV_TEXT
INTO LV_TEXT SEPARATED BY SPACE.
MESSAGE S000(CONV) WITH LV_TEXT.
PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
ENDIF.

* Itterate over each layout key get it's usage
LOOP AT LT_T042E INTO LS_T042E.

CLEAR : LV_WHERE1,
LV_WHERE2,
LV_WHERE3,
LV_VALUE.

IF NOT SY-BATCH IS INITIAL.
CONCATENATE 'Layouts usage Extracting T042E usage for:'
LS_T042E-ZBUKR
LS_T042E-ZLSCH
INTO LV_TEXT SEPARATED BY SPACE.
MESSAGE S000(CONV) WITH LV_TEXT.
PERFORM ADD_MESSAGE USING LV_TEXT ABAP_TRUE.
ENDIF.

*   Two years back
CONCATENATE 'PRIDT >'
IV_TWO_YEARS_BACK
'AND'
INTO LV_WHERE1 SEPARATED BY SPACE.

*   Key - zbukr = zbukr , rzawe = zlsch
CONCATENATE '''' LS_T042E-ZBUKR '''' INTO LV_VALUE.
CONCATENATE 'ZBUKR ='
LV_VALUE
'AND'
INTO LV_WHERE2 SEPARATED BY SPACE.

CLEAR : LV_VALUE.
CONCATENATE '''' LS_T042E-ZLSCH '''' INTO LV_VALUE.
CONCATENATE 'RZAWE ='
LV_VALUE
INTO LV_WHERE3 SEPARATED BY SPACE.

*   Get data from prod two years back per current key
CALL FUNCTION 'CATT_GET_TABLE_ENTRIES'
DESTINATION P_RFCDES
EXPORTING
TABLE         = 'PAYR'
WHERE1        = LV_WHERE1
WHERE2        = LV_WHERE2
WHERE3        = LV_WHERE3
*       where4        =
*       WHERE5        =
IMPORTING
ANZAHL        = LV_COUNT.

IF LV_COUNT > 0.
LS_PAYR-ZBUKR = LS_T042E-ZBUKR.
LS_PAYR-RZAWE = LS_T042E-ZLSCH.
LS_PAYR-COUNT = LV_COUNT.
APPEND LS_PAYR TO LT_PAYR.
ENDIF.

*   For reguh the date filed is laufd
*   Two years back
CLEAR : LV_WHERE1.
CONCATENATE 'LAUFD >'
IV_TWO_YEARS_BACK
'AND'
INTO LV_WHERE1 SEPARATED BY SPACE.

*   The key fields are the same for reguh
*   as for payr - zbukr and rzawe , use the previous wheres
CALL FUNCTION 'CATT_GET_TABLE_ENTRIES'
DESTINATION P_RFCDES
EXPORTING
TABLE         = 'REGUH'
WHERE1        = LV_WHERE1
WHERE2        = LV_WHERE2
WHERE3        = LV_WHERE3
*       where4        =
*       WHERE5        =
IMPORTING
ANZAHL        = LV_COUNT.

IF LV_COUNT > 0.
LS_REGUH-ZBUKR = LS_T042E-ZBUKR.
LS_REGUH-RZAWE = LS_T042E-ZLSCH.
LS_REGUH-COUNT = LV_COUNT.
APPEND LS_REGUH TO LT_REGUH.
ENDIF.
ENDLOOP.

* Add payr and reguh usage data to xml
IF NOT LT_PAYR[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
IV_USAGE_NODE
'PAYR_USAGE'
CHANGING LV_PAYR_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_PAYR
USING G_IREF_PDOCUMENT
LV_PAYR_NODE
'PAYR'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_PAYR_NODE 'X'.
ENDIF.

IF NOT LT_REGUH[] IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
IV_USAGE_NODE
'REGUH_USAGE'
CHANGING LV_REGUH_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_REGUH
USING G_IREF_PDOCUMENT
LV_REGUH_NODE
'REGUH'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING LV_REGUH_NODE 'X'.
ENDIF.

ENDFORM.                    " add_layouts_usage
*&---------------------------------------------------------------------*
*&      Form  check_sm_rfc_dest
*&---------------------------------------------------------------------*
FORM CHECK_SM_RFC_DEST
USING IV_RFC_DEST TYPE RFCDEST
IV_VALIDATE TYPE FLAG
CHANGING EV_VALID TYPE FLAG.

DATA : LV_ERR_MSG     TYPE STRING,
LT_TAB512      TYPE STANDARD TABLE OF TAB512,
LT_SMSY_SYSTEM TYPE SMSY_SYSTEM_T,
IV_AUTH_PROBLEM,
MESSAGE TYPE RFCLOG_D.

CLEAR G_EXTRACT_UPL.

* SM RFC entered
CHECK NOT IV_RFC_DEST IS INITIAL.

PERFORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST
IV_VALIDATE
CHANGING EV_VALID
SM_SYSID
SM_SAPRL.
* Continue to the solman checks only if the RFC is valid
CHECK NOT EV_VALID IS INITIAL.

* Check sm functions are available
PERFORM READ_SOLMAN_FUNCTIONS TABLES LT_TAB512
USING  IV_RFC_DEST
IV_VALIDATE
CHANGING EV_VALID.

READ TABLE LT_TAB512 WITH KEY WA =
'SMSY_GET_ALL_SYSTEMS_INFO'
TRANSPORTING NO FIELDS.

IF NOT SY-SUBRC IS INITIAL.
IF IV_VALIDATE IS INITIAL.
"Message - function doesnt exist in SM
CONCATENATE
'Could not read Solution Manager functions in'
IV_RFC_DEST
INTO LV_ERR_MSG SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ENDIF.

* Check able to get SMSY systems from SM
CALL FUNCTION 'SMSY_GET_ALL_SYSTEMS_INFO'
DESTINATION IV_RFC_DEST
*   EXPORTING
*     NO_KONZS            = ' '
*     IV_SYSTEMTYPE       =
IMPORTING
SYSTEMS             = LT_SMSY_SYSTEM
EXCEPTIONS
SYSTEM_FAILURE        = 1
COMMUNICATION_FAILURE = 2.

IF NOT SY-SUBRC IS INITIAL.
IF IV_VALIDATE IS INITIAL.
"Message - function doesnt exist in SM
CONCATENATE
'Failed to execute SMSY_GET_ALL_SYSTEMS_INFO in'
IV_RFC_DEST
INTO LV_ERR_MSG SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ENDIF.
IF LT_SMSY_SYSTEM[] IS INITIAL.
IF IV_VALIDATE IS INITIAL.
"Message - function doesnt exist in SM
CONCATENATE
'No SMSY systems defined in'
IV_RFC_DEST
INTO LV_ERR_MSG SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ENDIF.

* If there is a valid solman system, then check if there is upl data
* Check that UPL function exists
IF NOT EXTRACT_UPL_DATA IS INITIAL.
READ TABLE LT_TAB512 WITH KEY WA =
'RSDRI_INFOPROV_READ_RFC'
TRANSPORTING NO FIELDS.

IF NOT SY-SUBRC IS INITIAL.
IF IV_VALIDATE IS INITIAL.
"Message - UPL function doesnt exist in SM
CONCATENATE
'Could not read UPL Solution Manager functions in'
IV_RFC_DEST
INTO LV_ERR_MSG SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ENDIF.
ENDIF.


* Check authorization to UPL Data
PERFORM CHECK_UPL_EXISTENCE USING IV_RFC_DEST
CHANGING IV_AUTH_PROBLEM.
IF IV_AUTH_PROBLEM = 'X'.
IF IV_VALIDATE IS INITIAL.
"Message - No authorization to execute UPL function
CONCATENATE
'No authorization to execute UPL function in '
IV_RFC_DEST
INTO LV_ERR_MSG SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.

*   If there is no valid solman system then there is no upl data
IF EV_VALID = ABAP_FALSE.
CLEAR G_EXTRACT_UPL.
ENDIF.
ENDIF.


IF EXTRACT_SOLAR_DATA = 'X'.
*   Check if the hierarchy function exists in the destination
READ TABLE LT_TAB512 WITH KEY WA =
'SASAP_HIERARCHY_READ'
TRANSPORTING NO FIELDS.

IF NOT SY-SUBRC IS INITIAL.
IF IV_VALIDATE IS INITIAL.
"Message - UPL function doesnt exist in SM
CONCATENATE
'Could not read hierarchy functions for business process in'
IV_RFC_DEST
INTO LV_ERR_MSG SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ELSE.
PERFORM CHECK_BUSINESS_PROCESS_AUTH USING IV_RFC_DEST
CHANGING IV_AUTH_PROBLEM
MESSAGE.
IF IV_AUTH_PROBLEM = 'X'.
IF IV_VALIDATE IS INITIAL.
"Message - No authorization to execute UPL function
*        CONCATENATE
*        'No authorization to execute hierarchy function in '
*        IV_RFC_DEST
*        INTO LV_ERR_MSG SEPARATED BY SPACE.
LV_ERR_MSG = MESSAGE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.

*     If there is no valid solman system then there is no upl data
IF EV_VALID = ABAP_FALSE.
CLEAR G_EXTRACT_UPL.
ENDIF.
ENDIF..
ENDIF.
*   Check the accessibility for all of the tables of solman

PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'TOBJECTP' IV_RFC_DEST.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'BMTNODE01R' IV_RFC_DEST.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'BMTNODE01' IV_RFC_DEST.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'DFURLS' IV_RFC_DEST.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'AGS_TBOM_HEAD' IV_RFC_DEST.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'AGS_TBOM_BASE' IV_RFC_DEST.
ENDIF.
ENDFORM.                    " check_sm_rfc_dest
*&---------------------------------------------------------------------*
*&      Form  extract_users
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM EXTRACT_USERS.

TYPES: BEGIN OF USER_DATA,
BNAME LIKE USR02-BNAME,
GLTGV LIKE USR02-GLTGV,
GLTGB LIKE USR02-GLTGB,
USTYP LIKE USR02-USTYP,
TRDAT LIKE USR02-TRDAT,
LTIME LIKE USR02-LTIME,
END OF USER_DATA.

DATA: OPTIONS TYPE TABLE OF RFC_DB_OPT,
FIELD TYPE RFC_DB_FLD,
FIELDS TYPE TABLE OF RFC_DB_FLD,
USR02_ITAB TYPE TABLE OF USER_DATA,
L_STARTTIME LIKE SY-UZEIT.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Active Users'.

* Choose fields for selection
FIELD-FIELDNAME = 'BNAME'.
APPEND FIELD TO FIELDS.
FIELD-FIELDNAME = 'GLTGV'.
APPEND FIELD TO FIELDS.
FIELD-FIELDNAME = 'GLTGB'.
APPEND FIELD TO FIELDS.
FIELD-FIELDNAME = 'USTYP'.
APPEND FIELD TO FIELDS.
FIELD-FIELDNAME = 'TRDAT'.
APPEND FIELD TO FIELDS.
FIELD-FIELDNAME = 'LTIME'.
APPEND FIELD TO FIELDS.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE = 'USR02'
DELIMITER   = SPACE
NO_DATA     = SPACE
ROWSKIPS    = 0
ROWCOUNT    = 0
TABLES
OPTIONS     = OPTIONS
FIELDS      = FIELDS
DATA        = USR02_ITAB
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC IS INITIAL.
PERFORM APPEND_STRING_TO_FILE USING '<ACTIVE_USERS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES USR02_ITAB
USING G_IREF_PDOCUMENT
'USR02'.
PERFORM APPEND_STRING_TO_FILE USING '</ACTIVE_USERS>'.
ELSE.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extraction of USR02 from ' P_RFCDES
' failed. Error: ' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

FREE USR02_ITAB.

PERFORM ADD_TIME_STAT USING 'Extract Active Users' L_STARTTIME.

ENDFORM.                    " extract_users

*&---------------------------------------------------------------------*
*&      Form  extract_bw_extractors
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_BW_EXTRACTORS.

TYPES: BEGIN OF T_TEXT,
OLTPSOURCE TYPE CHAR30,
OBJVERS TYPE CHAR1,
LANGU TYPE CHAR1,
TXTSH TYPE CHAR20,
TXTMD TYPE CHAR40,
TXTLG TYPE CHAR_60,
END OF T_TEXT.

DATA: LS_FCAT TYPE LVC_S_FCAT,
LT_FCAT TYPE LVC_T_FCAT,
FIELD_CATALOG TYPE SLIS_T_FIELDCAT_ALV,
ROOSOURCE_ITAB TYPE REF TO DATA,
L_STARTTIME LIKE SY-UZEIT,
TEMP_DD02L TYPE DD02L.

DATA: LT_TEXT TYPE TABLE OF T_TEXT.

RANGES: R_OBJ_OSOA_D FOR RSEUI_SET-OBJ_NAME.

FIELD-SYMBOLS: <ROOSOURCE_ITAB> TYPE STANDARD TABLE,
<FIELD_CATALOG> TYPE SLIS_FIELDCAT_ALV,
<OBJ_OSOA_D> LIKE LINE OF GT_OBJ_OSOA_D,
<ROOSOURCE_LINE> TYPE ANY,
<OLTPSOURCE_VALUE> TYPE ANY.

CHECK VANILLA = ''.

SELECT SINGLE *
FROM DD02L
INTO TEMP_DD02L
WHERE TABNAME = 'ROOSOURCE'.

CHECK SY-SUBRC IS INITIAL.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting BW Extractors'.

CALL FUNCTION 'REUSE_ALV_FIELDCATALOG_MERGE'
EXPORTING
I_STRUCTURE_NAME       = 'ROOSOURCE'
CHANGING
CT_FIELDCAT            = FIELD_CATALOG
EXCEPTIONS
INCONSISTENT_INTERFACE = 1
PROGRAM_ERROR          = 2
OTHERS                 = 3.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'INCONSISTENT_INTERFACE'.
WHEN 2. ERROR = 'PROGRAM_ERROR'.
WHEN 3. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE
'extract BW extractors: REUSE_ALV_FIELDCATALOG_MERGE'
'of structure ROOSOURCE.' 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

ELSE.
LOOP AT FIELD_CATALOG ASSIGNING <FIELD_CATALOG>.
CLEAR LS_FCAT.
MOVE-CORRESPONDING <FIELD_CATALOG> TO LS_FCAT.
APPEND LS_FCAT TO LT_FCAT.
ENDLOOP.

CALL METHOD CL_ALV_TABLE_CREATE=>CREATE_DYNAMIC_TABLE
EXPORTING
IT_FIELDCATALOG           = LT_FCAT
IMPORTING
EP_TABLE                  = ROOSOURCE_ITAB.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'GENERATE_SUBPOOL_DIR_FULL'.
WHEN 2. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE
'extract BW extractors: create_dynamic_table'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
ASSIGN ROOSOURCE_ITAB->* TO <ROOSOURCE_ITAB>.

CHECK NOT GT_OBJ_OSOA_D[] IS INITIAL.
LOOP AT GT_OBJ_OSOA_D ASSIGNING <OBJ_OSOA_D>.
CLEAR R_OBJ_OSOA_D.
R_OBJ_OSOA_D-SIGN = 'I'.
R_OBJ_OSOA_D-OPTION = 'EQ'.
R_OBJ_OSOA_D-LOW = <OBJ_OSOA_D>-OBJ_NAME.
APPEND R_OBJ_OSOA_D.
ENDLOOP.

*     We identify customer extractors only by it's name Z*, Y*
*     and not by devclass, because when a user activates an
*     extractor, he attaches it to a customer devclass although it's
*     a standard extractor
SELECT * FROM ('ROOSOURCE')
INTO CORRESPONDING FIELDS OF TABLE <ROOSOURCE_ITAB>.

SELECT OLTPSOURCE OBJVERS LANGU TXTSH TXTMD TXTLG
FROM ('ROOSOURCET')
INTO CORRESPONDING FIELDS OF TABLE LT_TEXT.

DELETE LT_TEXT WHERE NOT OLTPSOURCE IN R_OBJ_OSOA_D.

*     Logic changed to selecting all data from ROOSOURCE and then
*     delete the irrelevant data.
*     This is bacause in some versions the type of rseui_set-obj_name
*     was changed in length, and FOR ALL ENTRIES got a dump for
*     incompatible types in WHERE clause.
LOOP AT <ROOSOURCE_ITAB> ASSIGNING <ROOSOURCE_LINE>.
ASSIGN COMPONENT 'OLTPSOURCE' OF STRUCTURE <ROOSOURCE_LINE>
TO <OLTPSOURCE_VALUE>.

IF NOT <OLTPSOURCE_VALUE> IN R_OBJ_OSOA_D.
DELETE <ROOSOURCE_ITAB>.
ENDIF.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<BW_EXTRACTORS>'.

PERFORM APPEND_STRING_TO_FILE USING '<BW_DATA>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES <ROOSOURCE_ITAB>
USING G_IREF_PDOCUMENT
'ROOSOURCE'.
PERFORM APPEND_STRING_TO_FILE USING '</BW_DATA>'.

PERFORM APPEND_STRING_TO_FILE USING '<BW_TEXT>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TEXT
USING G_IREF_PDOCUMENT
'ROOSOURCET'.
PERFORM APPEND_STRING_TO_FILE USING '</BW_TEXT>'.

PERFORM APPEND_STRING_TO_FILE USING '</BW_EXTRACTORS>'.

ENDIF.
ENDIF.

PERFORM ADD_TIME_STAT USING 'Extract BW Extractors' L_STARTTIME.

ENDFORM.                    " extract_bw_extractors

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_VANILLA_TABL_CUST_INDX
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_VANILLA_TABL_CUST_INDX.

CHECK NO_SUET_DATA IS INITIAL.
DATA: LT_DD12V   TYPE TABLE OF DD12V,
L_STARTTIME LIKE SY-UZEIT.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS
USING 'Extracting vanilla tables customer indexes'.

* Get Table Indexes 'DD12V'
PERFORM APPEND_STRING_TO_FILE
USING '<VANILLA_TABLE_CUSTOMER_INDEXES>'.

SELECT SQLTAB INDEXNAME DDLANGUAGE DDTEXT FROM DD12V
INTO CORRESPONDING FIELDS OF TABLE LT_DD12V PACKAGE SIZE PAC_SIZE
WHERE NOT AS4USER IN ('SAP','DDIC')
AND DDLANGUAGE IN ('E',SY-LANGU).

DELETE LT_DD12V[] WHERE SQLTAB IN G_TABNAME_INDEX.

SORT LT_DD12V BY SQLTAB INDEXNAME DDLANGUAGE.
DELETE ADJACENT DUPLICATES FROM LT_DD12V
COMPARING SQLTAB INDEXNAME DDLANGUAGE.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_DD12V
USING  G_IREF_PDOCUMENT
'DD12V'.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE
USING '</VANILLA_TABLE_CUSTOMER_INDEXES>'.

PERFORM ADD_TIME_STAT
USING 'Extract vanilla tables customer indexes' L_STARTTIME.

FREE G_TABNAME_INDEX[].


ENDFORM.                    " EXTRACT_VANILLA_TABL_CUST_INDX

*&---------------------------------------------------------------------*
*&      Form  GET_PROGRAM_VARIANTS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM GET_PROGRAM_VARIANTS  USING  PT_PROGRAM_NODE TYPE HANDLES_TYPE.

DATA: TEXTS_NODE   TYPE XML_ELEMENT,
LT_VARID     TYPE TABLE OF VARID.

CHECK NO_SUET_DATA IS INITIAL.
FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP.

*   Create a node for the Program Variants
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'VARIANTS'
CHANGING TEXTS_NODE.

ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.

SELECT REPORT VARIANT
FROM   VARID
INTO CORRESPONDING FIELDS OF TABLE LT_VARID
WHERE  REPORT = <LS_PROG>-NAME.

IF NOT LT_VARID[] IS INITIAL.
*     Add the Variants data to the current program
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES LT_VARID
USING G_IREF_PDOCUMENT
TEXTS_NODE 'VARID'.
ENDIF.

ENDFORM.                    " GET_PROGRAM_VARIANTS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_VANILLA_PROG_CUST_VARI
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_VANILLA_PROG_CUST_VARI.

CHECK NO_SUET_DATA IS INITIAL.

DATA: LT_VARID TYPE TABLE OF VARID,
LT_TEMP  TYPE TABLE OF TADIR,
L_STARTTIME LIKE SY-UZEIT.

FIELD-SYMBOLS: <VARID> LIKE LINE OF LT_VARID,
<CUST_PROG> LIKE LINE OF G_CUST_PROGS.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS
USING 'Extracting vanilla programs customer variants'.

* Get Programs Variants 'VARID'
PERFORM APPEND_STRING_TO_FILE
USING '<VANILLA_PROGRAMS_CUSTOMER_VARIANTS>'.

SELECT REPORT VARIANT FROM VARID
INTO CORRESPONDING FIELDS OF TABLE LT_VARID PACKAGE SIZE PAC_SIZE
WHERE ENAME <> 'SAP'.

DELETE LT_VARID[] WHERE REPORT IN G_CUST_PROGS.

IF NOT LT_VARID[] IS INITIAL.
*     Get local programs to delete it's variants
CLEAR LT_TEMP[].
SELECT * FROM TADIR
INTO TABLE LT_TEMP
FOR ALL ENTRIES IN LT_VARID
WHERE OBJ_NAME = LT_VARID-REPORT
AND PGMID = 'R3TR'
AND OBJECT = 'PROG'
AND DEVCLASS = '$TMP'.

IF SY-SUBRC = 0.
LOOP AT LT_VARID ASSIGNING <VARID>.
READ TABLE LT_TEMP WITH KEY OBJ_NAME = <VARID>-REPORT
TRANSPORTING NO FIELDS.
IF SY-SUBRC = 0.
DELETE LT_VARID[].
ENDIF.
ENDLOOP.
ENDIF.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_VARID
USING  G_IREF_PDOCUMENT
'VARID'.
ENDIF.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE
USING '</VANILLA_PROGRAMS_CUSTOMER_VARIANTS>'.

PERFORM ADD_TIME_STAT
USING 'Extract vanilla programs customer variants' L_STARTTIME.

FREE G_CUST_PROGS.

ENDFORM.                    " EXTRACT_VANILLA_PROG_CUST_VARI

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_AREA_MENUS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_AREA_MENUS.

DATA: TTREE_ITAB TYPE TABLE OF TTREE,
TTREE_LINE LIKE LINE OF TTREE_ITAB,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_OBJ_SHI3 FOR TTREE-ID.

FIELD-SYMBOLS: <OBJ_SHI3> LIKE LINE OF GT_OBJ_SHI3.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Area Menus'.

CHECK NOT GT_OBJ_SHI3[] IS INITIAL.

LOOP AT GT_OBJ_SHI3 ASSIGNING <OBJ_SHI3>.
CLEAR R_OBJ_SHI3.
R_OBJ_SHI3-SIGN = 'I'.
R_OBJ_SHI3-OPTION = 'EQ'.
R_OBJ_SHI3-LOW = <OBJ_SHI3>-OBJ_NAME.
APPEND R_OBJ_SHI3.
ENDLOOP.

SELECT ID
FROM TTREE
INTO CORRESPONDING FIELDS OF TABLE TTREE_ITAB
FOR ALL ENTRIES IN R_OBJ_SHI3
WHERE ID = R_OBJ_SHI3-LOW
AND   TYPE = 'BMENU'.

PERFORM APPEND_STRING_TO_FILE USING '<AREA_MENUS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES TTREE_ITAB
USING G_IREF_PDOCUMENT
'TTREE'.
PERFORM APPEND_STRING_TO_FILE USING '</AREA_MENUS>'.

FREE: GT_OBJ_SHI3.

PERFORM ADD_TIME_STAT USING 'Extract Area Menus' L_STARTTIME.

ENDFORM.                    " EXTRACT_AREA_MENUS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_SALES_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_SALES_USER_EXITS.

DATA: LT_SMODILOG TYPE TABLE OF SMODILOG,
LT_TEMP TYPE TABLE OF TADIR,
L_STARTTIME LIKE SY-UZEIT.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting Sales User Exits'.

SELECT OBJ_NAME FROM TADIR
INTO CORRESPONDING FIELDS OF TABLE LT_TEMP
WHERE PGMID = 'R3TR'
AND OBJECT = 'PROG'
AND DEVCLASS = 'VMOD'.

CHECK NOT LT_TEMP[] IS INITIAL.

PERFORM APPEND_STRING_TO_FILE USING '<SALES_USER_EXITS>'.

* Get Sales User Exits
SELECT OBJ_NAME INT_NAME FROM SMODILOG PACKAGE SIZE PAC_SIZE
INTO CORRESPONDING FIELDS OF TABLE LT_SMODILOG
FOR ALL ENTRIES IN LT_TEMP
WHERE OBJ_NAME = LT_TEMP-OBJ_NAME
AND OBJ_TYPE = 'PROG'
AND SUB_TYPE = 'REPS'
AND INT_TYPE = 'PU'.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SMODILOG
USING  G_IREF_PDOCUMENT
'SALES_UE'.

ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</SALES_USER_EXITS>'.

PERFORM ADD_TIME_STAT USING 'Extract Sales User Exits' L_STARTTIME.

ENDFORM.                    " EXTRACT_SALES_USER_EXITS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_BADI_IMP
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_BADI_IMP.

DATA: LT_SXC_EXIT TYPE TABLE OF SXC_EXIT,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_SXCI FOR SXC_EXIT-IMP_NAME.

FIELD-SYMBOLS: <OBJ_SXCI> LIKE LINE OF GT_OBJ_SXCI.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting BADI implementations'.

CHECK NOT GT_OBJ_SXCI[] IS INITIAL.

LOOP AT GT_OBJ_SXCI ASSIGNING <OBJ_SXCI>.
CLEAR R_SXCI.
R_SXCI-SIGN = 'I'.
R_SXCI-OPTION = 'EQ'.
R_SXCI-LOW = <OBJ_SXCI>-OBJ_NAME.
APPEND R_SXCI.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<BADI_IMPLEMENTATIONS>'.

* Get BADI implementations
SELECT IMP_NAME EXIT_NAME FROM SXC_EXIT PACKAGE SIZE PAC_SIZE
INTO CORRESPONDING FIELDS OF TABLE LT_SXC_EXIT
FOR ALL ENTRIES IN R_SXCI
WHERE IMP_NAME = R_SXCI-LOW.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXC_EXIT
USING  G_IREF_PDOCUMENT
'SXC_EXIT'.

ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</BADI_IMPLEMENTATIONS>'.
FREE GT_OBJ_SXCI.
PERFORM ADD_TIME_STAT
USING 'Extract BADI implementations' L_STARTTIME.

ENDFORM.                    " EXTRACT_BADI_IMP

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_VOFM_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_VOFM_USER_EXITS.

TYPES: BEGIN OF T_VOFM,
GRPZE  TYPE CHAR4,
DDTEXT TYPE DDTEXT,
GRPNO  TYPE NUMC3,
KAPPL  TYPE CHAR2,
BEZEI  TYPE CHAR20,
END OF T_VOFM.

DATA: LT_VOFM  TYPE TABLE OF T_VOFM,
LT_TFRM  TYPE TABLE OF TFRM,
LS_TFRM  TYPE TFRM,
LT_DOM_V TYPE TABLE OF RPY_DVAL,
LS_DOM_V TYPE RPY_DVAL,
L_STARTTIME LIKE SY-UZEIT.

FIELD-SYMBOLS: <VOFM> TYPE T_VOFM.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting VOFM User Exits'.

PERFORM APPEND_STRING_TO_FILE USING '<VOFM_USER_EXITS>'.

* Get VOFM User Exits
SELECT * FROM TFRM
INTO TABLE LT_TFRM
WHERE AKTIV = 'X'   " Only Active
AND GRPNO >= 900.

IF SY-SUBRC = 0.

*   Get texts
SELECT GRPZE GRPNO BEZEI FROM TFRMT
INTO CORRESPONDING FIELDS OF TABLE LT_VOFM
FOR ALL ENTRIES IN LT_TFRM
WHERE GRPZE = LT_TFRM-GRPZE
AND GRPNO = LT_TFRM-GRPNO
AND SPRAS = SY-LANGU.

IF SY-SUBRC = 0.

*     Get domain texts
CALL FUNCTION 'RPY_DOMAIN_READ'
EXPORTING
DOMA_NAME        = 'GRPZE'
TABLES
DOMA_VALUES      = LT_DOM_V
EXCEPTIONS
CANCELLED        = 1
NOT_FOUND        = 2
PERMISSION_ERROR = 3
ILLEGAL_TYPE     = 4
OTHERS           = 5.

IF SY-SUBRC <> 0.
CASE SY-SUBRC.
WHEN 1. ERROR = 'CANCELLED'.
WHEN 2. ERROR = 'NOT_FOUND'.
WHEN 3. ERROR = 'PERMISSION_ERROR'.
WHEN 4. ERROR = 'ILLEGAL_TYPE'.
WHEN 5. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extract VOFM: RPY_DOMAIN_READ of GRPZE.'
'ERROR:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED
BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

ELSE.

LOOP AT LT_VOFM ASSIGNING <VOFM>.
READ TABLE LT_TFRM INTO LS_TFRM WITH KEY GRPZE = <VOFM>-GRPZE
GRPNO = <VOFM>-GRPNO.
IF SY-SUBRC = 0.
<VOFM>-KAPPL = LS_TFRM-KAPPL.
ENDIF.

READ TABLE LT_DOM_V INTO LS_DOM_V
WITH KEY DOMVALUE_L = <VOFM>-GRPZE.
IF SY-SUBRC = 0.
<VOFM>-DDTEXT = LS_DOM_V-DDTEXT.
ENDIF.
ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_VOFM
USING  G_IREF_PDOCUMENT
'VOFM'.
ENDIF.
ENDIF.
ENDIF.

PERFORM APPEND_STRING_TO_FILE USING '</VOFM_USER_EXITS>'.

PERFORM ADD_TIME_STAT
USING 'Extract VOFM User Exits' L_STARTTIME.

ENDFORM.                    " EXTRACT_VOFM_USER_EXITS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_LSMW
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_LSMW.

TYPES: BEGIN OF T_LSMW_OBJ,
PROJECT         TYPE CHAR15,
SUBPROJ         TYPE CHAR15,
OBJECT          TYPE CHAR15,
OBJECTTYPE      TYPE CHAR2,
DXOBJ           TYPE CHAR4,
SUBDX           TYPE CHAR4,
BUSOBJ          TYPE CHAR10,
METHOD          TYPE CHAR32,
MESSTYPE        TYPE CHAR30,
IDOCTYPE        TYPE CHAR30,
CIMTYPE         TYPE CHAR30,
PROGRAMNUMBER   TYPE CHAR8,
OWNER           TYPE CHAR12,
X_ONETIME       TYPE CHAR1,
X_PERIODIC      TYPE CHAR1,
UNAME           TYPE CHAR12,
DATUM           TYPE DATUM,
SYSTEMDEPENDENT TYPE CHAR1,
EDIDC40         TYPE CHAR1,
END OF T_LSMW_OBJ.

DATA: L_STARTTIME LIKE SY-UZEIT,
TEMP_DD02L TYPE DD02L,
LT_LSMW_OBJS TYPE TABLE OF T_LSMW_OBJ.

SELECT SINGLE * FROM DD02L
INTO TEMP_DD02L
WHERE TABNAME = '/SAPDMC/LSOATT'.

CHECK SY-SUBRC IS INITIAL.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting LSMW objects'.

SELECT * FROM ('/SAPDMC/LSOATT')
INTO TABLE LT_LSMW_OBJS.

PERFORM APPEND_STRING_TO_FILE USING '<LSMW_OBJECTS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LSMW_OBJS
USING G_IREF_PDOCUMENT
'LSMW'.
PERFORM APPEND_STRING_TO_FILE USING '</LSMW_OBJECTS>'.

PERFORM ADD_TIME_STAT USING 'Extract LSMW objects' L_STARTTIME.

ENDFORM.                    " EXTRACT_LSMW

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_LANDSCAPE_DETAILS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_LANDSCAPE_DETAILS.

DATA: L_STARTTIME  LIKE SY-UZEIT,
LT_LANDSCAPE TYPE TABLE OF TMSCSYS.


L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Landscape Details'.

SELECT * FROM TMSCSYS
INTO TABLE LT_LANDSCAPE
WHERE INSTNR <> SPACE.

PERFORM APPEND_STRING_TO_FILE USING '<LANDSCAPE_DETAILS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LANDSCAPE
USING G_IREF_PDOCUMENT
'LANDSCAPE'.
PERFORM APPEND_STRING_TO_FILE USING '</LANDSCAPE_DETAILS>'.

PERFORM ADD_TIME_STAT USING 'Extract Landscape Details' L_STARTTIME.

ENDFORM.                    " EXTRACT_LANDSCAPE_DETAILS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_GATEWAY_CONNECTIONS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_GATEWAY_CONNECTIONS.

DATA: L_STARTTIME LIKE SY-UZEIT,
LT_GATEWAY  TYPE TABLE OF GWY_CONN,

LV_HOST   TYPE GWY_LHOST,
LV_SERV   TYPE GWY_SERV,
LV_SYSTEM TYPE CHAR2.


L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Gateway Connections'.

* Get Host&Server Parameters
CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'SAPLOCALHOST'
ID 'VALUE' FIELD LV_HOST.

IF SY-SUBRC <> 0.
ERROR = SY-SUBRC.
CONCATENATE 'Extract Gateway connections - Getting Host Param.'
'SY-SUBRC:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'SAPSYSTEM'
ID 'VALUE' FIELD LV_SYSTEM.

IF SY-SUBRC <> 0.
ERROR = SY-SUBRC.
CONCATENATE 'Extract Gateway connections - Getting System Param.'
'SY-SUBRC:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
LV_SERV   = 'sapgw'.
LV_SERV+5 = LV_SYSTEM.
ENDIF.

CALL FUNCTION 'GWY_READ_CONNECTIONS'
EXPORTING
GWHOST                    = LV_HOST
GWSERV                    = LV_SERV
TABLES
CONNECTIONS               = LT_GATEWAY
EXCEPTIONS
GWY_UNKNOWN_OPCODE        = 1
GWY_COMMUNICATION_FAILURE = 2
GWY_GET_TAB_FAILED        = 3
GWY_NEWLINE_FAILED        = 4
GWY_TABLEN_TOO_SHORT      = 5
GWY_GET_OPCODE_FAILED     = 6
GWY_GET_GWHOST_FAILED     = 7
GWY_GET_GWSERV_FAILED     = 8
GWY_MONITOR_DISABLED      = 9
OTHERS                    = 10.

IF SY-SUBRC <> 0.
CASE SY-SUBRC.
WHEN 1.  ERROR = 'GWY_UNKNOWN_OPCODE'.
WHEN 2.  ERROR = 'GWY_COMMUNICATION_FAILURE'.
WHEN 3.  ERROR = 'GWY_GET_TAB_FAILED'.
WHEN 4.  ERROR = 'GWY_NEWLINE_FAILED'.
WHEN 5.  ERROR = 'GWY_TABLEN_TOO_SHORT'.
WHEN 6.  ERROR = 'GWY_GET_OPCODE_FAILED'.
WHEN 7.  ERROR = 'GWY_GET_GWHOST_FAILED'.
WHEN 8.  ERROR = 'GWY_GET_GWSERV_FAILED'.
WHEN 9.  ERROR = 'GWY_MONITOR_DISABLED'.
WHEN 10. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extract Gateway connections - GWY_READ_CONNECTIONS:'
'Host:' LV_HOST 'Serv:' LV_SERV 'Error:' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

ELSE.

PERFORM APPEND_STRING_TO_FILE USING '<GATEWAY_CONNECTIONS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_GATEWAY
USING G_IREF_PDOCUMENT
'GWY_CONN'.
PERFORM APPEND_STRING_TO_FILE USING '</GATEWAY_CONNECTIONS>'.

ENDIF.

PERFORM ADD_TIME_STAT USING 'Extract Gateway Connections' L_STARTTIME.

ENDFORM.                    " EXTRACT_GATEWAY_CONNECTIONS

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_LANGUAGES_INSTALLED
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_LANGUAGES_INSTALLED.

TYPES: BEGIN OF T_LANG.
INCLUDE   TYPE T002.
TYPES:  SPTXT     TYPE SPTXT,
CODEPAGE  TYPE CPCODEPAGE,
END OF T_LANG.

DATA: L_STARTTIME  LIKE SY-UZEIT,
LT_LANG TYPE TABLE OF T_LANG.

FIELD-SYMBOLS: <LANG> LIKE LINE OF LT_LANG.


L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Languages Installed'.

SELECT T~SPRAS T~LASPEZ T~LAHQ T~LAISO FROM T002 AS T
INNER JOIN TLANIMP AS L ON T~SPRAS = L~SPRAS
INTO CORRESPONDING FIELDS OF TABLE LT_LANG.

SORT LT_LANG BY SPRAS.
DELETE ADJACENT DUPLICATES FROM LT_LANG COMPARING SPRAS.

LOOP AT LT_LANG ASSIGNING <LANG>.
SELECT SINGLE SPTXT FROM T002T
INTO <LANG>-SPTXT
WHERE SPRAS = SY-LANGU
AND   SPRSL = <LANG>-SPRAS.

CALL FUNCTION 'SCP_CODEPAGE_FOR_LANGUAGE'
EXPORTING
LANGUAGE    = <LANG>-SPRAS
IMPORTING
CODEPAGE    = <LANG>-CODEPAGE
EXCEPTIONS
NO_CODEPAGE = 1
OTHERS      = 2.

IF SY-SUBRC <> 0.
CASE SY-SUBRC.
WHEN 1. ERROR = 'NO_CODEPAGE'.
WHEN 2. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extract Languages Installed:'
'SCP_CODEPAGE_FOR_LANGUAGE -' <LANG>-SPRAS
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<LANGUAGES_INSTALLED>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_LANG
USING G_IREF_PDOCUMENT
'LANGUAGE'.
PERFORM APPEND_STRING_TO_FILE USING '</LANGUAGES_INSTALLED>'.

PERFORM ADD_TIME_STAT USING 'Extract Languages Installed' L_STARTTIME.

ENDFORM.                    " EXTRACT_LANGUAGES_INSTALLED

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_HARDWARE_PLATFORM
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_HARDWARE_PLATFORM.

TYPES: BEGIN OF T_PARAM,
PARAMETER_NAME  TYPE SMSYHWINFO-DESCRIPTOR,
PARAMETER_VALUE TYPE SMSYHWINFO-VALUE_1,
END OF T_PARAM.

DATA: L_STARTTIME LIKE SY-UZEIT,
LT_TEMP     TYPE TABLE OF SMSYHWINFO,
LT_HARDWARE TYPE TABLE OF T_PARAM,
LS_HARDWARE LIKE LINE OF LT_HARDWARE.

DATA: LV_PROCESS LIKE SY-TVAR0,
LV_MEMORY  LIKE SY-TVAR0,
LV_DISK    LIKE SY-TVAR0.

DATA: LT_DB6INFO TYPE TABLE OF DB6PMDB02,
LS_DB6INFO TYPE DB6PMDB02,
LS_ORAINFO TYPE TD110_STRU.


L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Hardware Platform'.

* Get Hardware information
CALL FUNCTION 'SCSI_GET_HARDWARE_INFO'
TABLES
INFO = LT_TEMP.

LT_HARDWARE[] = LT_TEMP[].

* Add Process, Memory & Disk parameters to Hardware information
CALL FUNCTION 'SCUI_GET_HARDWARE_DATA'
IMPORTING
EV_PROC_NR  = LV_PROCESS
EV_MEM_ALL  = LV_MEMORY
EV_DISKSIZE = LV_DISK.

LS_HARDWARE-PARAMETER_NAME  = 'No. Of processor'.
LS_HARDWARE-PARAMETER_VALUE = LV_PROCESS.
CONDENSE LS_HARDWARE-PARAMETER_VALUE.
APPEND LS_HARDWARE TO LT_HARDWARE.

LS_HARDWARE-PARAMETER_NAME  = 'Total memory'.
LS_HARDWARE-PARAMETER_VALUE = LV_MEMORY.
CONDENSE LS_HARDWARE-PARAMETER_VALUE.
APPEND LS_HARDWARE TO LT_HARDWARE.

LS_HARDWARE-PARAMETER_NAME  = 'Disk Space'.
LS_HARDWARE-PARAMETER_VALUE = LV_DISK.
CONDENSE LS_HARDWARE-PARAMETER_VALUE.
APPEND LS_HARDWARE TO LT_HARDWARE.

CASE SY-DBSYS.
WHEN 'DB6'.
CALL FUNCTION 'DB6_HIS_OVERVIEW'
TABLES
IT_DB6PMDB02          = LT_DB6INFO
EXCEPTIONS
NO_HISTORY_FOUND      = 1
INVALID_PARAMETER_SET = 2
ADBC_ERROR            = 3
SYSTEM_ERROR          = 4
OTHERS                = 5.
IF SY-SUBRC <> 0.
CASE SY-SUBRC.
WHEN 1. ERROR = 'NO_HISTORY_FOUND'.
WHEN 2. ERROR = 'INVALID_PARAMETER_SET'.
WHEN 3. ERROR = 'ADBC_ERROR'.
WHEN 4. ERROR = 'SYSTEM_ERROR'.
WHEN 5. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extract Hardware Platform - DB6_HIS_OVERVIEW'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ELSE.
READ TABLE LT_DB6INFO INTO LS_DB6INFO INDEX 1.
IF SY-SUBRC = 0.
CLEAR LS_HARDWARE.
LS_HARDWARE-PARAMETER_NAME  = 'DB Allocated Space'.
LS_HARDWARE-PARAMETER_VALUE = LS_DB6INFO-TOTALKB.
APPEND LS_HARDWARE TO LT_HARDWARE.

CLEAR LS_HARDWARE.
LS_HARDWARE-PARAMETER_NAME = 'DB Free Space'.
LS_HARDWARE-PARAMETER_VALUE = LS_DB6INFO-FREEKB.
APPEND LS_HARDWARE TO LT_HARDWARE.
ENDIF.
ENDIF.

WHEN 'ORACLE'.
CALL FUNCTION 'DB02_ORA_FILL_TD110'
IMPORTING
TD110 = LS_ORAINFO.

IF NOT LS_ORAINFO IS INITIAL.
CLEAR LS_HARDWARE.
LS_HARDWARE-PARAMETER_NAME  = 'DB Allocated Space'.
LS_HARDWARE-PARAMETER_VALUE = LS_ORAINFO-TSSI.
APPEND LS_HARDWARE TO LT_HARDWARE.

CLEAR LS_HARDWARE.
LS_HARDWARE-PARAMETER_NAME  = 'DB Free Space'.
LS_HARDWARE-PARAMETER_VALUE = LS_ORAINFO-TSFR.
APPEND LS_HARDWARE TO LT_HARDWARE.
ENDIF.

ENDCASE.

PERFORM APPEND_STRING_TO_FILE USING '<HARDWARE_PLATFORM>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_HARDWARE
USING G_IREF_PDOCUMENT
'HARDWARE_PARAM'.
PERFORM APPEND_STRING_TO_FILE USING '</HARDWARE_PLATFORM>'.

PERFORM ADD_TIME_STAT USING 'Extract Hardware Platform' L_STARTTIME.

ENDFORM.                    " EXTRACT_HARDWARE_PLATFORM

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WORKFLOW
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_WORKFLOWS.

TYPES: BEGIN OF T_WORKFLOW,
OTYPE TYPE HR_SOTYPE,
OBJID TYPE HR_SOBJID,
STEXT TYPE STEXT,
USAGE TYPE CHAR10,
END OF T_WORKFLOW.

DATA: L_STARTTIME   LIKE SY-UZEIT,
LT_WORKFLOWS  TYPE TABLE OF HRS1000,
LT_TEMP       TYPE TABLE OF HRS1000,
LV_USAGE_KEY  TYPE SWW_TASK,
R_TIME        TYPE SWR_TIMINT,
LS_FILTER     TYPE SWR_WITYPE,
LT_FILTER     TYPE TABLE OF SWR_WITYPE,
LT_WFLW_USAGE TYPE TABLE OF SWR_FREQ,
LS_WFLW_USAGE TYPE SWR_FREQ.

DATA: LT_STD_WFLW TYPE TABLE OF T_WORKFLOW,
LT_CST_WFLW TYPE TABLE OF T_WORKFLOW,
LS_WORKFLOW TYPE T_WORKFLOW.

FIELD-SYMBOLS: <WORKFLOW> TYPE HRS1000.


L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Workflows'.

CALL FUNCTION 'RH_CHECK_HRS_MACO'
EXPORTING
ACT_OTYPE     = 'WS'
TABLES
ACT_HRS_DATA  = LT_WORKFLOWS
EXCEPTIONS
NO_DATA_FOUND = 1
OTHERS        = 2.

CALL FUNCTION 'RH_CHECK_HRS_MACO'
EXPORTING
ACT_OTYPE     = 'TS'
TABLES
ACT_HRS_DATA  = LT_TEMP
EXCEPTIONS
NO_DATA_FOUND = 1
OTHERS        = 2.

APPEND LINES OF LT_TEMP TO LT_WORKFLOWS.
FREE LT_TEMP.

R_TIME-SIGN = 'I'.
R_TIME-OPTION = 'BT'.
R_TIME-LOW = SY-DATUM - 365.
R_TIME-HIGH = SY-DATUM.

LS_FILTER-WI_TYPE = 'W'.
APPEND LS_FILTER TO LT_FILTER.
LS_FILTER-WI_TYPE = 'B'.
APPEND LS_FILTER TO LT_FILTER.
LS_FILTER-WI_TYPE = 'F'.
APPEND LS_FILTER TO LT_FILTER.

CALL FUNCTION 'SAP_WAPI_WORKITEMS_BY_FREQUENC'
EXPORTING
TIME                     = R_TIME
SELECTION_STATUS_VARIANT = 0000
TABLES
WORKITEM_TYPE_FILTER     = LT_FILTER
WORKLIST_COMPACT         = LT_WFLW_USAGE.

SORT LT_WFLW_USAGE BY WI_RH_TASK.

LOOP AT LT_WORKFLOWS ASSIGNING <WORKFLOW>.
CLEAR LS_WORKFLOW.
LS_WORKFLOW-OTYPE = <WORKFLOW>-OTYPE.
LS_WORKFLOW-OBJID = <WORKFLOW>-OBJID.
LS_WORKFLOW-STEXT = <WORKFLOW>-STEXT.

CONCATENATE <WORKFLOW>-OTYPE <WORKFLOW>-OBJID INTO LV_USAGE_KEY.
READ TABLE LT_WFLW_USAGE INTO LS_WFLW_USAGE
WITH KEY WI_RH_TASK = LV_USAGE_KEY.
IF SY-SUBRC = 0.
LS_WORKFLOW-USAGE = LS_WFLW_USAGE-WI_COUNT.
SHIFT LS_WORKFLOW-USAGE LEFT DELETING LEADING SPACE.
ELSE.
LS_WORKFLOW-USAGE = '0'.
ENDIF.

*   Customer Workflow
IF <WORKFLOW>-OBJID > 89999999.
APPEND LS_WORKFLOW TO LT_CST_WFLW.
*   Standard Workflow with usage
ELSE.
IF NOT LS_WORKFLOW-USAGE = '0'.
APPEND LS_WORKFLOW TO LT_STD_WFLW.
ENDIF.
ENDIF.
ENDLOOP.

* Add the customer & standard workflow tables with usage
PERFORM APPEND_STRING_TO_FILE USING '<WORKFLOWS>'.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_CST_WFLW
USING G_IREF_PDOCUMENT
'WORKFLOW_CUST'.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_STD_WFLW
USING G_IREF_PDOCUMENT
'WORKFLOW_STD'.

PERFORM APPEND_STRING_TO_FILE USING '</WORKFLOWS>'.

PERFORM ADD_TIME_STAT USING 'Extract Workflows' L_STARTTIME.

ENDFORM.                    " EXTRACT_WORKFLOW

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_BTE_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_BTE_USER_EXITS.
L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting BTE User Exits'.

* Add the customer & standard workflow tables with usage
PERFORM APPEND_STRING_TO_FILE USING '<BTE_USER_EXITS>'.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES GT_BTE_UE
USING G_IREF_PDOCUMENT
'BTE'.

PERFORM APPEND_STRING_TO_FILE USING '</BTE_USER_EXITS>'.
FREE GT_BTE_UE.
PERFORM ADD_TIME_STAT USING 'Extract BTE User Exits' L_STARTTIME.
ENDFORM.                    " EXTRACT_BTE_USER_EXITS
*&---------------------------------------------------------------------*
*&      Form  GET_BTE_USER_EXITS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM GET_BTE_USER_EXITS USING I_FUNC_BTE TYPE T_FUNCTION_TYPE.
DATA: L_STARTTIME LIKE SY-UZEIT,
LS_BTE_UE   TYPE T_BTE_UE.

DATA: LT_TBE02 TYPE TABLE OF TBE02,
LV_TEXT1 TYPE TBE01T-TEXT1,
LV_XLBSE TYPE TBE01-XLBSE.

DATA: LT_FMRFC TYPE TABLE OF FMRFC,
LT_FMSAP TYPE TABLE OF FMSAP,
LT_FMPRT TYPE TABLE OF FMPRT,
LT_FMCUS TYPE TABLE OF FMCUS.

DATA: LT_TPS02 TYPE TABLE OF TPS02.

DATA: LT_APSAP TYPE TABLE OF APSAP,
LT_APPRT TYPE TABLE OF APPRT,
LT_APCUS TYPE TABLE OF APCUS.

FIELD-SYMBOLS: <TBE02> LIKE LINE OF LT_TBE02,
<FMRFC> LIKE LINE OF LT_FMRFC,
<FMSAP> LIKE LINE OF LT_FMSAP,
<FMPRT> LIKE LINE OF LT_FMPRT,
<FMCUS> LIKE LINE OF LT_FMCUS.

FIELD-SYMBOLS: <TPS02> LIKE LINE OF LT_TPS02,
<APSAP> LIKE LINE OF LT_APSAP,
<APPRT> LIKE LINE OF LT_APPRT,
<APCUS> LIKE LINE OF LT_APCUS.

FIELD-SYMBOLS: <BTE_UE> LIKE LINE OF GT_BTE_UE.

CHECK NO_SUET_DATA IS INITIAL.

SELECT DISTINCT EVENT FROM TBE02
INTO CORRESPONDING FIELDS OF TABLE LT_TBE02
WHERE ATTR_TYPE = 'A'.

LOOP AT LT_TBE02 ASSIGNING <TBE02>.
CLEAR: LS_BTE_UE, LV_XLBSE, LV_TEXT1,
LT_FMRFC[], LT_FMSAP[], LT_FMPRT[], LT_FMCUS[].

*   Get XLBSE from tbe01
SELECT SINGLE XLBSE FROM TBE01
INTO LV_XLBSE
WHERE EVENT = <TBE02>-EVENT.

*   Get text1 from tbe01t
SELECT SINGLE TEXT1 FROM TBE01T
INTO LV_TEXT1
WHERE EVENT = <TBE02>-EVENT
AND   SPRAS = SY-LANGU.

LS_BTE_UE-EVENT = <TBE02>-EVENT.
LS_BTE_UE-TEXT1 = LV_TEXT1.

IF LV_XLBSE IS INITIAL.
CALL FUNCTION 'BF_FUNCTIONS_FIND'
EXPORTING
I_EVENT       = <TBE02>-EVENT
TABLES
T_FMRFC       = LT_FMRFC
EXCEPTIONS
NOTHING_FOUND = 1
OTHERS        = 2.

LOOP AT LT_FMRFC ASSIGNING <FMRFC>.
LS_BTE_UE-STDFB = <FMRFC>-FUNCT.
APPEND LS_BTE_UE TO GT_BTE_UE.
ENDLOOP.

ELSE.
CALL FUNCTION 'BF_FUNCTIONS_READ'
EXPORTING
I_EVENT    = <TBE02>-EVENT
I_NO_XLBSE = 'X'
TABLES
T_FMSAP    = LT_FMSAP
T_FMPRT    = LT_FMPRT
T_FMCUS    = LT_FMCUS.

LOOP AT LT_FMSAP ASSIGNING <FMSAP> WHERE EVENT = <TBE02>-EVENT.
LS_BTE_UE-STDFB = <FMSAP>-FUNCT.
APPEND LS_BTE_UE TO GT_BTE_UE.
ENDLOOP.

LOOP AT LT_FMPRT ASSIGNING <FMPRT> WHERE EVENT = <TBE02>-EVENT.
LS_BTE_UE-STDFB = <FMPRT>-FUNCT.
APPEND LS_BTE_UE TO GT_BTE_UE.
ENDLOOP.

LOOP AT LT_FMCUS ASSIGNING <FMCUS> WHERE EVENT = <TBE02>-EVENT.
LS_BTE_UE-STDFB = <FMCUS>-FUNCT.
APPEND LS_BTE_UE TO GT_BTE_UE.
ENDLOOP.
ENDIF.
ENDLOOP.

SELECT DISTINCT PROCS FROM TPS02
INTO CORRESPONDING FIELDS OF TABLE LT_TPS02
WHERE ATTR_TYPE = 'A'.

LOOP AT LT_TPS02 ASSIGNING <TPS02>.
CLEAR: LS_BTE_UE, LV_XLBSE, LV_TEXT1,
LT_APSAP[], LT_APPRT[], LT_APCUS[].

SELECT SINGLE XLBSE FROM TPS01
INTO LV_XLBSE
WHERE PROCS = <TPS02>-PROCS.

SELECT SINGLE TEXT1 FROM TPS01T
INTO LV_TEXT1
WHERE PROCS = <TPS02>-PROCS
AND   SPRAS = SY-LANGU.

LS_BTE_UE-EVENT = <TPS02>-PROCS.
LS_BTE_UE-TEXT1 = LV_TEXT1.

IF LV_XLBSE IS INITIAL.
CALL FUNCTION 'PC_FUNCTIONS_READ'
EXPORTING
I_PROCS = <TPS02>-PROCS
TABLES
T_FMSAP = LT_APSAP
T_FMPRT = LT_APPRT
T_FMCUS = LT_APCUS.
ELSE.
CALL FUNCTION 'PC_FUNCTIONS_READ'
EXPORTING
I_PROCS    = <TPS02>-PROCS
I_NO_XLBSE = 'X'
TABLES
T_FMSAP    = LT_APSAP
T_FMPRT    = LT_APPRT
T_FMCUS    = LT_APCUS.
ENDIF.

LOOP AT LT_APSAP ASSIGNING <APSAP> WHERE PROCS = <TPS02>-PROCS.
LS_BTE_UE-STDFB = <APSAP>-FUNCT.
APPEND LS_BTE_UE TO GT_BTE_UE.
ENDLOOP.

LOOP AT LT_APPRT ASSIGNING <APPRT> WHERE PROCS = <TPS02>-PROCS.
LS_BTE_UE-STDFB = <APPRT>-FUNCT.
APPEND LS_BTE_UE TO GT_BTE_UE.
ENDLOOP.

LOOP AT LT_APCUS ASSIGNING <APCUS> WHERE PROCS = <TPS02>-PROCS.
LS_BTE_UE-STDFB = <APCUS>-FUNCT.
APPEND LS_BTE_UE TO GT_BTE_UE.
ENDLOOP.
ENDLOOP.

* Delete records that dont have a customer FM
LOOP AT GT_BTE_UE ASSIGNING <BTE_UE>.
READ TABLE I_FUNC_BTE WITH KEY FUNCNAME = <BTE_UE>-STDFB
BINARY SEARCH TRANSPORTING NO FIELDS.
IF SY-SUBRC <> 0.
DELETE GT_BTE_UE.
ENDIF.
ENDLOOP.
ENDFORM.                    " GET_BTE_USER_EXITS
*&---------------------------------------------------------------------*
*&      Form  extract_bw_data
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_BW_DATA.

CHECK NOT P_BW_RFC IS INITIAL.

PERFORM UPDATE_PROGRESS USING 'Extracting BW objects'.

* Extract Data
PERFORM APPEND_STRING_TO_FILE USING '<BW_OBJECTS>'.

PERFORM EXTRACT_DATA_SOURCES USING GV_LOGSYS.

PERFORM EXTRACT_INFO_PROVIDERS.

PERFORM EXTRACT_BW_OBJECTS USING GV_LOGSYS.

PERFORM EXTRACT_CONNECTION_TO_HIER.

PERFORM APPEND_STRING_TO_FILE  USING '</BW_OBJECTS>'.

ENDFORM.                    " extract_bw_data
*&---------------------------------------------------------------------*
*&      Form  extract_data_sources
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_PRODSYS  text
*----------------------------------------------------------------------*
FORM EXTRACT_DATA_SOURCES USING IV_PRODSYS TYPE LOGSYS.

DATA: LT_RSOLTPSOURCE TYPE TABLE OF TY_RSOLTPSOURCE,
LT_RSDS         TYPE TABLE OF TY_RSDS,
LT_RSISOSMAP    TYPE TABLE OF TY_RSISOSMAP,
LT_OPTIONS      TYPE TABLE OF RFC_DB_OPT,
LT_FIELDS       TYPE TABLE OF RFC_DB_FLD.

DATA: LS_OPTIONS      TYPE RFC_DB_OPT,
LS_FIELDS       TYPE RFC_DB_FLD.
DATA: LV_C_PRODSYS    TYPE CHAR12.

* Set prodsys in char for rfc options
CONCATENATE '''' IV_PRODSYS '''' INTO LV_C_PRODSYS.

*** Extract All Replicated DataSources in BW
***************************
*** Get 3X Data Sources ***
***************************
PERFORM APPEND_STRING_TO_FILE USING '<DATA_SOURCES_3X>'.

* Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING 'RSOLTPSOURCE'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSOLTPSOURCE.

SORT LT_RSOLTPSOURCE BY OLTPSOURCE ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSOLTPSOURCE
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSOLTPSOURCE
USING  G_IREF_PDOCUMENT
'RSOLTPSOURCE'.
CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE:  LT_RSOLTPSOURCE.

PERFORM APPEND_STRING_TO_FILE USING '</DATA_SOURCES_3X>'.

***************************
*** Get 7X Data Sources ***
***************************
PERFORM APPEND_STRING_TO_FILE USING '<DATA_SOURCES_7X>'.

* Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'DATASOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDS'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDS.

SORT LT_RSDS BY DATASOURCE ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDS
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDS
USING G_IREF_PDOCUMENT
'RSDS'.
CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDS.

PERFORM APPEND_STRING_TO_FILE USING '</DATA_SOURCES_7X>'.

************************************************
*** Get DataSources Connected To InfoSources ***
************************************************
PERFORM APPEND_STRING_TO_FILE USING '<DATA_SOURCES_TO_INFO_SOURCES>'.

* Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'ISOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSISOSMAP'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSISOSMAP.

SORT LT_RSISOSMAP BY ISOURCE OLTPSOURCE ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSISOSMAP
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSISOSMAP
USING  G_IREF_PDOCUMENT
'RSISOSMAP'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSISOSMAP.

PERFORM APPEND_STRING_TO_FILE USING '</DATA_SOURCES_TO_INFO_SOURCES>'.
ENDFORM.                    " extract_data_sources
*&---------------------------------------------------------------------*
*&      Form  extract_bw_objects
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_PRODSYS  text
*----------------------------------------------------------------------*
FORM EXTRACT_BW_OBJECTS USING IV_PRODSYS TYPE LOGSYS.

DATA: LT_RSPCPROCESSLOG      TYPE STANDARD TABLE OF TY_PROCESSLOG,
LT_RSPCPROCESSLOG_DATA TYPE TABLE OF TY_PROCESSLOG,
LT_RSLDPIO             TYPE TABLE OF TY_RSLDPIO,
LT_RSPCCHAINATTR       TYPE TABLE OF TY_RSPCCHAINATTR,
LT_RSPCCHAINATTR_TXT   TYPE TABLE OF TY_RSPCCHAINT,
LT_RSPCCHAIN           TYPE TABLE OF TY_RSPCCHAIN,
LS_RSPCCHAIN           LIKE LINE OF  LT_RSPCCHAIN,
LT_RSPCCHAIN_OUT       TYPE STANDARD TABLE OF TY_RSPCCHAIN_OUT,
LT_RSBKDTP             TYPE TABLE OF TY_RSBKDTP,
LT_RSBKDTP_TXT         TYPE TABLE OF TY_RSBKDTP_TXT,
LT_OPTIONS             TYPE TABLE OF RFC_DB_OPT,
LT_FIELDS              TYPE TABLE OF RFC_DB_FLD.

DATA: LV_COMP_COUNT TYPE I,
LV_FIRST_DATE TYPE BTCRELDT,
LV_LAST_DATE TYPE BTCRELDT,
LV_FIRST_TIME TYPE BTCRELTM,
LV_LAST_TIME TYPE BTCRELTM.

DATA: LS_OPTIONS             TYPE RFC_DB_OPT,
LS_FIELDS              TYPE RFC_DB_FLD.

DATA: LV_CURR_MONTH          TYPE CHAR2,
LV_FROM_DATE           TYPE BTCRELDT,
LV_TO_DATE             TYPE BTCRELDT,
LV_C_FROM_DATE         TYPE CHAR10,
LV_C_TO_DATE           TYPE CHAR10.
DATA: LV_C_PRODSYS           TYPE CHAR12.
FIELD-SYMBOLS : <LS_RSPCPROCESSLOG_DATA>
LIKE LINE OF LT_RSPCPROCESSLOG_DATA,
<LS_RSPCCHAIN_OUT>
LIKE LINE OF LT_RSPCCHAIN_OUT.

* Set prodsys in char for rfc options
CONCATENATE '''' IV_PRODSYS '''' INTO LV_C_PRODSYS.

*** Getting Usage Of BW Objects
***************************
*** Proccess Chain Data ***
***************************
PERFORM APPEND_STRING_TO_FILE USING '<PROCESS_CHAIN_ATTR>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'CHAIN_ID'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'APPLNM'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSPCCHAINATTR'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSPCCHAINATTR.

SORT LT_RSPCCHAINATTR BY CHAIN_ID APPLNM ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSPCCHAINATTR
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSPCCHAINATTR
USING  G_IREF_PDOCUMENT
'RSPCCHAINATTR'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSPCCHAINATTR.

PERFORM APPEND_STRING_TO_FILE USING '</PROCESS_CHAIN_ATTR>'.

*** Get Chain Data Text
PERFORM APPEND_STRING_TO_FILE USING '<CHAIN_DATA_TEXT>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'LANGU'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'CHAIN_ID'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TXTLG'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSPCCHAINT'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSPCCHAINATTR_TXT.

SORT LT_RSPCCHAINATTR_TXT BY CHAIN_ID LANGU TXTLG ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSPCCHAINATTR_TXT COMPARING ALL
FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSPCCHAINATTR_TXT
USING  G_IREF_PDOCUMENT
'RSPCCHAINT'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSPCCHAINATTR_TXT.

PERFORM APPEND_STRING_TO_FILE USING '</CHAIN_DATA_TEXT>'.


********************************
*** Process Chain Components ***
********************************
PERFORM APPEND_STRING_TO_FILE USING '<PROCESS_CHAIN_COMP>'.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSPCCHAIN'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSPCCHAIN.

SORT LT_RSPCCHAIN BY CHAIN_ID TYPE VARIANTE LNR EVENT_START
EVENTP_START EVENTNO_START BACKLINK_START  EVENT_GREEN EVENTP_GREEN
BACKLINK_GREEN EVENT_RED EVENTP_RED BACKLINK_RED GREEN_EQ_RED WAIT
MAIL_AT_RED MAIL_AT_GREEN ASCENDING.

DELETE ADJACENT DUPLICATES FROM LT_RSPCCHAIN
COMPARING ALL FIELDS.

LT_RSPCCHAIN_OUT[] = LT_RSPCCHAIN[].

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.

*******************************
*** Get Process Chains Logs ***
*******************************

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'TYPE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'EVENT_START'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'EVENTP_START'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'VARIANTE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'BATCHDATE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'BATCHTIME'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INSTANCE'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Add Current Month
LV_CURR_MONTH = SY-DATUM+4(2).

*** Get Data For Previous Year(12 month)
DO 12 TIMES.

IF SY-INDEX = 1.

LV_FROM_DATE      = SY-DATUM.
LV_FROM_DATE+6(2) = '01'.
LV_TO_DATE        = SY-DATUM.

ELSE.

*     Get Previous Month
SUBTRACT 1 FROM LV_CURR_MONTH.
IF LV_CURR_MONTH = 0.
*       Starting New Year
LV_CURR_MONTH  = 12.
ENDIF.

LV_FROM_DATE+4(2) = LV_CURR_MONTH.
LV_TO_DATE+4(2)   = LV_CURR_MONTH.
*     Get Days In Month
PERFORM GET_LAST_MONTH_DATE CHANGING LV_TO_DATE.
ENDIF.

*** Create WHERE String For SELECT
CONCATENATE '''' LV_FROM_DATE '''' INTO LV_C_FROM_DATE.
CONCATENATE '''' LV_TO_DATE ''''   INTO LV_C_TO_DATE.

CONCATENATE 'BATCHDATE BETWEEN'
LV_C_FROM_DATE 'AND' LV_C_TO_DATE
INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.

APPEND LS_OPTIONS TO LT_OPTIONS .

LS_OPTIONS-TEXT = 'AND ( TYPE = ''LOADING'''.
APPEND LS_OPTIONS TO LT_OPTIONS.
LS_OPTIONS-TEXT = 'OR TYPE = ''DTP_LOAD'' ) '.
APPEND LS_OPTIONS TO LT_OPTIONS.


PERFORM RFC_READ_TABLE USING   'RSPCPROCESSLOG'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSPCPROCESSLOG.

APPEND LINES OF LT_RSPCPROCESSLOG TO LT_RSPCPROCESSLOG_DATA.

CLEAR: LT_OPTIONS[], LT_RSPCPROCESSLOG[],  LS_OPTIONS.
ENDDO.

SORT LT_RSPCPROCESSLOG_DATA BY TYPE EVENT_START EVENTP_START
VARIANTE BATCHDATE BATCHTIME INSTANCE ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSPCPROCESSLOG_DATA
COMPARING ALL FIELDS.

* Count each component usage - number of log entries
LOOP AT LT_RSPCPROCESSLOG_DATA ASSIGNING <LS_RSPCPROCESSLOG_DATA>.
AT NEW VARIANTE.
LV_COMP_COUNT = 1.
LV_FIRST_DATE = <LS_RSPCPROCESSLOG_DATA>-BATCHDATE.
LV_FIRST_TIME = <LS_RSPCPROCESSLOG_DATA>-BATCHTIME.
ENDAT.

AT END OF VARIANTE.
LV_LAST_DATE = <LS_RSPCPROCESSLOG_DATA>-BATCHDATE.
LV_LAST_TIME = <LS_RSPCPROCESSLOG_DATA>-BATCHTIME.

READ TABLE LT_RSPCCHAIN_OUT
WITH KEY TYPE = <LS_RSPCPROCESSLOG_DATA>-TYPE
EVENT_START = <LS_RSPCPROCESSLOG_DATA>-EVENT_START
EVENTP_START = <LS_RSPCPROCESSLOG_DATA>-EVENTP_START
VARIANTE = <LS_RSPCPROCESSLOG_DATA>-VARIANTE
ASSIGNING <LS_RSPCCHAIN_OUT>.

IF SY-SUBRC IS INITIAL.
<LS_RSPCCHAIN_OUT>-FIRST_USED_DATE = LV_FIRST_DATE.
<LS_RSPCCHAIN_OUT>-FIRST_USED_TIME = LV_FIRST_TIME.
<LS_RSPCCHAIN_OUT>-LAST_USED_DATE = LV_LAST_DATE.
<LS_RSPCCHAIN_OUT>-LAST_USED_TIME = LV_LAST_TIME.
<LS_RSPCCHAIN_OUT>-COUNT = LV_COMP_COUNT.
ENDIF.
ENDAT.
LV_COMP_COUNT = LV_COMP_COUNT + 1.
ENDLOOP.

CLEAR: LT_FIELDS[], LS_FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSPCCHAIN_OUT
USING G_IREF_PDOCUMENT
'RSPCCHAIN'.
FREE : LT_RSPCCHAIN_OUT,
LT_RSPCCHAIN,
LT_RSPCPROCESSLOG_DATA.

PERFORM APPEND_STRING_TO_FILE USING '</PROCESS_CHAIN_COMP>'.

*****************************************
*** Get DataSources From InfoPackages ***
*****************************************
PERFORM APPEND_STRING_TO_FILE USING '<INFO_PACKAGES>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'LOGDPID'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'LOGSYS'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.

APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSLDPIO'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSLDPIO.

SORT LT_RSLDPIO BY LOGDPID LOGSYS OLTPSOURCE ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSLDPIO
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSLDPIO
USING G_IREF_PDOCUMENT
'RSLDPIO'.
CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSLDPIO.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_PACKAGES>'.

********************************
*** Get DataSources From DTP ***
********************************
PERFORM APPEND_STRING_TO_FILE USING '<DATASOURCE_FROM_DTP>'.

*** Fill Required Table Fields
*  ls_fields-fieldname = 'SRCTLOGO'.
*  APPEND ls_fields TO lt_fields.
LS_FIELDS-FIELDNAME = 'DTP'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'SRC'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'SRCTP'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'SRCTLOGO'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TGT'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TGTTP'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TGTTLOGO'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
LS_OPTIONS-TEXT =  'AND SRCTLOGO = ''RSDS'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSBKDTP'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSBKDTP.

SORT LT_RSBKDTP BY SRCTLOGO SRC SRCTP TGT TGTTP TGTTLOGO ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSBKDTP
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSBKDTP
USING G_IREF_PDOCUMENT
'RSBKDTP'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSBKDTP.
PERFORM APPEND_STRING_TO_FILE USING '</DATASOURCE_FROM_DTP>'.

*** Get Data Objects Text
PERFORM APPEND_STRING_TO_FILE USING '<DTP_TEXT>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'LANGU'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'DTP'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TXTLG'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSBKDTPT'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSBKDTP_TXT.

SORT LT_RSBKDTP_TXT BY DTP LANGU TXTLG ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSBKDTP_TXT COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSBKDTP_TXT
USING  G_IREF_PDOCUMENT
'RSBKDTPT'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSBKDTP_TXT.

PERFORM APPEND_STRING_TO_FILE USING '</DTP_TEXT>'.

ENDFORM.                    " extract_bw_objects
*&---------------------------------------------------------------------*
*&      Form  extract_connection_to_hier
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_CONNECTION_TO_HIER.


DATA: LT_OPTIONS             TYPE TABLE OF RFC_DB_OPT,
LT_FIELDS              TYPE TABLE OF RFC_DB_FLD,
LT_TADIR               TYPE STANDARD TABLE OF TADIR,
LT_RSDAREA             TYPE TABLE OF TY_AREA,
LT_RSDAREA_TXT         TYPE TABLE OF TY_AREA_TXT,
LT_TDEVC               TYPE TABLE OF TY_TDEVC.

DATA: LS_OPTIONS             TYPE RFC_DB_OPT,
LS_FIELDS              TYPE RFC_DB_FLD.

********************************
*** InfoProvider To DevClass ***
********************************
PERFORM APPEND_STRING_TO_FILE USING '<INFO_CUBES_TO_DEV_CLASS>'.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = ' OBJECT = ''CUBE'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
LS_OPTIONS-TEXT = ' OR  OBJECT = ''ODSO'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
LS_OPTIONS-TEXT = ' OR  OBJECT = ''IOBJ'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'TADIR'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_TADIR.

SORT LT_TADIR BY PGMID OBJECT OBJ_NAME KORRNUM SRCSYSTEM AUTHOR SRCDEP
DEVCLASS GENFLAG EDTFLAG CPROJECT MASTERLANG VERSID PAKNOCHECK
OBJSTABLTY COMPONENT CRELEASE  ASCENDING.

DELETE ADJACENT DUPLICATES FROM LT_TADIR
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TADIR
USING  G_IREF_PDOCUMENT
'TADIR'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_TADIR.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_CUBES_TO_DEV_CLASS>'.

*******************************
*** Extract All Dev Classes ***
*******************************
PERFORM APPEND_STRING_TO_FILE USING '<BW_DEV_CLASSES>'.

PERFORM RFC_READ_TABLE USING   'TDEVC'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_TDEVC.

SORT LT_TDEVC BY DEVCLASS
INTSYS
CONSYS
CTEXT
KORRFLAG
AS4USER
PDEVCLASS
ASCENDING.

DELETE ADJACENT DUPLICATES FROM LT_TDEVC
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_TDEVC
USING  G_IREF_PDOCUMENT
'TDEVC'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_TDEVC.

PERFORM APPEND_STRING_TO_FILE USING '</BW_DEV_CLASSES>'.

**********************
*** InfoAreas List ***
**********************
PERFORM APPEND_STRING_TO_FILE USING '<INFO_AREA_LIST>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'INFOAREA'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'OWNER'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOAREA_P'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOAREA_C'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOAREA_N'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TSTPNM'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TIMESTMP'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDAREA'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDAREA.

SORT LT_RSDAREA BY INFOAREA OWNER INFOAREA_P INFOAREA_C INFOAREA_N
TSTPNM ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDAREA
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDAREA
USING  G_IREF_PDOCUMENT
'RSDAREA'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDAREA.
PERFORM APPEND_STRING_TO_FILE USING '</INFO_AREA_LIST>'.

*** Get Info Area Text
PERFORM APPEND_STRING_TO_FILE USING '<INFO_AREA_LIST_TEXT>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'LANGU'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOAREA'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TXTLG'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDAREAT'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDAREA_TXT.

SORT LT_RSDAREA_TXT BY INFOAREA LANGU TXTLG ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDAREA_TXT COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDAREA_TXT
USING  G_IREF_PDOCUMENT
'RSDAREAT'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDAREA_TXT.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_AREA_LIST_TEXT>'.

ENDFORM.                    " extract_connection_to_hier
*&---------------------------------------------------------------------*
*&      Form  extract_info_providers
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM EXTRACT_INFO_PROVIDERS.
DATA:  LT_RSTRAN              TYPE TABLE OF TY_RSTRAN,
LT_RSUPDINFO           TYPE TABLE OF TY_RSUPDINFO,
LT_RSDCUBE             TYPE TABLE OF TY_RSDCUBE,
LT_RSDCUBE_TXT         TYPE TABLE OF TY_RSDCUBE_TXT,
LT_RSDIOBJ             TYPE TABLE OF TY_RSDIOBJ,
LT_RSDIOBJ_TXT         TYPE TABLE OF TY_RSDIOBJ_TXT,
LT_RSDODSO             TYPE TABLE OF TY_RSDODSO,
LT_RSDODSO_TXT         TYPE TABLE OF TY_RSDODSO_TXT,
LT_OPTIONS             TYPE TABLE OF RFC_DB_OPT,
LT_FIELDS              TYPE TABLE OF RFC_DB_FLD,
LT_RSDCHABAS           TYPE TABLE OF TY_RSDCHABAS.

DATA: LS_OPTIONS             TYPE RFC_DB_OPT,
LS_FIELDS              TYPE RFC_DB_FLD.

PERFORM APPEND_STRING_TO_FILE USING '<CONNECTED_BY_TRANSFORMATIONS>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'TRANID'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'SOURCETYPE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'SOURCENAME'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TARGETTYPE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TARGETNAME'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSTRAN'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSTRAN.

SORT LT_RSTRAN BY TARGETTYPE TARGETNAME SOURCENAME ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSTRAN
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSTRAN
USING  G_IREF_PDOCUMENT
'RSTRAN'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSTRAN.

PERFORM APPEND_STRING_TO_FILE USING '</CONNECTED_BY_TRANSFORMATIONS>'.

****************************************************
*** Get Info Providers Connected By Update Rules ***
****************************************************
PERFORM APPEND_STRING_TO_FILE USING '<CONNECTED_BY_UPDATE_RULES>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'UPDID'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOCUBE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'ISOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSUPDINFO'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSUPDINFO.

SORT LT_RSUPDINFO BY INFOCUBE ISOURCE ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSUPDINFO
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSUPDINFO
USING  G_IREF_PDOCUMENT
'RSUPDINFO'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSUPDINFO.

PERFORM APPEND_STRING_TO_FILE USING '</CONNECTED_BY_UPDATE_RULES>'.


*****************************
*** Get InfoProvider Data ***
*****************************
PERFORM APPEND_STRING_TO_FILE USING '<INFO_CUBES>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'INFOAREA'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOCUBE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TSTPNM'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TIMESTMP'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDCUBE'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDCUBE.

SORT  LT_RSDCUBE BY INFOAREA INFOCUBE TSTPNM ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDCUBE
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDCUBE
USING  G_IREF_PDOCUMENT
'RSDCUBE'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDCUBE.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_CUBES>'.

*** Get Info Providers Text
PERFORM APPEND_STRING_TO_FILE USING '<INFO_CUBES_TEXTS>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'LANGU'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOCUBE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TXTLG'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDCUBET'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDCUBE_TXT.

SORT LT_RSDCUBE_TXT BY INFOCUBE TXTLG ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDCUBE COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDCUBE_TXT
USING  G_IREF_PDOCUMENT
'RSDCUBET'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDCUBE_TXT.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_CUBES_TEXTS>'.

************************
*** Get Info Objects ***
************************
PERFORM APPEND_STRING_TO_FILE USING '<INFO_OBJECTS>'.

*** Fill Required Table Fields
*  ls_fields-fieldname = 'IOBJTP'.
*  APPEND ls_fields TO lt_fields.
LS_FIELDS-FIELDNAME = 'IOBJNM'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TSTPNM'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TIMESTMP'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
LS_OPTIONS-TEXT = 'AND IOBJTP = ''CHA'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDIOBJ'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDIOBJ.

SORT LT_RSDIOBJ BY IOBJNM TSTPNM ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDIOBJ
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDIOBJ
USING  G_IREF_PDOCUMENT
'RSDIOBJ'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDIOBJ.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_OBJECTS>'.

*** Get Info Objects Text
PERFORM APPEND_STRING_TO_FILE USING '<INFO_OBJECTS_TEXTS>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'LANGU'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'IOBJNM'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TXTLG'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
LS_OPTIONS-TEXT = 'AND LANGU = ''E'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDIOBJT'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDIOBJ_TXT.

SORT LT_RSDIOBJ_TXT BY IOBJNM LANGU TXTLG ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDIOBJ_TXT COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDIOBJ_TXT
USING  G_IREF_PDOCUMENT
'RSDIOBJT'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDIOBJ_TXT.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_OBJECTS_TEXTS>'.

*********************************
*** Get Info Objects Add Data ***
*********************************

PERFORM APPEND_STRING_TO_FILE USING '<INFO_OBJECTS_ADD_DATA>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'CHABASNM'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOAREA'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'APPLNM'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDCHABAS'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDCHABAS.

SORT LT_RSDCHABAS BY CHABASNM INFOAREA APPLNM ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDCHABAS
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDCHABAS
USING  G_IREF_PDOCUMENT
'RSDCHABAS'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDCHABAS.

PERFORM APPEND_STRING_TO_FILE USING '</INFO_OBJECTS_ADD_DATA>'.
************************
*** Extract DSO Data ***
************************
PERFORM APPEND_STRING_TO_FILE USING '<DSO_DATA>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'ODSOBJECT'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'ODSOTYPE'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'INFOAREA'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TSTPNM'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TIMESTMP'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDODSO'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDODSO.

SORT LT_RSDODSO BY ODSOBJECT ODSOTYPE INFOAREA TSTPNM ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDODSO
COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDODSO
USING  G_IREF_PDOCUMENT
'RSDODSO'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDODSO.

PERFORM APPEND_STRING_TO_FILE USING '</DSO_DATA>'.

*** Get Info Objects Text
PERFORM APPEND_STRING_TO_FILE USING '<DSO_DATA_TEXTS>'.

*** Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'ODSOBJECT'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'LANGU'.
APPEND LS_FIELDS TO LT_FIELDS.
LS_FIELDS-FIELDNAME = 'TXTLG'.
APPEND LS_FIELDS TO LT_FIELDS.

*** Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

PERFORM RFC_READ_TABLE USING   'RSDODSOT'
P_BW_RFC
LT_OPTIONS
LT_FIELDS
CHANGING LT_RSDODSO_TXT.

SORT LT_RSDODSO_TXT BY LANGU TXTLG ASCENDING.
DELETE ADJACENT DUPLICATES FROM LT_RSDODSO_TXT COMPARING ALL FIELDS.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_RSDODSO_TXT
USING  G_IREF_PDOCUMENT
'RSDODSOT'.

CLEAR: LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.
FREE: LT_RSDODSO_TXT.

PERFORM APPEND_STRING_TO_FILE USING '</DSO_DATA_TEXTS>'.

ENDFORM.                    " extract_info_providers
*&---------------------------------------------------------------------*
*&      Form  get_last_month_date
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_LV_TO_DATE  text
*----------------------------------------------------------------------*
FORM GET_LAST_MONTH_DATE CHANGING CV_TO_DATE TYPE BTCRELDT.
DATA: LV_DAYS_MONTH  TYPE BUTAG,"/osp/dt_day,
LV_MONTH    TYPE  MONAT,
LV_YEAR   TYPE  GJAHR.

LV_MONTH = CV_TO_DATE+4(2).
LV_YEAR  = CV_TO_DATE(4).

CALL FUNCTION 'NUMBER_OF_DAYS_PER_MONTH_GET'
EXPORTING
PAR_MONTH = LV_MONTH
PAR_YEAR  = LV_YEAR
IMPORTING
PAR_DAYS  = LV_DAYS_MONTH.

CV_TO_DATE+6(2) = LV_DAYS_MONTH.
ENDFORM.                    " get_last_month_date
*&---------------------------------------------------------------------*
*&      Form  rfc_read_table
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_9673   text
*      -->P_P_BW_RFC  text
*      -->P_LT_OPTIONS  text
*      -->P_LT_FIELDS  text
*      <--P_LT_RSOLTPSOURCE  text
*----------------------------------------------------------------------*

FORM RFC_READ_TABLE  USING    IV_TABLE_NAME TYPE  DD02L-TABNAME
IV_DEST       TYPE  RFCDEST
IT_OPTIONS    TYPE  TT_OPTIONS
IT_FIELDS     TYPE  TT_FIELDS
CHANGING CT_DATA       TYPE  ANY TABLE.

DATA: LT_TAB TYPE TABLE OF TAB512.

DATA: LV_MSG(150)  TYPE C,
LV_RFC_ERROR TYPE RFCLOG_D,
LV_STARTTIME TYPE SYUZEIT,
LV_STEP(512) TYPE C.

LV_STARTTIME = SY-UZEIT.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION IV_DEST
EXPORTING
QUERY_TABLE           = IV_TABLE_NAME
*      delimiter             = space
*      no_data               = space
*      rowskips              = 0
TABLES
OPTIONS               = IT_OPTIONS
FIELDS                = IT_FIELDS
DATA                  = LT_TAB
EXCEPTIONS
TABLE_NOT_AVAILABLE   = 1
TABLE_WITHOUT_DATA    = 2
OPTION_NOT_VALID      = 3
FIELD_NOT_VALID       = 4
NOT_AUTHORIZED        = 5
DATA_BUFFER_EXCEEDED  = 6
SYSTEM_FAILURE        = 7  MESSAGE LV_RFC_ERROR
COMMUNICATION_FAILURE = 8  MESSAGE LV_RFC_ERROR
OTHERS                = 9.

CASE SY-SUBRC.
WHEN 1.
CONCATENATE 'Table:' IV_TABLE_NAME 'Not Available'
INTO LV_MSG SEPARATED BY SPACE.
WHEN 2.
CONCATENATE 'Table:' IV_TABLE_NAME 'Without Data'
INTO LV_MSG SEPARATED BY SPACE.
WHEN 3.
CONCATENATE 'Option Not Valid For Table: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 4.
CONCATENATE 'Field Not Valid: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 5.
CONCATENATE 'No authorizations reading from table: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 6.
CONCATENATE 'Data Buffer Exceeded. Table: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 7 OR 8.
LV_MSG = LV_RFC_ERROR(50).
ENDCASE.

* Save table data
CT_DATA[] = LT_TAB[].

* Update Status
CONCATENATE 'Extract' IV_TABLE_NAME INTO LV_STEP SEPARATED BY SPACE.
PERFORM ADD_TIME_STAT USING LV_STEP LV_STARTTIME.

IF NOT LV_MSG IS INITIAL.
CONCATENATE 'Extraction failed. Error:' LV_MSG
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDFORM.                    " rfc_read_table

*&---------------------------------------------------------------------*
*&      Form  rfc_read_table_with_row_count
*&---------------------------------------------------------------------*
*       Read table from an rfc destination with option for lines limit
*----------------------------------------------------------------------*
*      -->IV_TABLE_NAME - table name
*      -->IV_DEST  - RFC Destination name
*      -->IT_OPTIONS  - select options for the query
*      -->IT_FIELDS - field to retreive from the query
*      -->ROW_COUNT - Number of lines to read (send 0 to read all)
*      <--P_LT_RSOLTPSOURCE  text
*----------------------------------------------------------------------*

FORM RFC_READ_TABLE_WITH_ROWCOUNT
USING IV_TABLE_NAME TYPE DD02L-TABNAME
IV_DEST       TYPE RFCDEST
IT_OPTIONS    TYPE TT_OPTIONS
IT_FIELDS     TYPE TT_FIELDS
ROW_COUNT     TYPE SOID-ACCNT
CHANGING CT_DATA    TYPE  ANY TABLE.

DATA: LT_TAB TYPE TABLE OF TAB512.

DATA: LV_MSG(150)  TYPE C,
LV_RFC_ERROR TYPE RFCLOG_D,
LV_STARTTIME TYPE SYUZEIT,
LV_STEP(512) TYPE C.

DATA: SY_SUBC TYPE I.

LV_STARTTIME = SY-UZEIT.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION IV_DEST
EXPORTING
QUERY_TABLE           = IV_TABLE_NAME
*      delimiter             = space
*      no_data               = space
*      rowskips              = 0
ROWCOUNT             = ROW_COUNT
TABLES
OPTIONS               = IT_OPTIONS
FIELDS                = IT_FIELDS
DATA                  = LT_TAB
EXCEPTIONS
TABLE_NOT_AVAILABLE   = 1
TABLE_WITHOUT_DATA    = 2
OPTION_NOT_VALID      = 3
FIELD_NOT_VALID       = 4
NOT_AUTHORIZED        = 5
DATA_BUFFER_EXCEEDED  = 6
SYSTEM_FAILURE        = 7  MESSAGE LV_RFC_ERROR
COMMUNICATION_FAILURE = 8  MESSAGE LV_RFC_ERROR
OTHERS                = 9.

SY_SUBC = SY-SUBRC.

CT_DATA[] = LT_TAB[].

* Update Status
CONCATENATE 'Extract' IV_TABLE_NAME INTO LV_STEP SEPARATED BY SPACE.
PERFORM ADD_TIME_STAT USING LV_STEP LV_STARTTIME.

CASE SY_SUBC.
WHEN 1.
CONCATENATE 'Table:' IV_TABLE_NAME 'Not Available'
INTO LV_MSG SEPARATED BY SPACE.
WHEN 2.
CONCATENATE 'Table:' IV_TABLE_NAME 'Without Data'
INTO LV_MSG SEPARATED BY SPACE.
WHEN 3.
CONCATENATE 'Option Not Valid For Table: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 4.
CONCATENATE 'Field Not Valid: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 5.
CONCATENATE 'No authorizations reading from table: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 6.
CONCATENATE 'Data Buffer Exceeded. Table: ' IV_TABLE_NAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 7 OR 8.
LV_MSG = LV_RFC_ERROR(50).
ENDCASE.

IF NOT LV_MSG IS INITIAL.
CONCATENATE 'Extraction failed. Error:' LV_MSG
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDFORM.                    " rfc_read_table_with_rowcount
*&---------------------------------------------------------------------*
*&      Form  get_rfc_structure
*&---------------------------------------------------------------------*
FORM GET_RFC_STRUCTURE TABLES O_FIELDS STRUCTURE RFC_FIELDS
USING  I_TABLE_NAME
IV_DEST.

DATA: FIELD_WA LIKE LINE OF O_FIELDS,
SUBRC TYPE C.

CALL FUNCTION 'RFC_GET_STRUCTURE_DEFINITION' DESTINATION IV_DEST
EXPORTING
TABNAME                = I_TABLE_NAME
TABLES
FIELDS                 = O_FIELDS
EXCEPTIONS
TABLE_NOT_ACTIVE       = 1
OTHERS                 = 2.

IF SY-SUBRC <> 0.
SUBRC = SY-SUBRC.
CONCATENATE 'SOLAR:8.1 Warning:failed getting rfc structure'
I_TABLE_NAME
'exited with subrc' SUBRC
INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDFORM.                                      "get_rfc_structure
*&---------------------------------------------------------------------*
*&      Form  check_bw_rfc_dest
*&---------------------------------------------------------------------*
FORM CHECK_BW_RFC_DEST USING    IV_RFC_DEST TYPE RFCDEST
IV_VALIDATE TYPE FLAG
CHANGING EV_VALID    TYPE FLAG.

DATA : LV_ERR_MSG TYPE STRING,
BW_SYSID   TYPE SYSYSID,
BW_SAPRL   TYPE SYSAPRL.

* BW RFC entered
CHECK NOT IV_RFC_DEST IS INITIAL.

PERFORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST
IV_VALIDATE
CHANGING EV_VALID
BW_SYSID
BW_SAPRL.

* Tables Accessibility Check
* RFC is valid - ev_valid = true
IF NOT EV_VALID IS INITIAL.
PERFORM CHECK_BW_TABLES_ACCESSIBILITY.
*   BW connection and BW tables checked
*   check BW data sources use the PRD RFC system as
*   source system - otherwise no DataSource will be
*   extracted and no BW impact found
PERFORM CHECK_BW_DATA_SOURCES.
ENDIF.
ENDFORM.                    " check_bw_rfc_dest
*---------------------------------------------------------------------*
*       FORM check_bw_data_sources                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM CHECK_BW_DATA_SOURCES.

DATA: LV_C_PRODSYS    TYPE CHAR12,
LT_OPTIONS      TYPE TABLE OF RFC_DB_OPT,
LT_FIELDS       TYPE TABLE OF RFC_DB_FLD,
LS_OPTIONS      TYPE RFC_DB_OPT,
LS_FIELDS       TYPE RFC_DB_FLD.
DATA: LT_TAB          TYPE TABLE OF TAB512.
DATA: LT_RSOLTPSOURCE TYPE TABLE OF TY_RSOLTPSOURCE,
LT_RSDS         TYPE TABLE OF TY_RSDS.
DATA: LV_MESSAGE      TYPE STRING.

* The data sources are correlated with prod sys
CHECK NOT GV_LOGSYS IS INITIAL AND
NOT P_BW_RFC IS INITIAL.

* Set prodsys in char for rfc options
CONCATENATE '''' GV_LOGSYS '''' INTO LV_C_PRODSYS.

* Check 3X DS available in BW sys with PROD RFC source
* Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'OLTPSOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .
CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
APPEND LS_OPTIONS TO LT_OPTIONS .

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_BW_RFC
EXPORTING
QUERY_TABLE          = 'RSOLTPSOURCE'
ROWCOUNT             = 1
TABLES
OPTIONS              = LT_OPTIONS
FIELDS               = LT_FIELDS
DATA                 = LT_TAB
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
ENDIF.
LT_RSOLTPSOURCE[] = LT_TAB[].

CLEAR: LT_TAB[], LT_FIELDS[], LT_OPTIONS[], LS_FIELDS, LS_OPTIONS.

* Check 7X DS available in BW sys with PROD RFC source
* Fill Required Table Fields
LS_FIELDS-FIELDNAME = 'DATASOURCE'.
APPEND LS_FIELDS TO LT_FIELDS.

* Create WHERE String For SELECT
LS_OPTIONS-TEXT = 'OBJVERS = ''A'''.
APPEND LS_OPTIONS TO LT_OPTIONS .

CONCATENATE 'AND LOGSYS =' LV_C_PRODSYS
INTO LS_OPTIONS-TEXT SEPARATED BY SPACE.
APPEND LS_OPTIONS TO LT_OPTIONS .

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_BW_RFC
EXPORTING
QUERY_TABLE          = 'RSDS'
ROWCOUNT             = 1
TABLES
OPTIONS              = LT_OPTIONS
FIELDS               = LT_FIELDS
DATA                 = LT_TAB
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
ENDIF.
LT_RSDS[] = LT_TAB[].

* No DataSources available in BW system with the PRD source system
IF LT_RSDS[] IS INITIAL AND
LT_RSOLTPSOURCE[] IS INITIAL.

IF NOT R_FORE IS INITIAL.
MESSAGE W001(00) WITH
'No BW DataSources available with source system :'
GV_LOGSYS
' with RFC to BW system :'
P_BW_RFC.
ELSE.
*     Add to ETL messages
CONCATENATE
'No BW DataSources available with source system:'
GV_LOGSYS
'with RFC to BW system:'
P_BW_RFC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  check_bw_tables_accessibility
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM CHECK_BW_TABLES_ACCESSIBILITY .

CHECK NOT P_BW_RFC IS INITIAL.

PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCPROCESSLOG' P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSLDPIO'       P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSISOSMAP'     P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSTRAN'        P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSUPDINFO'     P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSOLTPSOURCE'  P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDS'          P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDCUBE'       P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDCUBET'      P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDIOBJ'       P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDIOBJT'      P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDODSO'       P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDODSOT'      P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCCHAINATTR' P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCCHAIN'     P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSPCCHAINT'    P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSBKDTP'       P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSBKDTPT'      P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'TADIR'         P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDAREA'       P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'RSDAREAT'      P_BW_RFC.
PERFORM TEST_RFC_TABLE_ACCESSIBILITY USING 'TDEVC'         P_BW_RFC.

ENDFORM.                    " check_bw_tables_accessibility
*---------------------------------------------------------------------*
*       FORM test_rfc_table_accessibility
*
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_TABNAME                                                     *
*---------------------------------------------------------------------*
FORM TEST_RFC_TABLE_ACCESSIBILITY USING IV_TABNAME TYPE TABNAME
IV_RFCDEST TYPE RFCDES-RFCDEST.

DATA: LT_TAB       TYPE TABLE OF TAB512,
LT_OPTIONS   TYPE TABLE OF RFC_DB_OPT,
LT_FIELDS    TYPE TABLE OF RFC_DB_FLD.

DATA: LV_MSG(150)  TYPE C,
LV_RFC_ERROR TYPE RFCLOG_D,
LV_ERR_MSG   TYPE STRING.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION IV_RFCDEST
EXPORTING
QUERY_TABLE           = IV_TABNAME
DELIMITER             = SPACE
NO_DATA               = 'X'  "space
ROWSKIPS              = 0
ROWCOUNT              = 1
TABLES
OPTIONS               = LT_OPTIONS
FIELDS                = LT_FIELDS
DATA                  = LT_TAB
EXCEPTIONS
TABLE_NOT_AVAILABLE   = 1
TABLE_WITHOUT_DATA    = 2
OPTION_NOT_VALID      = 3
FIELD_NOT_VALID       = 4
NOT_AUTHORIZED        = 5
DATA_BUFFER_EXCEEDED  = 6
SYSTEM_FAILURE        = 7  MESSAGE LV_RFC_ERROR
COMMUNICATION_FAILURE = 8  MESSAGE LV_RFC_ERROR
OTHERS                = 9.

CASE SY-SUBRC.

WHEN 1.
CONCATENATE 'Table:' IV_TABNAME 'Not Available'
INTO LV_MSG SEPARATED BY SPACE.
WHEN 2.
CONCATENATE 'Table:' IV_TABNAME 'Without Data'
INTO LV_MSG SEPARATED BY SPACE.
WHEN 3.
CONCATENATE 'Option Not Valid For Table: ' IV_TABNAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 4.
CONCATENATE 'Field Not Valid For Table: ' IV_TABNAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 5.
CONCATENATE 'No authorizations reading from table: ' IV_TABNAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 6.
CONCATENATE 'Data Buffer Exceeded. Table: ' IV_TABNAME
INTO LV_MSG SEPARATED BY SPACE.
WHEN 7 OR 8.
LV_MSG = LV_RFC_ERROR(50).
ENDCASE.

IF NOT LV_MSG IS INITIAL.
IF NOT R_FORE IS INITIAL.
MESSAGE E000(CONV) WITH LV_MSG.
ELSE.
APPEND LV_MSG TO GT_ETL_MESSAGE.
ENDIF.
ENDIF.
ENDFORM.                    "test_rfc_table_accessibility
*&---------------------------------------------------------------------*
*&      Form  validate_rfc_connection
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IV_RFC_DEST  text
*      -->P_IV_VALIDATE  text
*      <--P_EV_VALID  text
*----------------------------------------------------------------------*
FORM VALIDATE_RFC_CONNECTION USING IV_RFC_DEST TYPE RFCDEST
IV_VALIDATE TYPE FLAG
CHANGING EV_VALID TYPE FLAG
EV_SYSID TYPE SYSYSID
EV_SAPRL TYPE SYSAPRL.

DATA : LS_RFCDES     TYPE RFCDES,
LS_RFCDISPLAY TYPE RFCDISPLAY,
LV_ERR_MSG    TYPE STRING,
RFC_ERROR     TYPE RFCLOG_D,
LV_FAILED     TYPE FLAG,
LS_RFCSI      TYPE RFCSI.

EV_VALID = ABAP_TRUE.

* Get RFC basic data
SELECT SINGLE *
FROM RFCDES
INTO LS_RFCDES
WHERE
RFCDEST = IV_RFC_DEST.

IF SY-SUBRC IS INITIAL.
*   Get RFC connections data
CALL FUNCTION 'RFCDES2RFCDISPLAY'
EXPORTING
IMPORT_RFCDES           = LS_RFCDES
AUTHORITY_CHECK         = ABAP_TRUE
IMPORTING
EXPORT_RFCDISPLAY       = LS_RFCDISPLAY
EXCEPTIONS
FORMAT_ERROR            = 1
AUTHORITY_NOT_AVAILABLE = 2
OTHERS                  = 3.

IF SY-SUBRC IS INITIAL.
*     Check the RFC connection - auth and validity
CALL FUNCTION 'RFC_READ_R3_DESTINATION'
EXPORTING
DESTINATION                   = IV_RFC_DEST
AUTHORITY_CHECK               = ABAP_TRUE
*         BYPASS_BUF                    = 'X'
EXCEPTIONS
AUTHORITY_NOT_AVAILABLE       = 1
DESTINATION_NOT_EXIST         = 2
INFORMATION_FAILURE           = 3
INTERNAL_FAILURE              = 4
OTHERS                        = 5.

IF SY-SUBRC IS INITIAL.
CALL FUNCTION 'RFC_SYSTEM_INFO'
DESTINATION IV_RFC_DEST
IMPORTING
RFCSI_EXPORT          = LS_RFCSI
EXCEPTIONS
SYSTEM_FAILURE        = 1  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE = 2  MESSAGE RFC_ERROR.

IF SY-SUBRC <> 0.
IF IV_VALIDATE IS INITIAL.
CONCATENATE 'Could not connect to RFC destination'
IV_RFC_DEST
INTO LV_ERR_MSG
SEPARATED BY SPACE.                       "#EC NOTEXT
MESSAGE E208(00) WITH LV_ERR_MSG RFC_ERROR.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ELSE.       "SUBRC = 0 for func RFC_SYSTEM_INFO
EV_SYSID = LS_RFCSI-RFCSYSID.
EV_SAPRL = LS_RFCSI-RFCSAPRL.
ENDIF.       "SUBRC for func RFC_SYSTEM_INFO

*       To get a logon screen at the next 'normal' RFC call
*       it is required to close the connection opend by RFC_SYSTEM_INFO
CALL FUNCTION 'RFC_CONNECTION_CLOSE'
EXPORTING
DESTINATION = IV_RFC_DEST
EXCEPTIONS
OTHERS      = 1.
ELSE.                "SUBRC <> 0 for func RFC_READ_R3_DESTINATION
IF IV_VALIDATE IS INITIAL.
CONCATENATE 'Could not connect to RFC destination'
IV_RFC_DEST
INTO LV_ERR_MSG
SEPARATED BY SPACE.                                "#EC NOTEXT
MESSAGE E208(00) WITH LV_ERR_MSG RFC_ERROR.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ENDIF.           "SUBRC for func RFC_READ_R3_DESTINATION
ELSE.            "SUBRC <> 0 for func RFCDES2RFCDISPLAY
IF IV_VALIDATE IS INITIAL.
"LEON
CONCATENATE 'RFC destination' IV_RFC_DEST
'does not exist or is not R/3 connection' INTO LV_ERR_MSG
SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ENDIF.           " SUBRC for func RFCDES2RFCDISPLAY
ELSE.              "SUBRC <> 0 for query from RFCDES
IF IV_VALIDATE IS INITIAL.
CONCATENATE 'RFC destination' IV_RFC_DEST
'does not exist or is not R/3 connection' INTO LV_ERR_MSG
SEPARATED BY SPACE.
MESSAGE E208(00) WITH LV_ERR_MSG.
LEAVE TO SCREEN SY-DYNNR.
ELSE.
EV_VALID = ABAP_FALSE.
ENDIF.
ENDIF.             "SUBRC for query from RFCDES
ENDFORM.                    " validate_rfc_connection

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_SAP_SCRIPT_FORMS
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM EXTRACT_SAP_SCRIPT_FORMS.

DATA: LT_FORM TYPE TABLE OF STXH,
L_STARTTIME LIKE SY-UZEIT.

RANGES: R_FORM FOR STXH-TDNAME.

FIELD-SYMBOLS: <OBJ_FORM> LIKE LINE OF GT_OBJ_FORM.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting SAP Script Forms'.

CHECK NOT GT_OBJ_FORM[] IS INITIAL.

LOOP AT GT_OBJ_FORM ASSIGNING <OBJ_FORM>.
CLEAR R_FORM.
R_FORM-SIGN = 'I'.
R_FORM-OPTION = 'EQ'.
R_FORM-LOW = <OBJ_FORM>-OBJ_NAME.
APPEND R_FORM.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<SAP_SCRIPT_FORMS>'.

* Get SAP Screipt Form Definitions
SELECT TDNAME FROM STXH PACKAGE SIZE PAC_SIZE
INTO CORRESPONDING FIELDS OF TABLE LT_FORM
FOR ALL ENTRIES IN R_FORM
WHERE TDNAME = R_FORM-LOW
AND TDOBJECT = 'FORM'
AND TDID = 'DEF'
AND TDSPRAS = SY-LANGU.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_FORM
USING  G_IREF_PDOCUMENT
'SAP_SCRIPT'.

ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</SAP_SCRIPT_FORMS>'.

PERFORM ADD_TIME_STAT
USING 'Extract SAP Script Forms' L_STARTTIME.

ENDFORM.                    " EXTRACT_SAP_SCRIPT_FORMS

*&---------------------------------------------------------------------*
*&      Form  ADD_SYSTEM_TYPES_TO_HEADER
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*
FORM ADD_SYSTEM_TYPES_TO_HEADER
USING IV_HEADER_NODE TYPE REF TO IF_IXML_ELEMENT.

DATA: LS_LOCAL_SYSTEM  TYPE T000,
LS_TARGET_SYSTEM TYPE T000,
LS_RFCDES        TYPE RFCDES,
LS_RFCDISPLAY    TYPE RFCDISPLAY.

DATA: LV_PREFIX TYPE STRING,
LV_SUFFIX TYPE STRING,
LV_TARGET_MANDT TYPE MANDT.

DATA: OPTIONS   TYPE TABLE OF RFC_DB_OPT,
FIELDS    TYPE TABLE OF RFC_DB_FLD,
T000_ITAB TYPE TABLE OF T000.

* Local system's type
SELECT SINGLE *
FROM T000
INTO CORRESPONDING FIELDS OF LS_LOCAL_SYSTEM
WHERE MANDT EQ SY-MANDT.

IF SY-SUBRC IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING IV_HEADER_NODE
'LOCAL_SYSTEM_TYPE' LS_LOCAL_SYSTEM-CCCATEGORY.
MESSAGE S000(CONV) WITH 'LOCAL_SYSTEM_TYPE ='
LS_LOCAL_SYSTEM-CCCATEGORY.
ENDIF.

* Target system's type
SELECT SINGLE *
FROM RFCDES BYPASSING BUFFER
INTO CORRESPONDING FIELDS OF LS_RFCDES
WHERE RFCDEST EQ P_RFCDES.

IF SY-SUBRC IS INITIAL.
SPLIT LS_RFCDES-RFCOPTIONS AT ',M=' INTO LV_PREFIX LV_SUFFIX.
IF SY-SUBRC IS INITIAL AND NOT LV_SUFFIX IS INITIAL.
LV_TARGET_MANDT = LV_SUFFIX(3).
ENDIF.
ENDIF.

* Get target system T000 table
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'T000'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = OPTIONS
FIELDS               = FIELDS
DATA                 = T000_ITAB
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC IS INITIAL AND NOT T000_ITAB IS INITIAL.
IF NOT LV_TARGET_MANDT IS INITIAL.
*     Read target T000 with mandt
READ TABLE T000_ITAB INTO LS_TARGET_SYSTEM
WITH KEY MANDT = LV_TARGET_MANDT.
IF NOT SY-SUBRC IS INITIAL.
*       Fallback: Mandt not found Read target T000 with cccategory = 'P'
CONCATENATE
'No results in target system T000 table'
'for target MANDT found:' LV_TARGET_MANDT
'Reading T000 with cccategory = P'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

READ TABLE T000_ITAB INTO LS_TARGET_SYSTEM
WITH KEY CCCATEGORY = 'P'.
ENDIF.
ELSE.
*     Fallback: No mandt: Read target T000 with cccategory = 'P'
CONCATENATE
'Failed to get MANDT, Reading target system T000'
'table with cccategory = P'
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

READ TABLE T000_ITAB INTO LS_TARGET_SYSTEM
WITH KEY CCCATEGORY = 'P'.
ENDIF.
ENDIF.

IF NOT LS_TARGET_SYSTEM IS INITIAL.
PERFORM ADD_ATTRIBUTE_TO_NODE USING IV_HEADER_NODE
'TARGET_SYSTEM_TYPE' LS_TARGET_SYSTEM-CCCATEGORY.

MESSAGE S000(CONV) WITH 'TARGET_SYSTEM_TYPE ='
LS_TARGET_SYSTEM-CCCATEGORY.
ENDIF.

ENDFORM.                    " ADD_SYSTEM_TYPES_TO_HEADER

*&---------------------------------------------------------------------*
*&      Form  CHECK_BUSINESS_PROCESS_AUTH
*&---------------------------------------------------------------------*
*       ........                                                       *
*----------------------------------------------------------------------*

FORM CHECK_BUSINESS_PROCESS_AUTH USING IV_RFC_DEST
CHANGING IV_AUTH_PROBLEM
MESSAGE TYPE RFCLOG_D.

DATA:
NODES     TYPE TABLE OF HIER_IFACE.

CALL FUNCTION 'SASAP_HIERARCHY_READ' DESTINATION IV_RFC_DEST
TABLES
LIST_OF_NODES               = NODES
EXCEPTIONS
SYSTEM_FAILURE        = 1  MESSAGE MESSAGE
COMMUNICATION_FAILURE = 2  MESSAGE MESSAGE.

IF NOT SY-SUBRC IS INITIAL.
IV_AUTH_PROBLEM = 'X'.
ENDIF.



ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  ADD_MESSAGE
*&---------------------------------------------------------------------*
*       This form handles addition of record to ETL_MESSAGES  (
*       messages created during ETL run ) and ETL_JOBLOG ( joblog
*       created during backround run of the ETL )
*----------------------------------------------------------------------*
FORM ADD_MESSAGE USING MESS_TEXT
IS_JOBLOG.

DATA: MESS_RECORD TYPE ETL_MESSAGE_TYPE.

* Handle order counter
IF IS_JOBLOG IS INITIAL.
MESS_RECORD-ORDER = GT_NEXT_ORDER.
ADD 1 TO GT_NEXT_ORDER.
ELSE.
MESS_RECORD-ORDER = GT_NEXT_ORDER_JOBLOG.
ADD 1 TO GT_NEXT_ORDER_JOBLOG.
ENDIF.

* Handle other data ( message, date and time )
MESS_RECORD-DATE = SY-DATUM.
MESS_RECORD-TIME = SY-UZEIT.
MESS_RECORD-MESSAGE = MESS_TEXT.

* Add record
IF IS_JOBLOG IS INITIAL.
APPEND MESS_RECORD TO GT_ETL_MESSAGE.
ELSE.
APPEND MESS_RECORD TO GT_ETL_JOBLOG.
ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  GET_USAGE_BY_MONTHS_BACK
*&---------------------------------------------------------------------*
FORM GET_USAGE_BY_MONTHS_BACK USING KEY1
KEY2
KEY3
KEY4
USAGE_TYPE
CHANGING CALLERS TYPE TT_USAGE_CALLER.

DATA: LV_BEGDA TYPE DATUM,
LV_ENDDA TYPE DATUM.

DATA: LV_MONTHS_BACK TYPE I.

* Set first end date and begin date to be
* from today to beginning of the month
LV_ENDDA = SY-DATUM.
LV_BEGDA = LV_ENDDA.
LV_BEGDA+6(2) = '01'.

* Calculate months back according to the day of the month
IF LV_ENDDA+6(2) GT '15'.
LV_MONTHS_BACK = MONTHS_BACK_USAGE.
ELSE.
LV_MONTHS_BACK = MONTHS_BACK_USAGE + 1.
ENDIF.

DO LV_MONTHS_BACK TIMES.

CASE USAGE_TYPE.
WHEN 'PROXIES'.
PERFORM GET_PROXY_USAGE_BY_DATES USING KEY1
KEY2
LV_BEGDA
LV_ENDDA
CHANGING CALLERS.
WHEN 'IDOCS'.
PERFORM GET_IDOCS_USAGE_BY_DATES USING KEY1
KEY2
KEY3
KEY4
LV_BEGDA
LV_ENDDA
CHANGING CALLERS.
ENDCASE.

*   If there is data for current month, return it.
*   If not, check for next month back
IF NOT CALLERS[] IS INITIAL.
EXIT.
ELSE.
*     Calculate previous month
LV_ENDDA = LV_BEGDA - 1.
LV_BEGDA = LV_ENDDA.
LV_BEGDA+6(2) = '01'.
ENDIF.
ENDDO.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  GET_TABLE_DATA_VIA_RFC
*&---------------------------------------------------------------------*
FORM GET_TABLE_DATA_VIA_RFC TABLES RESULT
USING TAB_NAME TYPE TABNAME.

DATA: OPTIONS TYPE TABLE OF RFC_DB_OPT,
FIELDS TYPE TABLE OF RFC_DB_FLD,
TAB_DATA TYPE TABLE OF TAB512.

CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = TAB_NAME
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = OPTIONS
FIELDS               = FIELDS
DATA                 = RESULT
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF NOT SY-SUBRC IS INITIAL.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'Extraction of ' TAB_NAME ' from ' P_RFCDES
' failed. Error: ' ERROR
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  get_sapworkdir
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM GET_SAPWORKDIR.

* Run this only if the program is running in foreground
IF SY-BATCH IS INITIAL.

*   Set the default foreground filename
TRY.
CALL FUNCTION 'IW_C_GET_SAPWORKDIR'
IMPORTING
SAPWORKDIR = SAPWORKDIR.
CONCATENATE SAPWORKDIR '\' INTO SAPWORKDIR.
CATCH CX_ROOT.
GT_ETL_MESSAGE = 'Error while SAPWORKDIR extraction'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDTRY.
ENDIF.
IF SAPWORKDIR IS INITIAL.
SAPWORKDIR = 'C:\'.
ENDIF.
ENDFORM.                    "get_sapworkdir

*&---------------------------------------------------------------------*
*&      Form  check_etl_version
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM CHECK_ETL_VERSION.
IF SY-SAPRL < '700'.
MESSAGE E000(CONV) WITH 'ETL version & SAP version are different.'
' Please contact Panaya customer support.'.
ENDIF.
ENDFORM.                    "check_etl_version

*&---------------------------------------------------------------------*
*&      Form  version_specific_init
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM VERSION_SPECIFIC_INIT.

DATA: CVERS_WA TYPE CVERS.

GV_ENDLINE = CL_ABAP_CHAR_UTILITIES=>NEWLINE.
CONCATENATE SPACE GV_ENDLINE  INTO NEW_LINE.

PERFORM FILL_VANILLA_PROGRAMS.

PERFORM INIT_WEB_BLACKLIST.

* Get Unicode-length
CALL FUNCTION 'DD_GET_UCLEN'
IMPORTING
UCLEN = UNICODELG.

* Find active business set (industry solution)
SELECT SINGLE BSET
FROM SFW_ACTIVE_B1
INTO ACTIVE_INDUSTRY_SOLUTION
WHERE VERSION = 'A'.

* In case we didn't find any active business set, we look for specific
* IS installed as add-on
IF SY-SUBRC IS NOT INITIAL.

SELECT SINGLE * FROM CVERS
INTO CVERS_WA WHERE COMPONENT = 'P3A'.

IF SY-SUBRC IS INITIAL.
ACTIVE_INDUSTRY_SOLUTION = 'AFS'.
ENDIF.

ENDIF.
ENDFORM.                    "version_specific_init

*---------------------------------------------------------------------*
*       FORM version_specific_header_attrib
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VERSION_SPECIFIC_HEADER_ATTRIB USING HEADER_NODE TYPE XML_ELEMENT
.
* Add the mini version attribute (for vanilla programs validation)
PERFORM ADD_ATTRIBUTE_TO_NODE USING HEADER_NODE 'MINI_VERSION'
HEADER_MINI_VERSION.
ENDFORM.                    "version_specific_header_attrib

*---------------------------------------------------------------------*
*       FORM append_itab_to_file                                      *
*---------------------------------------------------------------------*
FORM APPEND_ITAB_TO_FILE USING I_STREAM_SIZE TYPE I
I_TAB_CONVERTED_DATA TYPE XML_TAB_TYPE.

DATA: L_OREF TYPE REF TO CX_ROOT,
TEXT TYPE STRING.
DATA: L_FILE  TYPE STRING.
DATA: LS_FILE TYPE XML_LINE_TYPE.
DATA: L_REMAINING_SIZE TYPE I.
DATA: L_RECSIZE        TYPE I.

IF NOT R_FORE IS INITIAL.
L_FILE =  TEMP_FORE_FILENAME.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>GUI_DOWNLOAD
EXPORTING
BIN_FILESIZE            = I_STREAM_SIZE
FILENAME                = L_FILE
FILETYPE                = 'BIN'
APPEND                  = G_FILE_APPEND_MODE
CHANGING
DATA_TAB                = I_TAB_CONVERTED_DATA
EXCEPTIONS
FILE_WRITE_ERROR        = 1
NO_BATCH                = 2
GUI_REFUSE_FILETRANSFER = 3
INVALID_TYPE            = 4
NO_AUTHORITY            = 5
UNKNOWN_ERROR           = 6
HEADER_NOT_ALLOWED      = 7
SEPARATOR_NOT_ALLOWED   = 8
FILESIZE_NOT_ALLOWED    = 9
HEADER_TOO_LONG         = 10
DP_ERROR_CREATE         = 11
DP_ERROR_SEND           = 12
DP_ERROR_WRITE          = 13
UNKNOWN_DP_ERROR        = 14
ACCESS_DENIED           = 15
DP_OUT_OF_MEMORY        = 16
DISK_FULL               = 17
DP_TIMEOUT              = 18
FILE_NOT_FOUND          = 19
DATAPROVIDER_EXCEPTION  = 20
CONTROL_FLUSH_ERROR     = 21
NOT_SUPPORTED_BY_GUI    = 22
ERROR_NO_GUI            = 23
OTHERS                  = 24.

IF SY-SUBRC <> 0.
DATA: EXPLAN TYPE STRING.
IF SY-SUBRC = 17.
EXPLAN = 'Disk is full'.
ELSE.
EXPLAN = SY-SUBRC.
ENDIF.
MESSAGE E000(CONV) WITH 'Problem writing to file: ' EXPLAN.
ENDIF.
ENDIF.

* Server file
IF NOT R_BACK IS INITIAL.
* Open file
IF G_FILE_APPEND_MODE IS INITIAL.
OPEN DATASET TEMP_BACK_FILENAME  FOR OUTPUT IN BINARY MODE.
ELSE.
OPEN DATASET TEMP_BACK_FILENAME  FOR APPENDING IN BINARY MODE.
ENDIF.
* Write file
L_REMAINING_SIZE = I_STREAM_SIZE.
LOOP AT I_TAB_CONVERTED_DATA INTO LS_FILE.
IF L_REMAINING_SIZE < 256.
L_RECSIZE = L_REMAINING_SIZE.
ELSE.
L_RECSIZE = 256.
ENDIF.

TRANSFER LS_FILE TO TEMP_BACK_FILENAME  LENGTH L_RECSIZE.
SUBTRACT L_RECSIZE FROM L_REMAINING_SIZE.
ENDLOOP.
* Close file
CLOSE DATASET TEMP_BACK_FILENAME .
IF SY-SUBRC IS INITIAL.
*      MESSAGE s171(26) WITH p_back.
*     File & created
ELSE.
*      MESSAGE e005(ps).
*     Cannot close output file
ENDIF.
ENDIF.

* The first time we write the file in overwrite mode, then we switch
* to append mode
IF G_FILE_APPEND_MODE IS INITIAL.
G_FILE_APPEND_MODE = 'X'.
ENDIF.

ENDFORM.                    "append_itab_to_file

*&---------------------------------------------------------------------*
*&      Form  add_abap_query_objects
*&
*& The following objects are collected:
*& 1. Function group of AQ (/1BCDWB/SAPLIQ*) - added once as FUGR and
*&    once as PROG. We add it as FUGR so that the fugr's function
*&    modules interface will be extracted
*& 2. Function group includes (/1BCDWB/LIQ*) - TOP include, UXX include,
*&                             func. modules includes are added as PROG
*& 3. AQ includes (/1BCDWB/IQ*) - added as PROG
*&---------------------------------------------------------------------*
FORM ADD_ABAP_QUERY_OBJECTS.

DATA: LT_AQLQCAT TYPE TABLE OF AQLQCAT WITH HEADER LINE,
OBJ_NAME   LIKE RSEUI_SET-OBJ_NAME,
RSTAT      LIKE TRDIR-RSTAT,
FUGR_NAME  LIKE RSEUI_SET-OBJ_NAME.

SELECT * FROM  AQLQCAT CLIENT SPECIFIED
INTO TABLE LT_AQLQCAT
WHERE  MANDT  = SY-MANDT.
LOOP AT LT_AQLQCAT.
CLEAR GS_TADIR.
GS_TADIR-PGMID  = 'R3TR'.
GS_TADIR-OBJECT = 'PROG'.
* Get Query's program name
CALL FUNCTION 'RSAQ_REPORT_NAME'
EXPORTING
WORKSPACE  = ' '
USERGROUP  = LT_AQLQCAT-NUM
QUERY      = LT_AQLQCAT-QNUM
IMPORTING
REPORTNAME = GS_TADIR-OBJ_NAME.
CHECK NOT GS_TADIR-OBJ_NAME IS INITIAL.
APPEND GS_TADIR TO GT_TADIR.

ABAP_QUERY_PROGS-OBJ_NAME = GS_TADIR-OBJ_NAME.
APPEND ABAP_QUERY_PROGS.
ENDLOOP.

IF ADD_ABAP_QUERIES = 'X'.

*   Add includes
SELECT NAME FROM TRDIR
INTO OBJ_NAME
WHERE NAME LIKE '/1BCDWB/IQ%'.
GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
ENDSELECT.

*   Add function group includes (TOP/UXX/function module includes)
SELECT NAME RSTAT FROM TRDIR
INTO (OBJ_NAME, RSTAT)
WHERE NAME LIKE '/1BCDWB/LIQ%'.

*     Do not collect system includes
IF NOT ( RSTAT = 'S' AND OBJ_NAME CS '$' ).
GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
APPEND GS_OBJECTLIST TO GT_OBJ_PROG.
ENDIF.
ENDSELECT.

*   Add function groups (as a function group and a program)
SELECT NAME FROM TRDIR
INTO OBJ_NAME
WHERE NAME LIKE '/1BCDWB/SAPLIQ%'.
GS_OBJECTLIST-OBJ_TYPE = 'PROG'.
GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
APPEND GS_OBJECTLIST TO GT_OBJ_PROG.

GS_OBJECTLIST-OBJ_TYPE = 'FUGR'.

PERFORM GET_FUGR_FROM_FUGR_PROG USING OBJ_NAME
CHANGING FUGR_NAME.

GS_OBJECTLIST-OBJ_NAME = FUGR_NAME.
APPEND GS_OBJECTLIST TO GT_OBJ_FUNC.
ENDSELECT.

*   Add structures
SELECT TABNAME FROM DD02L
INTO OBJ_NAME
WHERE TABNAME LIKE '/1BCDWB/IQ%'.
GS_OBJECTLIST-OBJ_TYPE = 'TABL'.
GS_OBJECTLIST-OBJ_NAME = OBJ_NAME.
APPEND GS_OBJECTLIST TO GT_OBJ_TABL.
APPEND GS_OBJECTLIST TO GT_OBJ_TYPE.
ENDSELECT.

ENDIF.

ENDFORM.                    "add_abap_query_objects


*---------------------------------------------------------------------*
*       FORM get_text_elements                                        *
*---------------------------------------------------------------------*
FORM GET_TEXT_ELEMENTS TABLES LT_TEXTELM   STRUCTURE TEXTPOOL
CLASS_INCLUDES TYPE PROG_TAB_TYPE
USING P_NAME TYPE C
P_RFC_DEST TYPE RFCDEST.

READ TABLE CLASS_INCLUDES WITH KEY PROG = P_NAME BINARY SEARCH.
IF NOT SY-SUBRC IS INITIAL.

*   The text elements are not read in RPY_PROGRAM_READ since the is a
*   problem. The text field of selection texts based on data dictionary
*   are not solved
CALL FUNCTION 'RS_TEXTPOOL_READ'
EXPORTING
OBJECTNAME           = P_NAME
ACTION               = ''
LANGUAGE             = 'E'
TABLES
TPOOL                = LT_TEXTELM
EXCEPTIONS
OBJECT_NOT_FOUND     = 1
PERMISSION_FAILURE   = 2
INVALID_PROGRAM_TYPE = 3
ERROR_OCCURED        = 4
ACTION_CANCELLED     = 5
OTHERS               = 6.
IF SY-SUBRC <> 0 AND SY-SUBRC <> 1 AND SY-SUBRC <> 3.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 2. ERROR = 'PERMISSION_FAILURE'.
WHEN 4. ERROR = 'ERROR_OCCURED'.
WHEN 5. ERROR = 'ACTION_CANCELLED'.
WHEN 6. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract programs: RS_TEXTPOOL_READ, program:'
P_NAME 'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDIF.

ENDFORM.                    "get_text_elements

*&---------------------------------------------------------------------*
*&      Form  INTLEN_TO_UCLEN
*&---------------------------------------------------------------------*
FORM UCLEN_TO_INTLEN USING DATATYPE
INTLEN   LIKE DD03P-INTLEN
UC_LEN   LIKE X030L-UNICODELG.

DATA CHAR_TYPES(60) VALUE
'ACCP CHAR CLNT CUKY DATS LANG LCHR NUMC TIMS TMST VARC UNIT'.
DATA: MASK00(1) TYPE X VALUE 00,
MASK01(1) TYPE X VALUE 01.

IF UC_LEN <> MASK00 AND UC_LEN <> MASK01 AND CHAR_TYPES CS DATATYPE.
INTLEN = INTLEN / UC_LEN.
ENDIF.

ENDFORM.                    " INTLEN_TO_UCLENGTH

*&---------------------------------------------------------------------*
*&      Form  read_function_module_interface
*&---------------------------------------------------------------------*
*       Reads function module interface
*----------------------------------------------------------------------*
FORM READ_FUNCTION_MODULE_INTERFACE
TABLES
IMPORT_PARAMETER STRUCTURE  RSIMP
CHANGING_PARAMETER STRUCTURE  RSCHA
EXPORT_PARAMETER STRUCTURE  RSEXP
TABLES_PARAMETER STRUCTURE  RSTBL
EXCEPTION_LIST STRUCTURE  RSEXC
DOCUMENTATION STRUCTURE  RSFDO
SOURCE STRUCTURE  RSSOURCE
USING
FUNCTIONNAME   TYPE RS38L-NAME
CHANGING
GLOBAL_FLAG    LIKE  RS38L-GLOBAL
REMOTE_CALL    LIKE  RS38L-REMOTE
UPDATE_TASK    LIKE  RS38L-UTASK
SHORT_TEXT     LIKE  TFTIT-STEXT
FUNCTION_POOL  LIKE  RS38L-AREA
RC             LIKE  SY-SUBRC.

CALL FUNCTION 'RPY_FUNCTIONMODULE_READ_NEW'
EXPORTING
FUNCTIONNAME       = FUNCTIONNAME
IMPORTING
GLOBAL_FLAG        = GLOBAL_FLAG
REMOTE_CALL        = REMOTE_CALL
UPDATE_TASK        = UPDATE_TASK
SHORT_TEXT         = SHORT_TEXT
FUNCTION_POOL      = FUNCTION_POOL
TABLES
IMPORT_PARAMETER   = IMPORT_PARAMETER
CHANGING_PARAMETER = CHANGING_PARAMETER
EXPORT_PARAMETER   = EXPORT_PARAMETER
TABLES_PARAMETER   = TABLES_PARAMETER
EXCEPTION_LIST     = EXCEPTION_LIST
DOCUMENTATION      = DOCUMENTATION
SOURCE             = SOURCE
EXCEPTIONS
ERROR_MESSAGE      = 1
FUNCTION_NOT_FOUND = 2
INVALID_NAME       = 3
OTHERS             = 4.
RC = SY-SUBRC.


ENDFORM.                    "read_function_module_interface

*---------------------------------------------------------------------*
*       FORM check_filename                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  FILENAME                                                      *
*---------------------------------------------------------------------*
FORM CHECK_FILENAME USING FILENAME.

DATA: TEMP_FILENAME LIKE RLGRAP-FILENAME,
LEN TYPE I,
LAST_CHARS(4) TYPE C.


DESCRIBE FIELD FILENAME LENGTH LEN IN CHARACTER MODE.
IF LEN > 128.
MESSAGE E000(CONV) WITH
'File name too long. Maximum length of the filename is 128 chars'.
ENDIF.

LEN = STRLEN( FILENAME ).
LEN = LEN - 4.
LAST_CHARS = FILENAME+LEN(4).
IF LAST_CHARS <> '.XML' AND LAST_CHARS <> '.xml'.
MESSAGE E000(CONV) WITH 'File name suffix must be .xml'.
ENDIF.


* Check if the filename contains invalid characters
TEMP_FILENAME = FILENAME.
TRANSLATE TEMP_FILENAME TO UPPER CASE.

IF TEMP_FILENAME CN ALLOWED_CHARS.
MESSAGE E000(CONV) WITH
'File name is not valid.'.
ENDIF.

ENDFORM.                    "check_filename

*&---------------------------------------------------------------------*
*&      Form  get_program_gui_status_wrap
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_GUI_STATUS_WRAP
USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE.

CHECK IA_DATA_ONLY IS INITIAL.

FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP.
TRY.
PERFORM GET_PROGRAM_GUI_STATUS USING PT_PROGRAM_NODE.
CATCH CX_ROOT.
ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.
CONCATENATE 'extract program gui status: program:'
<LS_PROG>-NAME
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDTRY.
ENDFORM.                    "get_program_gui_status_wrap

*&---------------------------------------------------------------------*
*&      Form  get_program_syntax_check
*&---------------------------------------------------------------------*
FORM GET_PROGRAM_SYNTAX_CHECK USING PT_PROGRAM_NODE  TYPE HANDLES_TYPE
.

CHECK TESTING_DATA_ONLY IS INITIAL.

DATA: ERRORS_NODE  TYPE XML_ELEMENT.
DATA: COMPILER TYPE REF TO CL_ABAP_COMPILER.
DATA: ERRORS TYPE SYNT_ERRORS,
ERROR LIKE LINE OF ERRORS.
DATA: MAIN_PROG TYPE PROGRAM.
DATA: OREF TYPE REF TO CX_ROOT.
DATA: ERROR_MESSAGE TYPE STRING,
RC(2) TYPE C.
DATA: BEGIN OF SOURCE_TAB OCCURS 100,
LINE(80),
END OF SOURCE_TAB.
FIELD-SYMBOLS: <LS_PROG>    LIKE LT_PROG_EXP.

ASSIGN PT_PROGRAM_NODE-WA->* TO <LS_PROG>.
CHECK <LS_PROG>-SUBC <> 'I' OR <LS_PROG>-NAME(2) = 'ZX'.

TRY.
IF <LS_PROG>-NAME(2) = 'ZX'.

CONCATENATE 'SAPL' <LS_PROG>-NAME+1(4) INTO MAIN_PROG.

CREATE OBJECT COMPILER
EXPORTING
P_NAME             = MAIN_PROG
P_INCLUDE          = <LS_PROG>-NAME
*           p_includes         =
*           p_only_interface   =
EXCEPTIONS
PROGRAM_NAME_EMPTY = 1
OTHERS             = 2.
ELSE.
CREATE OBJECT COMPILER
EXPORTING
P_NAME             = <LS_PROG>-NAME
*           p_include          =
*           p_includes         =
*           p_only_interface   =
EXCEPTIONS
PROGRAM_NAME_EMPTY = 1
OTHERS             = 2.

ENDIF.

RC = SY-SUBRC.
CONCATENATE 'SYNTAX CHECK DEBUG: ' <LS_PROG>-NAME
'1. compiler initialized. rc:' RC
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

CALL METHOD COMPILER->GET_ALL
IMPORTING
*         p_result =
P_ERRORS = ERRORS.

IF ERRORS[] IS INITIAL AND <LS_PROG>-SUBC <> 'I'.
CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
'2.1. no errors found, trying with the function'
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

CALL FUNCTION 'RS_SYNTAX_CHECK'
EXPORTING
I_GLOBAL_CHECK         = 'X'
I_GLOBAL_PROGRAM       = <LS_PROG>-NAME
I_PROGRAM              = ''
*          I_WITH_DIALOG          = ' '
IMPORTING
O_ERROR_INCLUDE        = ERROR-INCNAME
O_ERROR_LINE           = ERROR-LINE
O_ERROR_MESSAGE        = ERROR-MESSAGE
O_ERROR_OFFSET         = ERROR-COL
*          O_ERROR_SUBRC          =
*          O_NAVIGATE             =
*          CANCEL                 =
TABLES
I_SOURCE               = SOURCE_TAB
.

IF NOT ERROR-MESSAGE IS INITIAL.
CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
'2.2. found error with func: ' ERROR-MESSAGE
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

APPEND ERROR TO ERRORS.
CLEAR ERROR.
ELSE.
CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
'2.2. no error with func. '
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ELSE.
LOOP AT ERRORS INTO ERROR.
CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
'2. found error: ' ERROR-MESSAGE
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDLOOP.
ENDIF.

CHECK NOT ERRORS[] IS INITIAL.

*     Create a node for the Program Text Elements
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
PT_PROGRAM_NODE-NODE_REF
'SYNTAX_ERRORS'
CHANGING ERRORS_NODE.

*     Add the Text Elements data to the current program
PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES ERRORS
USING G_IREF_PDOCUMENT
ERRORS_NODE 'ERROR'.

CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
'3. added errors to xml'
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.

CATCH CX_ROOT INTO OREF.

CALL METHOD OREF->GET_TEXT
RECEIVING
RESULT = ERROR_MESSAGE.

CONCATENATE 'SYNTAX CHECK DEBUG:' <LS_PROG>-NAME
'4. caught excpetion, message:' ERROR_MESSAGE
INTO GT_ETL_MESSAGE-MESSAGE
SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDTRY.

ENDFORM.                    " get_program_syntax_check

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_INDUSTRY_SOLUTION
*&---------------------------------------------------------------------*
FORM EXTRACT_INDUSTRY_SOLUTION.

DATA: BF_ACTIVE_TAB TYPE TABLE OF SFW_ACTIVE_B2,
SFW_SWITCH_STATE_ITAB TYPE TABLE OF SFW_SWITCH_STATE,
SFW_ACTIVE_BSET_ITAB TYPE TABLE OF SFW_ACTIVE_BSET,
SFW_ACTIVE_BFUNC_ITAB TYPE TABLE OF SFW_ACTIVE_BFUNC.

PERFORM UPDATE_PROGRESS USING
'Extracting industry solution BFs'.

* Extract activate business functions (BF_ACTIVE_TAB)
PERFORM APPEND_STRING_TO_FILE USING '<ACTIVE_BUSINESS_FUNCTIONS>'.

SELECT * FROM SFW_ACTIVE_B2
INTO TABLE BF_ACTIVE_TAB.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES BF_ACTIVE_TAB
USING G_IREF_PDOCUMENT
'SFW_ACTIVE_B2'.
PERFORM APPEND_STRING_TO_FILE USING '</ACTIVE_BUSINESS_FUNCTIONS>'.

FREE BF_ACTIVE_TAB.

* extract Swith States ( SFW_SWITCH_STATE )
PERFORM APPEND_STRING_TO_FILE USING '<SWITCH_STATES>'.

SELECT * FROM SFW_SWITCH_STATE
INTO TABLE SFW_SWITCH_STATE_ITAB.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_SWITCH_STATE_ITAB
USING G_IREF_PDOCUMENT
'SFW_SWITCH_STATE'.
PERFORM APPEND_STRING_TO_FILE USING '</SWITCH_STATES>'.

FREE SFW_SWITCH_STATE_ITAB.

* extract Active Business Functions set ( SFW_ACTIVE_BSET )
PERFORM APPEND_STRING_TO_FILE USING '<ACTIVE_BSET>'.

SELECT * FROM SFW_ACTIVE_BSET
INTO TABLE SFW_ACTIVE_BSET_ITAB.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_ACTIVE_BSET_ITAB
USING G_IREF_PDOCUMENT
'SFW_ACTIVE_BSET'.

PERFORM APPEND_STRING_TO_FILE USING '</ACTIVE_BSET>'.

FREE SFW_ACTIVE_BSET_ITAB.

* extract Active Business Functions( SFW_ACTIVE_BFUNC )
PERFORM APPEND_STRING_TO_FILE USING '<ACTIVE_BFUNCS>'.

SELECT * FROM SFW_ACTIVE_BFUNC
INTO TABLE SFW_ACTIVE_BFUNC_ITAB.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_ACTIVE_BFUNC_ITAB
USING G_IREF_PDOCUMENT
'SFW_ACTIVE_BFUNC'.

PERFORM APPEND_STRING_TO_FILE USING '</ACTIVE_BFUNCS>'.

FREE SFW_ACTIVE_BFUNC_ITAB.

* extract the BF data from prod as well
PERFORM EXTRACT_PROD_INDUSTRY_SOLUTION.

ENDFORM.                    " EXTRACT_INDUSTRY_SOLUTION

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROD_INDUSTRY_SOLUTION
*&---------------------------------------------------------------------*
FORM EXTRACT_PROD_INDUSTRY_SOLUTION.

DATA: BF_ACTIVE_TAB TYPE TABLE OF SFW_ACTIVE_B2,
BF_ACTIVE_WA LIKE LINE OF BF_ACTIVE_TAB,
SFW_SWITCH_STATE_ITAB TYPE TABLE OF SFW_SWITCH_STATE,
SFW_ACTIVE_BSET_ITAB TYPE TABLE OF SFW_ACTIVE_BSET,
SFW_ACTIVE_BFUNC_ITAB TYPE TABLE OF SFW_ACTIVE_BFUNC,
SFW_ACTIVE_BFUNC_WA LIKE LINE OF SFW_ACTIVE_BFUNC_ITAB,
TAB_DATA TYPE TABLE OF TAB512,
LS_DATA LIKE LINE OF TAB_DATA,
SEL TYPE TABLE OF RFC_DB_OPT,
FIELDS_TAB TYPE TABLE OF RFC_DB_FLD.


PERFORM UPDATE_PROGRESS USING
'Extracting prod industry solution BFs'.

* Extract activate business functions (BF_ACTIVE_TAB)
PERFORM APPEND_STRING_TO_FILE USING
'<PROD_ACTIVE_BUSINESS_FUNCTIONS>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[], LS_DATA.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'SFW_ACTIVE_B2'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.
IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of SFW_ACTIVE_B2.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY
SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

*   The data cannot be parsed automatically because of the decimals.
LOOP AT TAB_DATA INTO LS_DATA.
BF_ACTIVE_WA-VERSION = LS_DATA-WA(1).
BF_ACTIVE_WA-BFUNCTION = LS_DATA-WA+1(30).
BF_ACTIVE_WA-SWITCH_ON_TIME = LS_DATA-WA+31(15).
APPEND BF_ACTIVE_WA TO BF_ACTIVE_TAB.
ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES BF_ACTIVE_TAB
USING G_IREF_PDOCUMENT
'PROD_SFW_ACTIVE_B2'.
PERFORM APPEND_STRING_TO_FILE USING
'</PROD_ACTIVE_BUSINESS_FUNCTIONS>'.
FREE BF_ACTIVE_TAB.

* extract Swith States ( SFW_SWITCH_STATE )
PERFORM APPEND_STRING_TO_FILE USING '<PROD_SWITCH_STATES>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[], LS_DATA.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'SFW_SWITCH_STATE'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of SFW_SWITCH_STATE.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE
.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

SFW_SWITCH_STATE_ITAB[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_SWITCH_STATE_ITAB
USING G_IREF_PDOCUMENT
'PROD_SFW_SWITCH_STATE'.
PERFORM APPEND_STRING_TO_FILE USING '</PROD_SWITCH_STATES>'.

FREE SFW_SWITCH_STATE_ITAB.

* extract Active Business Functions set ( SFW_ACTIVE_BSET )
PERFORM APPEND_STRING_TO_FILE USING '<PROD_ACTIVE_BSET>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[], LS_DATA.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'SFW_ACTIVE_BSET'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of SFW_ACTIVE_BSET.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY
SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

SFW_ACTIVE_BSET_ITAB[] = TAB_DATA[].

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_ACTIVE_BSET_ITAB
USING G_IREF_PDOCUMENT
'PROD_SFW_ACTIVE_BSET'.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_ACTIVE_BSET>'.

FREE SFW_ACTIVE_BSET_ITAB.

* extract Active Business Functions( SFW_ACTIVE_BFUNC )
PERFORM APPEND_STRING_TO_FILE USING '<PROD_ACTIVE_BFUNCS>'.

CLEAR: SEL[], FIELDS_TAB[], TAB_DATA[], LS_DATA.
CALL FUNCTION 'RFC_READ_TABLE' DESTINATION P_RFCDES
EXPORTING
QUERY_TABLE          = 'SFW_ACTIVE_BFUNC'
DELIMITER            = SPACE
NO_DATA              = SPACE
ROWSKIPS             = 0
ROWCOUNT             = 0
TABLES
OPTIONS              = SEL
FIELDS               = FIELDS_TAB
DATA                 = TAB_DATA
EXCEPTIONS
TABLE_NOT_AVAILABLE  = 1
TABLE_WITHOUT_DATA   = 2
OPTION_NOT_VALID     = 3
FIELD_NOT_VALID      = 4
NOT_AUTHORIZED       = 5
DATA_BUFFER_EXCEEDED = 6
OTHERS               = 7.

IF SY-SUBRC <> 0.
CLEAR ERROR.
CASE SY-SUBRC.
WHEN 1. ERROR = 'TABLE_NOT_AVAILABLE'.
WHEN 2. ERROR = 'TABLE_WITHOUT_DATA'.
WHEN 3. ERROR = 'OPTION_NOT_VALID'.
WHEN 4. ERROR = 'FIELD_NOT_VALID'.
WHEN 5. ERROR = 'NOT_AUTHORIZED'.
WHEN 6. ERROR = 'DATA_BUFFER_EXCEEDED'.
WHEN 7. ERROR = 'OTHERS'.
ENDCASE.

CONCATENATE 'extract prod BF: RFC_READ_TABLE of SFW_ACTIVE_BFUNC.'
'Error:' ERROR INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE
.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.

*   The data cannot be parsed automatically because of the decimals.
LOOP AT TAB_DATA INTO LS_DATA.
SFW_ACTIVE_BFUNC_WA-VERSION = LS_DATA-WA(1).
SFW_ACTIVE_BFUNC_WA-BFUNCTION = LS_DATA-WA+1(30).
SFW_ACTIVE_BFUNC_WA-SWITCH_ON_TIME = LS_DATA-WA+31(15).
APPEND SFW_ACTIVE_BFUNC_WA TO SFW_ACTIVE_BFUNC_ITAB.
ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SFW_ACTIVE_BFUNC_ITAB
USING G_IREF_PDOCUMENT
'PROD_SFW_ACTIVE_BFUNC'.

PERFORM APPEND_STRING_TO_FILE USING '</PROD_ACTIVE_BFUNCS>'.

FREE SFW_ACTIVE_BFUNC_ITAB.

ENDFORM.                    " EXTRACT_INDUSTRY_SOLUTION

*&---------------------------------------------------------------------*
*&      Form  fill_vanilla_programs
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM FILL_VANILLA_PROGRAMS.
*Cloned Program Names

ENDFORM.                    "fill_vanilla_programs

*&---------------------------------------------------------------------*
*&      Form  MOVE_FILE
*&---------------------------------------------------------------------*
*       Move file from initial location to the location specified by
*       user
*----------------------------------------------------------------------*
FORM MOVE_FILE USING P_TEMP_FORE_FILE
P_TEMP_BACK_FILE
P_ORIG_FORE_FILE
P_ORIG_BACK_FILE
P_IS_FORE.

DATA: EXPLAN TYPE STRING,
ERROR_MSG TYPE STRING,
CURR_LINE_LEN  TYPE I,
DATA(256)      TYPE C,
FILENAME1 TYPE STRING,
FILENAME2 TYPE STRING.
DATA: L_OREF TYPE REF TO CX_ROOT,
TEXT TYPE STRING,
TEXT_LEN TYPE I,
PARAM1(50) TYPE C,
PARAM2(50) TYPE C,
PARAM3(50) TYPE C,
PARAM4(50) TYPE C.


IF NOT P_IS_FORE IS INITIAL.

*   Copy the file to original location
FILENAME1 = P_TEMP_FORE_FILE.
FILENAME2 = P_ORIG_FORE_FILE.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_COPY
EXPORTING
SOURCE             = FILENAME1
DESTINATION        = FILENAME2
OVERWRITE          = 'X'
EXCEPTIONS
CNTL_ERROR         = 1
ERROR_NO_GUI       = 2
WRONG_PARAMETER    = 3
DISK_FULL          = 4
ACCESS_DENIED      = 5
FILE_NOT_FOUND     = 6
DESTINATION_EXISTS = 7
UNKNOWN_ERROR      = 8
PATH_NOT_FOUND     = 9
DISK_WRITE_PROTECT = 10
DRIVE_NOT_READY    = 11
OTHERS             = 12.

IF SY-SUBRC <> 0.
IF SY-SUBRC = 4.
EXPLAN = 'Disk is full'.
ELSE.
EXPLAN = SY-SUBRC.
ENDIF.
MESSAGE E001(00) WITH 'Problem writing to file: '
P_ORIG_FORE_FILE
EXPLAN.
ENDIF.

*   Delete the temporary file
DATA: RC TYPE I.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_DELETE
EXPORTING
FILENAME           = P_TEMP_FORE_FILE
CHANGING
RC                 = RC
EXCEPTIONS
FILE_DELETE_FAILED = 1
CNTL_ERROR         = 2
ERROR_NO_GUI       = 3
FILE_NOT_FOUND     = 4
ACCESS_DENIED      = 5
UNKNOWN_ERROR      = 6
OTHERS             = 7.
IF SY-SUBRC <> 0.
EXPLAN = SY-SUBRC.
MESSAGE E001(00) WITH 'Problem deleting file: ' P_TEMP_FORE_FILE
' return code (RC) = ' RC.
ENDIF.

ELSE.
*    Open the temp file
OPEN DATASET P_TEMP_BACK_FILE FOR INPUT IN BINARY
MODE MESSAGE ERROR_MSG.

OPEN DATASET P_ORIG_BACK_FILE FOR OUTPUT IN BINARY MODE
MESSAGE ERROR_MSG.

*   Transfer the data to destination file
DO.
READ DATASET P_TEMP_BACK_FILE INTO DATA LENGTH CURR_LINE_LEN.
IF SY-SUBRC <> 0.
TRANSFER DATA TO P_ORIG_BACK_FILE
LENGTH CURR_LINE_LEN.
EXIT.
ENDIF.
TRANSFER DATA TO P_ORIG_BACK_FILE LENGTH CURR_LINE_LEN.
ENDDO.

*   Close both files
CLOSE DATASET P_TEMP_BACK_FILE.
CLOSE DATASET P_ORIG_BACK_FILE.

*   Delete the file from current directory
DELETE DATASET P_TEMP_BACK_FILE.

IF SY-SUBRC <> 0.
MESSAGE E001(00) WITH 'Problem deleting file: ' P_TEMP_BACK_FILE
' SUBC: ' SY-SUBRC.
EXIT.
ENDIF.
ENDIF.
ENDFORM.                    " MOVE_FILE

*&---------------------------------------------------------------------*
*&      Form  VALIDATE_FILE
*&---------------------------------------------------------------------*
*       Read the file till the end and validate that it ends with
*       ROOT_ELEMENT
*----------------------------------------------------------------------*
FORM VALIDATE_FILE USING P_ORIG_FORE_FILE
P_ORIG_BACK_FILE
P_IS_FORE.

DATA: L_FILE  TYPE STRING,
L_LENGTH TYPE I,
DATA TYPE TABLE OF STRING,
EXPLAN TYPE STRING,
NO_OF_LINES TYPE I,
LAST_LINE TYPE STRING,
ERROR_MSG TYPE STRING,
CURR_LINE TYPE STRING.

IF NOT P_IS_FORE IS INITIAL.

* Read the file
L_FILE = P_ORIG_FORE_FILE.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>GUI_UPLOAD
EXPORTING
FILENAME                = L_FILE
FILETYPE                = 'ASC'
IMPORTING
FILELENGTH              = L_LENGTH
CHANGING
DATA_TAB                = DATA
EXCEPTIONS
FILE_OPEN_ERROR         = 1
FILE_READ_ERROR         = 2
NO_BATCH                = 3
GUI_REFUSE_FILETRANSFER = 4
INVALID_TYPE            = 5
NO_AUTHORITY            = 6
UNKNOWN_ERROR           = 7
BAD_DATA_FORMAT         = 8
HEADER_NOT_ALLOWED      = 9
SEPARATOR_NOT_ALLOWED   = 10
HEADER_TOO_LONG         = 11
UNKNOWN_DP_ERROR        = 12
ACCESS_DENIED           = 13
DP_OUT_OF_MEMORY        = 14
DISK_FULL               = 15
DP_TIMEOUT              = 16
OTHERS                  = 17.

IF SY-SUBRC <> 0.
EXPLAN = SY-SUBRC.
MESSAGE E001(00) WITH 'Problem reading file for validation: '
P_ORIG_FORE_FILE ' return code (RC) = ' EXPLAN.
ENDIF.

* Check that the last line is </ROOT_ELEMENT>. If not - show an error.
DESCRIBE TABLE DATA LINES NO_OF_LINES.
READ TABLE DATA INDEX NO_OF_LINES INTO LAST_LINE.
IF LAST_LINE <> '</ROOT_ELEMENT>'.
MESSAGE E001(00) WITH
'The file was created cut.'
'Please rerun the program to create a new file.'.
ENDIF.

ELSE.

*  Read file
OPEN DATASET P_ORIG_BACK_FILE FOR INPUT IN TEXT MODE ENCODING
UTF-8
MESSAGE ERROR_MSG.

IF NOT SY-SUBRC IS INITIAL.
MESSAGE E001(00) WITH 'Problem reading file: ' P_ORIG_BACK_FILE
' SUBC: ' ERROR_MSG.
EXIT.
ENDIF.

* Check that the last line is </ROOT_ELEMENT>. If not - show an error.
DO.
READ DATASET P_ORIG_BACK_FILE INTO CURR_LINE.
IF SY-SUBRC <> 0.
EXIT.
ENDIF.
LAST_LINE = CURR_LINE.
ENDDO.
IF LAST_LINE <> '</ROOT_ELEMENT>'.
MESSAGE E001(00) WITH
'The file was created cut.'
'Please rerun the program to create a new file.'.
ENDIF.

CLOSE DATASET P_ORIG_BACK_FILE.

ENDIF.
ENDFORM.                    "VALIDATE_FILE
*&---------------------------------------------------------------------*
*&      Form  get_rfc_list
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM GET_RFC_LIST.

DATA : LT_RFCDES TYPE STANDARD TABLE OF RFCDES,
LS_RFCDES TYPE RFCDES,
LS_RFCDISPLAY TYPE RFCDISPLAY.

CLEAR : GT_RFCS[].

SELECT *
FROM RFCDES BYPASSING BUFFER
INTO CORRESPONDING FIELDS OF TABLE LT_RFCDES
WHERE RFCTYPE = '3'.

IF SY-SUBRC = 0.

LOOP AT LT_RFCDES INTO LS_RFCDES.

CLEAR LS_RFCDISPLAY.
CALL FUNCTION 'RFCDES2RFCDISPLAY'
EXPORTING
IMPORT_RFCDES                 = LS_RFCDES
*        AUTHORITY_CHECK               = ' '
IMPORTING
EXPORT_RFCDISPLAY             = LS_RFCDISPLAY
EXCEPTIONS
FORMAT_ERROR                  = 1
AUTHORITY_NOT_AVAILABLE       = 2
OTHERS                        = 3.

IF SY-SUBRC <> 0.
ELSE.
APPEND LS_RFCDISPLAY TO GT_RFCS.
ENDIF.

ENDLOOP.
ENDIF.

ENDFORM.                    " get_rfc_list
*&---------------------------------------------------------------------*
*&      Form  READ_PROGRAM_INCLUDES
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_INCLUDE  text
*      -->P_LV_PROGNAME  text
*----------------------------------------------------------------------*
FORM READ_PROGRAM_INCLUDES TABLES INCLUDE_TABLE
USING INCLNAME LIKE TRDIR-NAME.

** !! code from: RS_GET_LOW_LEVEL_INCLUDES (not for programs only)
DATA: SEDI_TK TYPE  STOKESX OCCURS 0.
DATA: TK LIKE SEDI_TK WITH HEADER LINE.
DATA: TK_INDEX LIKE SY-TABIX,
INCL LIKE TRDIR-NAME,
DEVCLASS LIKE TADIR-DEVCLASS,
SOURCE_TABLE TYPE RSWSOURCET,
MSG(132),
WRD(30),
ROW LIKE TK-ROW,
COL LIKE TK-COL.
DATA: BEGIN OF KW OCCURS 10,
LINE(30),
END OF KW.
DATA  BEGIN OF STM OCCURS 1000.
INCLUDE STRUCTURE SSTMNT.
DATA  END OF STM.
DATA  BEGIN OF LV OCCURS 100.
INCLUDE STRUCTURE SLEVEL.
DATA  END OF LV.
DATA: TRDIR_WA LIKE TRDIR.

REFRESH INCLUDE_TABLE.

READ REPORT INCLNAME INTO SOURCE_TABLE.
REFRESH: KW, TK, STM, LV. CLEAR: KW, TK, STM, LV.

KW = 'INCLUDE'.            APPEND KW.
SCAN ABAP-SOURCE SOURCE_TABLE
TOKENS     INTO TK
STATEMENTS INTO STM
LEVELS     INTO LV
*                          OVERFLOW INTO OVERFLOW_AREA
KEYWORDS FROM KW
*          program from src_name
WITH ANALYSIS
WITH INCLUDES
WITHOUT TRMAC
MESSAGE INTO MSG
WORD    INTO WRD
INCLUDE INTO INCL
LINE    INTO ROW
OFFSET  INTO COL.

IF NOT SY-SUBRC IS INITIAL.
EXIT.
ENDIF.

LOOP AT STM.
READ TABLE TK INDEX STM-FROM.
IF TK-STR = 'INCLUDE'.
TK_INDEX = STM-FROM + 1.
READ TABLE TK INDEX TK_INDEX.
IF TK-STR NE 'STRUCTURE' AND TK-STR NE 'TYPE' AND
TK-STR(1) NE '<' AND TK-STR(1) NE '>' AND TK-STR(1) NE '%' .
INCLUDE_TABLE = TK-STR.
SELECT SINGLE * FROM TRDIR INTO TRDIR_WA
WHERE NAME = INCLUDE_TABLE.
IF SY-SUBRC = 0.
APPEND INCLUDE_TABLE.
ENDIF.
ENDIF.
ENDIF.
ENDLOOP.

ENDFORM.                   " READ_PROGRAM_INCLUDES

*&---------------------------------------------------------------------*
*&      Form  add_used_memory_to_log
*&---------------------------------------------------------------------*
FORM ADD_USED_MEMORY_TO_LOG.

DATA: MEM_SIZE TYPE ABAP_MSIZE,
MEM(25) TYPE C,
MEM_TEXT(50) TYPE C.

IF SY-BATCH = 'X'.
*   Used memory log message
CALL METHOD CL_ABAP_MEMORY_UTILITIES=>GET_TOTAL_USED_SIZE
IMPORTING
SIZE = MEM_SIZE.
MEM = MEM_SIZE.
CONCATENATE 'Used memory:' MEM INTO MEM_TEXT SEPARATED BY SPACE.
MESSAGE S000(CONV) WITH MEM_TEXT.
PERFORM ADD_MESSAGE USING MEM_TEXT ABAP_TRUE.
ENDIF.

ENDFORM.                 " add_used_memory_to_log
*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WEB_USAGE_CONFIG
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_NODE_REF text
*----------------------------------------------------------------------*
FORM EXTRACT_WEB_USAGE_CONFIG USING P_NODE_REF TYPE XML_ELEMENT.

DATA:PARAMETER_TABLE TYPE  SAPWLCOLPARAMS,
PARAMETER_WA    TYPE  SAPWLCOLPA,
WA_LIST         TYPE SAPWLPARNS,
T_LIST          TYPE SAPWLPARAMNAMES,
WEB_CONFIG_NODE TYPE XML_ELEMENT.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
P_NODE_REF
'WEB_STAT_CONFIG'
CHANGING WEB_CONFIG_NODE.

* This code is taken from program SWNC_CONFIG_URL.
* Check the system's configuration
WA_LIST-PARAMNAME  = 'HTTP_STATREC_PATH_SPLIT_RULE'.
APPEND WA_LIST TO T_LIST.
WA_LIST-PARAMNAME  = 'HTTP_STATREC_PATH_SPLIT_RULE_WEB'.
APPEND WA_LIST TO T_LIST.

CALL FUNCTION 'SAPWL_PARAMETERS_READ'
EXPORTING
PARAMETER_LIST      = T_LIST
IMPORTING
PARAMETER_TABLE     = PARAMETER_TABLE
EXCEPTIONS
PARAMETER_NOT_FOUND = 1
OTHERS              = 2.

READ TABLE PARAMETER_TABLE INTO PARAMETER_WA WITH KEY PARAMNAME =
'HTTP_STATREC_PATH_SPLIT_RULE'.
IF SY-SUBRC = 0.
PERFORM ADD_ATTRIBUTE_TO_NODE USING WEB_CONFIG_NODE
'TRANS_PROFILE' PARAMETER_WA-PAR_INTVAL.
ENDIF.
READ TABLE PARAMETER_TABLE INTO PARAMETER_WA WITH KEY PARAMNAME =
'HTTP_STATREC_PATH_SPLIT_RULE_WEB'.
IF SY-SUBRC = 0.
PERFORM ADD_ATTRIBUTE_TO_NODE USING WEB_CONFIG_NODE 'WEB_CONFIG'
PARAMETER_WA-PAR_INTVAL.
ENDIF.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING WEB_CONFIG_NODE 'X'.

ENDFORM.                    "EXTRACT_WEB_USAGE_CONFIG
*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WEB_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_TCODE    text
*      -->P_TYPE     text
*      -->P_NODE_REF text
*----------------------------------------------------------------------*
FORM EXTRACT_WEB_DATA USING P_TCODE TYPE CHAR255
P_TYPE TYPE CHAR1
P_NODE_REF TYPE XML_ELEMENT.

DATA: WEBDYN_NODE TYPE XML_ELEMENT,
WEB_ENTRY_ID TYPE SWNCENTRYID,
WEB_DATA_WA TYPE SWNCAGGWEBDEST.

IF NOT G_WEB_DATA[] IS INITIAL.
*Check if there is an entry for this transaction in the web data
*         if so, mark it as web
*          CONCATENATE RECORD-TCODE RECORD-TYPE INTO WEB_ENTRY_ID.
WEB_ENTRY_ID = P_TCODE.
WEB_ENTRY_ID+72(1) = P_TYPE.
READ TABLE G_WEB_DATA WITH KEY ENTRY_ID = WEB_ENTRY_ID INTO
WEB_DATA_WA.
IF SY-SUBRC IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
P_NODE_REF
'WEBDYN'
CHANGING WEBDYN_NODE.
ENDIF.
ENDIF.
ENDFORM.                    "EXTRACT_WEB_DATA

*---------------------------------------------------------------------*
*       FORM EXTRACT_UPL_DATA                                         *
*---------------------------------------------------------------------*
FORM EXTRACT_UPL_DATA.
DATA: L_T_DATA TYPE STANDARD TABLE OF UPL_DATA
WITH DEFAULT KEY INITIAL SIZE 10,
UPL_NODE TYPE XML_ELEMENT,
UPL_SYS_NODE TYPE XML_ELEMENT,
L_STARTTIME LIKE SY-UZEIT.

* Check if upl data is needed and there is a solman connection.
CHECK NOT G_EXTRACT_UPL IS INITIAL AND NOT P_SM_RFC IS INITIAL.

L_STARTTIME = SY-UZEIT.

PERFORM UPDATE_PROGRESS USING 'Extracting UPL Data'.

* Get the upl data
PERFORM GET_UPL_DATA TABLES L_T_DATA.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT G_IREF_ROOT_ELEM
'UPL_USAGE'
CHANGING UPL_NODE.

PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT UPL_NODE
'UPL_SYSTEM'
CHANGING UPL_SYS_NODE.
PERFORM ADD_ATTRIBUTE_TO_NODE USING UPL_SYS_NODE
'SYSTEM_NAME'
RFC_SYSID.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES L_T_DATA
USING G_IREF_PDOCUMENT UPL_NODE
'UPL'.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING UPL_NODE 'X'.

PERFORM ADD_TIME_STAT USING 'Extract UPL' L_STARTTIME.

ENDFORM.                    " extract_upl_data
*---------------------------------------------------------------------*
*       FORM GET_UPL_DATA                                             *
*---------------------------------------------------------------------*
FORM GET_UPL_DATA TABLES P_T_DATA TYPE UPL_DATA_TAB.
TYPE-POOLS: RS, RSDRC.
DATA:
I_T_SFK      TYPE RSDRI_T_SFK,
I_L_SFK      TYPE LINE OF RSDRI_T_SFK,
RANGE_WA     TYPE SM_RSDRI_S_RANGE_RFC,
E_T_RFCDATA  TYPE RSDRI_T_RFCDATA,
E_T_FIELD    TYPE RSDP0_T_FIELD,
L_S_DATA     TYPE UPL_DATA,
FINAL_UPL_T  TYPE TABLE OF UPL_DATA,
FINAL_WA     TYPE UPL_DATA,
RFC_DATA_WA  TYPE RSDRI_S_RFCDATA,
MONTH(6)      TYPE N,
L_T_SFC      TYPE TABLE OF RSDRI_S_SFC,
L_T_RANGE    TYPE TABLE OF SM_RSDRI_S_RANGE_RFC,
SUBRC(4)     TYPE N,
METH_KEY     TYPE SEOCPDKEY,
PSMODISRC    TYPE TABLE OF SMODISRC,
PSMODILOG    TYPE TABLE OF SMODILOG,
PSOURCE      TYPE TABLE OF ABAPTXT255,
PTRDIR       TYPE TABLE OF TRDIR,
PTRDIR_WA    TYPE TRDIR,
UPL_LINES    TYPE I,
S_UPL_LINES  TYPE STRING.

* The sfc sets what fields will be returning full from the BW data cube
PERFORM FILL_SFC TABLES L_T_SFC.

*
I_L_SFK-KYFNM = '0SM_CCLPE'.
I_L_SFK-KYFALIAS = 'SM_CCLPE'.
I_L_SFK-AGGR = 'SUM'.

PERFORM FILL_OBJECT_RANGE TABLES L_T_RANGE
CHANGING MONTH.


DO UPL_MONTH_NUMBER TIMES.
*   Set the wanted month
CLEAR E_T_RFCDATA[].
READ TABLE L_T_RANGE WITH KEY CHANM = '0CALMONTH' INTO RANGE_WA.
RANGE_WA-LOW = MONTH.
MODIFY L_T_RANGE INDEX SY-TABIX FROM RANGE_WA TRANSPORTING LOW.

CONCATENATE 'UPL: Getting UPL data for month ' MONTH
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

*   Read the UPL data
CALL FUNCTION 'RSDRI_INFOPROV_READ_RFC' DESTINATION P_SM_RFC
EXPORTING
I_INFOPROV             = '0SM_UPL'
I_REFERENCE_DATE       = SY-DATUM
I_SAVE_IN_TABLE        = ' '
I_SAVE_IN_FILE         = ' '
I_AUTHORITY_CHECK      = RSDRC_C_AUTHCHK-READ
TABLES
I_T_SFC                = L_T_SFC
I_T_SFK                = I_T_SFK
I_T_RANGE              = L_T_RANGE
E_T_RFCDATA            = E_T_RFCDATA
E_T_FIELD              = E_T_FIELD
EXCEPTIONS
ILLEGAL_INPUT          = 1
ILLEGAL_INPUT_SFC      = 2
ILLEGAL_INPUT_SFK      = 3
ILLEGAL_INPUT_RANGE    = 4
ILLEGAL_INPUT_TABLESEL = 5
NO_AUTHORIZATION       = 6
GENERATION_ERROR       = 7
ILLEGAL_DOWNLOAD       = 8
ILLEGAL_TABLENAME      = 9
ILLEGAL_RESULTTYPE     = 10
X_MESSAGE              = 11
DATA_OVERFLOW          = 12
OTHERS                 = 13.

IF SY-SUBRC IS INITIAL.
*     Add the the lines of the current week upl to the aggregated list
*      APPEND LINES OF E_T_RFCDATA TO AGR_RFC_DATA.

CLEAR FINAL_WA.
CLEAR FINAL_UPL_T.
*     Get the data into the upl structure type
PERFORM CONVERT_TO_STRUCT TABLES E_T_RFCDATA
E_T_FIELD
FINAL_UPL_T
USING  RFC_DATA_WA
FINAL_WA.
CLEAR E_T_RFCDATA[].
CLEAR E_T_FIELD[].
*     Go over the data received in this itaration and sum the usage
LOOP AT FINAL_UPL_T INTO FINAL_WA.
*       Check if the process unit is already in the table
READ TABLE P_T_DATA WITH KEY SM_CCLPN = FINAL_WA-SM_CCLPN
SM_CCLOT = FINAL_WA-SM_CCLOT
SM_CCLON = FINAL_WA-SM_CCLON
SM_CCLNS = FINAL_WA-SM_CCLNS
SM_CCLTP = FINAL_WA-SM_CCLTP
SM_CCLNP = FINAL_WA-SM_CCLNP
SM_CCLPE = FINAL_WA-SM_CCLPE
INTO L_S_DATA.

IF SY-SUBRC IS INITIAL.
*         Add another usage
L_S_DATA-MONTH_USED = L_S_DATA-MONTH_USED + 1.
MODIFY P_T_DATA FROM L_S_DATA INDEX SY-TABIX.
ELSE.
*         Add the process unit to the table
L_S_DATA-SM_CCLPN = FINAL_WA-SM_CCLPN.
L_S_DATA-SM_CCLOT = FINAL_WA-SM_CCLOT.
L_S_DATA-SM_CCLON = FINAL_WA-SM_CCLON.
L_S_DATA-SM_CCLNS = FINAL_WA-SM_CCLNS.
L_S_DATA-SM_CCLTP = FINAL_WA-SM_CCLTP.
L_S_DATA-SM_CCLNP = FINAL_WA-SM_CCLNP.
L_S_DATA-CALMONTH = MONTH.
L_S_DATA-MONTH_USED = 1.
APPEND L_S_DATA TO P_T_DATA.
ENDIF.
ENDLOOP.

CLEAR FINAL_WA.
CLEAR FINAL_UPL_T.

ELSE.
SUBRC = SY-SUBRC.
CONCATENATE 'UPL: Error getting UPL month ' MONTH ' system '
RFC_SYSID '. SUBRC ' SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.
ENDIF.
*   Set the week to be the previous month
MONTH = MONTH - 1.
IF MONTH+4(2) = '00'.
MONTH = MONTH - 1.
MONTH+4(2) = 12.
ENDIF.
ENDDO.

DESCRIBE TABLE P_T_DATA LINES UPL_LINES.
S_UPL_LINES = UPL_LINES.
CONCATENATE 'UPL: UPL Lines number extracted ' S_UPL_LINES INTO
GT_ETL_MESSAGE SEPARATED BY SPACE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

GT_ETL_MESSAGE = 'UPL: Start getting the methods includes'.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
MESSAGE S000(CONV) WITH GT_ETL_MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_TRUE.

* Go over the methods and get their include name
LOOP AT P_T_DATA INTO L_S_DATA WHERE SM_CCLTP = 'METH'.

METH_KEY-CLSNAME = FINAL_WA-SM_CCLON.
METH_KEY-CPDNAME = FINAL_WA-SM_CCLNP.
CLEAR PTRDIR.

CALL FUNCTION 'METH_GET_OBJECT'
EXPORTING
METHODKEY               = METH_KEY
*       R3STATE                 = 'A'
TABLES
PSMODISRC               = PSMODISRC
PSMODILOG               = PSMODILOG
PSOURCE                 = PSOURCE
PTRDIR                  = PTRDIR
EXCEPTIONS
VERSION_NOT_FOUND       = 1
METH_NOT_EXIST          = 2
OTHERS                  = 3.

CLEAR PSOURCE[].
CLEAR PSMODISRC[].
CLEAR PSMODILOG[].

READ TABLE PTRDIR INDEX 1 INTO PTRDIR_WA.
IF SY-SUBRC IS INITIAL.
L_S_DATA-METHOD_INC = PTRDIR_WA-NAME.
ENDIF.
ENDLOOP.

ENDFORM.                              "get_upld_data

*---------------------------------------------------------------------*
*       FORM FILL_SFC                                                 *
*---------------------------------------------------------------------*
FORM FILL_SFC TABLES G_TH_SFC STRUCTURE RSDRI_S_SFC.

DATA:
G_S_SFC      TYPE RSDRI_S_SFC.

* Program name
CLEAR G_S_SFC.
*   --- name of characteristic
G_S_SFC-CHANM    = '0SM_CCLPN'.
*   --- name of corresponding column in G_T_DATA
G_S_SFC-CHAALIAS = 'SM_CCLPN'.
*   --- no ORDER-BY
G_S_SFC-ORDERBY  = 0.
*   --- include into list of characteristics
INSERT G_S_SFC INTO TABLE G_TH_SFC.


* Object Name
CLEAR G_S_SFC.
G_S_SFC-CHANM    = '0SM_CCLON'.
G_S_SFC-CHAALIAS = 'SM_CCLON'.
G_S_SFC-ORDERBY  = 0.
INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Month in year
CLEAR G_S_SFC.
G_S_SFC-CHANM    = '0CALMONTH'.
G_S_SFC-CHAALIAS = 'CALMONTH'.
G_S_SFC-ORDERBY  = 0.
INSERT G_S_SFC INTO TABLE G_TH_SFC.

* System ID
CLEAR G_S_SFC.
G_S_SFC-CHANM    = '0SMD_LSID'.
G_S_SFC-CHAALIAS = 'SMD_LSID'.
G_S_SFC-ORDERBY  = 0.
INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Object Type
CLEAR G_S_SFC.
G_S_SFC-CHANM    = '0SM_CCLOT'.
G_S_SFC-CHAALIAS = 'SM_CCLOT'.
G_S_SFC-ORDERBY  = 0.
INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Namespace
CLEAR G_S_SFC.
G_S_SFC-CHANM    = '0SM_CCLNS'.
G_S_SFC-CHAALIAS = 'SM_CCLNS'.
G_S_SFC-ORDERBY  = 0.
INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Processing Type
CLEAR G_S_SFC.
G_S_SFC-CHANM    = '0SM_CCLTP'.
G_S_SFC-CHAALIAS = 'SM_CCLTP'.
G_S_SFC-ORDERBY  = 0.
INSERT G_S_SFC INTO TABLE G_TH_SFC.

* Processing block
CLEAR G_S_SFC.
G_S_SFC-CHANM    = '0SM_CCLNP'.
G_S_SFC-CHAALIAS = 'SM_CCLNP'.
G_S_SFC-ORDERBY  = 0.
INSERT G_S_SFC INTO TABLE G_TH_SFC.
ENDFORM.                    "fill_sfc
*---------------------------------------------------------------------*
*       FORM FILL_UPL_RANGE                                           *
*---------------------------------------------------------------------*
FORM FILL_UPL_RANGE TABLES G_T_RANGE
USING  FIELD_NAME
VALUE
OPTION
SIGN.
DATA:
G_S_RANGE TYPE SM_RSDRI_S_RANGE_RFC.

CLEAR G_S_RANGE.
G_S_RANGE-CHANM    = FIELD_NAME.
G_S_RANGE-SIGN     = SIGN.
G_S_RANGE-COMPOP   = OPTION.
G_S_RANGE-LOW      = VALUE.
APPEND G_S_RANGE TO G_T_RANGE.

ENDFORM.                    "fill_upl_range
*---------------------------------------------------------------------*
*       FORM CONVERT_TO_STRUCT                                        *
*---------------------------------------------------------------------*
FORM  CONVERT_TO_STRUCT TABLES TAB_DATA TYPE RSDRI_T_RFCDATA
FIELDS STRUCTURE RSDP0_S_FIELD
FINAL_TABLE
USING  TAB_WA TYPE RSDRI_S_RFCDATA
FINAL_WA TYPE UPL_DATA.

DATA:
STRING_WA(1050) TYPE C,
D_LENGTH TYPE I VALUE 8,
T_LENGTH TYPE I VALUE 6,
OFFSET TYPE I VALUE 0,
FIELD_WA TYPE RSDP0_S_FIELD,
SM_CCLPN_POS TYPE I,
SM_CCLPN_LEN TYPE I,
SM_CCLOT_POS TYPE I,
SM_CCLOT_LEN TYPE I,
SM_CCLON_POS TYPE I,
SM_CCLON_LEN TYPE I,
SM_CCLNS_POS TYPE I,
SM_CCLNS_LEN TYPE I,
SM_CCLTP_POS TYPE I,
SM_CCLTP_LEN TYPE I,
SM_CCLNP_POS TYPE I,
SM_CCLNP_LEN TYPE I,
CALMONTH_POS TYPE I,
CALMONTH_LEN TYPE I,
SM_CCLPE_POS TYPE I,
SM_CCLPE_LEN TYPE I,
CUR_ROW TYPE I.

IF NOT TAB_DATA[] IS INITIAL.
*   Get the offset and length of all of the fields that are needed
LOOP AT FIELDS INTO FIELD_WA.
IF FIELD_WA-FIELDTYPE = 'D'.
FIELD_WA-FIELDLENGTH = D_LENGTH.
ELSEIF FIELD_WA-FIELDTYPE = 'T'.
FIELD_WA-FIELDLENGTH = T_LENGTH.
ENDIF.

IF FIELD_WA-FIELDNAME = '0SM_CCLPN'.
SM_CCLPN_POS = OFFSET + 1.
SM_CCLPN_LEN = FIELD_WA-FIELDLENGTH.
ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLOT'.
SM_CCLOT_POS = OFFSET + 1.
SM_CCLOT_LEN = FIELD_WA-FIELDLENGTH.
ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLON'.
SM_CCLON_POS = OFFSET + 1.
SM_CCLON_LEN = FIELD_WA-FIELDLENGTH.
ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLNS'.
SM_CCLNS_POS = OFFSET + 1 .
SM_CCLNS_LEN = FIELD_WA-FIELDLENGTH.
ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLTP'.
SM_CCLTP_POS = OFFSET + 1.
SM_CCLTP_LEN = FIELD_WA-FIELDLENGTH.
ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLNP'.
SM_CCLNP_POS = OFFSET + 1.
SM_CCLNP_LEN = FIELD_WA-FIELDLENGTH.
ELSEIF FIELD_WA-FIELDNAME = '0CALMONTH'.
CALMONTH_POS = OFFSET + 1.
CALMONTH_LEN = FIELD_WA-FIELDLENGTH.
ELSEIF FIELD_WA-FIELDNAME = '0SM_CCLPE'.
SM_CCLPE_POS = OFFSET + 1.
SM_CCLPE_LEN = FIELD_WA-FIELDLENGTH.
ENDIF.
OFFSET = OFFSET + FIELD_WA-FIELDLENGTH.
ENDLOOP.

CUR_ROW = 1.
LOOP AT TAB_DATA INTO TAB_WA.

OFFSET = ( CUR_ROW - 1 ) * 255.
STRING_WA+OFFSET = TAB_WA.
IF TAB_WA-CONT IS INITIAL.
FINAL_WA-SM_CCLPN = STRING_WA+SM_CCLPN_POS(SM_CCLPN_LEN).
FINAL_WA-SM_CCLOT = STRING_WA+SM_CCLOT_POS(SM_CCLOT_LEN).
FINAL_WA-SM_CCLON = STRING_WA+SM_CCLON_POS(SM_CCLON_LEN).
FINAL_WA-SM_CCLNS = STRING_WA+SM_CCLNS_POS(SM_CCLNS_LEN).
FINAL_WA-SM_CCLTP = STRING_WA+SM_CCLTP_POS(SM_CCLTP_LEN).
FINAL_WA-SM_CCLNP = STRING_WA+SM_CCLNP_POS(SM_CCLNP_LEN).
FINAL_WA-CALMONTH = STRING_WA+CALMONTH_POS(CALMONTH_LEN).
FINAL_WA-SM_CCLPE = STRING_WA+SM_CCLPE_POS(SM_CCLPE_LEN).
APPEND FINAL_WA TO FINAL_TABLE.
CUR_ROW = 1.
CLEAR STRING_WA.
ELSE.
CUR_ROW = CUR_ROW + 1.
ENDIF.
ENDLOOP.
ENDIF.

ENDFORM.                    "CONVERT_TO_STRUCT
*---------------------------------------------------------------------*
*       FORM FILL_OBJECT_RANGE                                        *
*---------------------------------------------------------------------*
FORM FILL_OBJECT_RANGE TABLES P_T_RANGE
CHANGING MONTH.
IF GET_ONLY_CUST_UPL = 'X'.
*   Set the customer objects that the upl data is needed for
LOOP AT CUSTOMER_OBJECTS.
PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
USING '0SM_CCLPN'
CUSTOMER_OBJECTS-LOW
CUSTOMER_OBJECTS-OPTION
CUSTOMER_OBJECTS-SIGN.
ENDLOOP.

LOOP AT CUST_NAMESPACE_RNG.
PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
USING '0SM_CCLPN'
CUST_NAMESPACE_RNG-LOW
CUST_NAMESPACE_RNG-OPTION
CUST_NAMESPACE_RNG-SIGN.
ENDLOOP.
PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
USING '0SM_CCLPN'
'AQ*'
RS_C_RANGE_OPT-PATTERN
RS_C_RANGE_SIGN-INCLUDING.

PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
USING '0SM_CCLPN'
'%_C*'
RS_C_RANGE_OPT-PATTERN
RS_C_RANGE_SIGN-INCLUDING.
ENDIF.
* Set the system that the upl data is needed for
PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
USING '0SMD_LSID'
RFC_SYSID
RS_C_RANGE_OPT-EQUAL
RS_C_RANGE_SIGN-INCLUDING.

* Set the month range
MONTH = SY-DATUM(6).
PERFORM FILL_UPL_RANGE TABLES P_T_RANGE
USING '0CALMONTH'
MONTH
RS_C_RANGE_OPT-EQUAL
RS_C_RANGE_SIGN-INCLUDING.


ENDFORM.                    "FILL_OBJECT_RANGE

*---------------------------------------------------------------------*
*       FORM GET_SUBROUTINE_FOR_PROGRAM                               *
*---------------------------------------------------------------------*
FORM GET_SUBROUTINE_FOR_PROGRAM TABLES P_SOURCE
P_SUBROUTINES
USING  P_OBJECT.
DATA:
TK TYPE TABLE OF STOKES WITH HEADER LINE,
NAME_TABIX TYPE SY-TABIX,
SUBROUTINE_NAME TYPE SUBROUTINE_TYPE,
TK_PRINT_WA TYPE STOKES.

DATA  BEGIN OF STM OCCURS 1000.
INCLUDE STRUCTURE SSTMNT.
DATA  END OF STM.

DATA: KEY_TAB TYPE TABLE OF LINE,
KEY TYPE LINE.

* Create the keywords key in order to get only the wanted subroutine
* statement
KEY = P_OBJECT.
APPEND KEY TO KEY_TAB.

* Get the tokens and statement of the statements containing the wanted
* subroutine
SCAN ABAP-SOURCE P_SOURCE
TOKENS      INTO TK
STATEMENTS  INTO STM
KEYWORDS FROM KEY_TAB.
CLEAR STM.
CLEAR P_SUBROUTINES.

* Get the name of the subroutine
LOOP AT TK WHERE STR = P_OBJECT.
*   The name of the subroutine is the word after the keyword
NAME_TABIX = SY-TABIX + 1.
READ TABLE TK INDEX NAME_TABIX INTO TK_PRINT_WA.
IF SY-SUBRC IS INITIAL.
SUBROUTINE_NAME-SUBROUTINE = TK_PRINT_WA-STR.
APPEND SUBROUTINE_NAME TO P_SUBROUTINES.
ELSE.
CONCATENATE 'GET_SUBROUTINE: ERROR getting ' P_OBJECT ' name'
INTO GT_ETL_MESSAGE-MESSAGE.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDLOOP.
ENDFORM.                    "GET_SUBROUTINE_FOR_PROGRAM
*---------------------------------------------------------------------*
*       FORM CHECK_UPL_EXISTENCE                                      *
*---------------------------------------------------------------------*
FORM CHECK_UPL_EXISTENCE USING IV_RFC_DEST TYPE RFCDEST
CHANGING IV_AUTH_PROBLEM.

DATA:
I_T_SFK      TYPE RSDRI_T_SFK,
L_T_SFC      TYPE TABLE OF RSDRI_S_SFC,
E_T_RFCDATA  TYPE  RSDRI_T_RFCDATA,
SUBRC        TYPE STRING..

IF EXTRACT_UPL_DATA IS INITIAL.
CLEAR G_EXTRACT_UPL.
ELSE.
CALL FUNCTION 'RSDRI_INFOPROV_READ_RFC' DESTINATION IV_RFC_DEST
EXPORTING
I_INFOPROV             = '0SM_UPL'
I_MAXROWS              = 1
TABLES
I_T_SFC                = L_T_SFC
I_T_SFK                = I_T_SFK
E_T_RFCDATA            = E_T_RFCDATA
EXCEPTIONS
ILLEGAL_INPUT          = 1
ILLEGAL_INPUT_SFC      = 2
ILLEGAL_INPUT_SFK      = 3
ILLEGAL_INPUT_RANGE    = 4
ILLEGAL_INPUT_TABLESEL = 5
NO_AUTHORIZATION       = 6
GENERATION_ERROR       = 7
ILLEGAL_DOWNLOAD       = 8
ILLEGAL_TABLENAME      = 9
ILLEGAL_RESULTTYPE     = 10
X_MESSAGE              = 11
DATA_OVERFLOW          = 12
OTHERS                 = 13.
IF SY-SUBRC <> 0.
SUBRC = SY-SUBRC.
IF  ( SY-MSGID = 'RSDODSO' AND
SY-MSGNO = 201 ).
CLEAR G_EXTRACT_UPL.

CONCATENATE 'UPL: UPL data not available in ' IV_RFC_DEST
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.


ELSEIF SY-SUBRC = 6.
IV_AUTH_PROBLEM = 'X'.
CONCATENATE 'UPL: NO AUTHORIZATION for UPL in ' IV_RFC_DEST
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

ELSE.
CONCATENATE 'UPL: Problem when checking UPL existance subrc'
SUBRC 'for system' IV_RFC_DEST 'message info' SY-MSGID SY-MSGNO
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

ENDIF.
PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
CLEAR G_EXTRACT_UPL.
ELSE.
G_EXTRACT_UPL = 'X'.
ENDIF.
ENDIF.
ENDFORM.                    "CHECK_UPL_EXISTENCE

*&---------------------------------------------------------------------*
*&      Form  IS_EHP7_SYSTEM
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->G_IS_EHP7  text
*----------------------------------------------------------------------*
FORM IS_EHP7_SYSTEM CHANGING G_IS_EHP7.

DATA: CURR_RELEASE TYPE SAPRELEASE.

* Check that the system is EHP7 system
SELECT SINGLE RELEASE FROM CVERS
INTO CURR_RELEASE
WHERE COMPONENT = 'SAP_APPL'.

IF SY-SUBRC IS INITIAL AND CURR_RELEASE = EHP7_RELEASE.
G_IS_EHP7 = 'X'.
ENDIF.

ENDFORM.                    "IS_EHP7_SYSTEM

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_WEB_SERVICES
*&---------------------------------------------------------------------*
FORM EXTRACT_WEB_SERVICES.

TYPES: BEGIN OF TY_VEPTEXT,
VEPNAME TYPE VEPNAME,
LANGU   TYPE SPRAS,
TEXT    TYPE VEPTEXT,
END OF TY_VEPTEXT.

* We don't want to extract fields CLUSTR, CLUSTD
* of VEPENDPOINT table
TYPES: BEGIN OF TY_VEPENDPOINT,
RELID          TYPE RELID,
VEPNAME        TYPE VEPNAME,
VERSION        TYPE R3STATE,
SORTFIELD      TYPE SRTF2,
ENDPOINTTYPE   TYPE VEPREFTYPE,
DATA_VERSION   TYPE VIFENDPOINTDATAVERS,
DEF_START_PT   TYPE DEF_START_PT,
AUTO_GENERATED TYPE AUTO_GENERATED,
END OF TY_VEPENDPOINT.

DATA: L_STARTTIME LIKE SY-UZEIT.

DATA: WSHEADER_ITAB TYPE TABLE OF WSHEADER,
VEPENDPOINT_ITAB TYPE TABLE OF TY_VEPENDPOINT,
VEPFUNCTION_ITAB TYPE TABLE OF VEPFUNCTION,
VEPTEXT_ITAB TYPE STANDARD TABLE OF TY_VEPTEXT,
VEPCROSSREF_ITAB TYPE STANDARD TABLE OF VEPCROSSREF.

RANGES: R_OBJ_WEBI FOR WSHEADER-WSNAME.

DATA: LS_OBJ_WEBI LIKE LINE OF R_OBJ_WEBI,
LS_VEPTEXT  LIKE LINE OF VEPTEXT_ITAB.

FIELD-SYMBOLS: <OBJ_WEBI> LIKE LINE OF GT_OBJ_WEBI.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Web Services'.

CHECK NOT GT_OBJ_WEBI[] IS INITIAL.

LOOP AT GT_OBJ_WEBI ASSIGNING <OBJ_WEBI>.
CLEAR R_OBJ_WEBI.
R_OBJ_WEBI-SIGN = 'I'.
R_OBJ_WEBI-OPTION = 'EQ'.
R_OBJ_WEBI-LOW = <OBJ_WEBI>-OBJ_NAME.
APPEND R_OBJ_WEBI.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICES>'.

* Extract web services header data
SELECT *
FROM WSHEADER
INTO CORRESPONDING FIELDS OF TABLE WSHEADER_ITAB
FOR ALL ENTRIES IN R_OBJ_WEBI
WHERE VINAME = R_OBJ_WEBI-LOW.

IF SY-SUBRC = 0.
PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_HEADERS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES WSHEADER_ITAB
USING  G_IREF_PDOCUMENT
'WSHEADER'.
PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_HEADERS>'.
ENDIF.

* Extract web services end point data
SELECT *
FROM VEPENDPOINT
INTO CORRESPONDING FIELDS OF TABLE VEPENDPOINT_ITAB
FOR ALL ENTRIES IN R_OBJ_WEBI
WHERE VEPNAME = R_OBJ_WEBI-LOW.

IF SY-SUBRC = 0.
PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_END_POINTS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPENDPOINT_ITAB
USING  G_IREF_PDOCUMENT
'VEPENDPOINT'.
PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_END_POINTS>'.
ENDIF.

* Extract web services end point functions data
SELECT *
FROM VEPFUNCTION
INTO CORRESPONDING FIELDS OF TABLE VEPFUNCTION_ITAB
FOR ALL ENTRIES IN R_OBJ_WEBI
WHERE VEPNAME = R_OBJ_WEBI-LOW.

IF SY-SUBRC = 0.
PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_FUNCTIONS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPFUNCTION_ITAB
USING  G_IREF_PDOCUMENT
'VEPFUNCTION'.
PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_FUNCTIONS>'.
ENDIF.

* Extract web services connection to XI Proxies
SELECT *
FROM VEPCROSSREF
INTO CORRESPONDING FIELDS OF TABLE VEPCROSSREF_ITAB
FOR ALL ENTRIES IN R_OBJ_WEBI
WHERE VEPNAME = R_OBJ_WEBI-LOW
AND ( SUB_TYPE = 'INTF'  OR
SUB_TYPE = 'CLAS' ).

IF SY-SUBRC = 0.
PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_XI_PROXY>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPCROSSREF_ITAB
USING  G_IREF_PDOCUMENT
'VEPCROSSREF'.
PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_XI_PROXY>'.
ENDIF.

* Extract web services texts
LOOP AT R_OBJ_WEBI INTO LS_OBJ_WEBI.
*   Get English Text
CLEAR LS_VEPTEXT.
LS_VEPTEXT-VEPNAME = LS_OBJ_WEBI-LOW.
LS_VEPTEXT-LANGU   = 'E'.
CALL FUNCTION 'GET_WEBI_SHORTTEXT'
EXPORTING
VINAME               = LS_VEPTEXT-VEPNAME
LANGUAGE             = LS_VEPTEXT-LANGU
IMPORTING
TEXT                 = LS_VEPTEXT-TEXT
EXCEPTIONS
NOT_FOUND            = 1
LOCKED               = 2
INTERNAL_ERROR       = 3
NO_PERMISSION        = 4
OTHERS               = 5.
IF SY-SUBRC = 0.
APPEND LS_VEPTEXT TO VEPTEXT_ITAB.
ENDIF.

*   Get login language text (if not english)
IF SY-LANGU NE 'E'.
CLEAR LS_VEPTEXT.
LS_VEPTEXT-VEPNAME = LS_OBJ_WEBI-LOW.
LS_VEPTEXT-LANGU   = SY-LANGU.
CALL FUNCTION 'GET_WEBI_SHORTTEXT'
EXPORTING
VINAME               = LS_VEPTEXT-VEPNAME
LANGUAGE             = LS_VEPTEXT-LANGU
IMPORTING
TEXT                 = LS_VEPTEXT-TEXT
EXCEPTIONS
NOT_FOUND            = 1
LOCKED               = 2
INTERNAL_ERROR       = 3
NO_PERMISSION        = 4
OTHERS               = 5.
IF SY-SUBRC = 0.
APPEND LS_VEPTEXT TO VEPTEXT_ITAB.
ENDIF.
ENDIF.
ENDLOOP.

IF NOT VEPTEXT_ITAB[] IS INITIAL.
PERFORM APPEND_STRING_TO_FILE USING '<WEB_SERVICE_TEXTS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES VEPTEXT_ITAB
USING  G_IREF_PDOCUMENT
'VEPTEXT'.
PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICE_TEXTS>'.
ENDIF.

* Append closing XML tag for web services data
PERFORM APPEND_STRING_TO_FILE USING '</WEB_SERVICES>'.

FREE: GT_OBJ_WEBI.

PERFORM ADD_TIME_STAT USING 'Extract Web Services' L_STARTTIME.

ENDFORM.                    " EXTRACT_WEB_SERVICES

*&---------------------------------------------------------------------*
*&      Form  INIT_WEB_BLACKLIST
*&---------------------------------------------------------------------*
FORM INIT_WEB_BLACKLIST.

DATA: LS_WEB_BLACKLIST LIKE LINE OF G_WEB_BLACKLIST.

LS_WEB_BLACKLIST-SIGN   = 'I'.
LS_WEB_BLACKLIST-OPTION = 'CP'.

* Suffix
LS_WEB_BLACKLIST-LOW = '*.PNG'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.HTM'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.ICO'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.CSS'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.PDF'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.XDP'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.XFD'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.ASP'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.JSP'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.CFC'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.CFM'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.TXT'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.DLL'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.XML'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.PHP'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.KEY'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.INI'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.PL'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.TCL'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.JSPA'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.JPG'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.GIF'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.SWF'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.JSF'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.JS'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '*.XLS'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.

* Prefix
LS_WEB_BLACKLIST-LOW = '/SAP/BC/GUI/SAP/ITS/*'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '/SAP/PUBLIC/BC/UR*'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '/SAP/PUBLIC/BC/ITS*'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.
LS_WEB_BLACKLIST-LOW = '/SAP/BC/WEBDYNPRO/*'.
APPEND LS_WEB_BLACKLIST TO G_WEB_BLACKLIST.


ENDFORM.                    " INIT_WEB_BLACKLIST

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_USAGE_FOR_PERIOD
*&---------------------------------------------------------------------*
FORM EXTRACT_USAGE_FOR_PERIOD TABLES   T_PERIOD
T_SAPWLSERV_TAB
T_FULL_USAGE
USING    P_PERIOD TYPE SAPWLACCPT
CHANGING P_IS_DATA.

TYPES: BEGIN OF USER_DATA_TYPE,
USERNAME TYPE SAPWLUTACC,
USERUSAGE TYPE NUM10,
END OF USER_DATA_TYPE,
BEGIN OF CALLERS_DATA_TYPE,
CALLER_NAME LIKE SAPWLRFCS-REMOT_DEST,
END OF CALLERS_DATA_TYPE.

DATA:
DATE       TYPE SY-DATUM,
SAPWLSERV_REC TYPE SAPWLSERV,
INSTANCE_NAME LIKE SAPWLSERV-NAME.

DATA: RECORD TYPE TY_RECORD.

DATA: TTAB       LIKE TABLE OF RECORD.
DATA: CURR_RECORD LIKE RECORD,
PREV_RECORD LIKE RECORD.

DATA: TEMP_TTAB TYPE TT_RECORD.

DATA: TOTAL_USAGE   TYPE P,
USAGE_PER_USER  TYPE P.

DATA: USERS TYPE TABLE OF USER_DATA_TYPE WITH HEADER LINE,
CALLERS TYPE TABLE OF CALLERS_DATA_TYPE WITH HEADER LINE.

DATA: LT_MONTH   TYPE TABLE OF SY-DATUM,
LT_WEEK    TYPE TABLE OF SY-DATUM,
LT_DAY     TYPE TABLE OF SY-DATUM,
OUTREC     TYPE OUTREC.

DATA: DATATAB TYPE TABLE OF OUTREC.

DATA: USAGE_NODE TYPE XML_ELEMENT,
USERS_NODE TYPE XML_ELEMENT,
CALLERS_NODE TYPE XML_ELEMENT,
LT_USAGE_TCODE_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE,
LT_USAGE_USERS_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE.

CHECK VANILLA = ''.

LOOP AT T_PERIOD INTO DATE.

LOOP AT T_SAPWLSERV_TAB INTO SAPWLSERV_REC.

INSTANCE_NAME = SAPWLSERV_REC-NAME.
CLEAR: TEMP_TTAB[].

*     Extract all usage (including Web Statistics)
*     Check that RFC target is 700 or higher
*     to verify that the function exists in destination
IF NO_WEB_USAGE IS INITIAL
AND ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ).
PERFORM GET_ALL_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
USING DATE
INSTANCE_NAME
P_PERIOD
CHANGING TEMP_TTAB
P_IS_DATA.
ELSE.
*       Extract only tcode & rfc usage (in case of performence issues)
PERFORM GET_TCODE_RFC_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
USING DATE
INSTANCE_NAME
P_PERIOD
CHANGING TEMP_TTAB
P_IS_DATA.
ENDIF.

*     Append the temp records to main ttab
IF NOT TEMP_TTAB[] IS INITIAL.
APPEND LINES OF TEMP_TTAB TO TTAB.
ENDIF.
ENDLOOP.

*   Anna - aggregate the records by program and
*   user name ( don't duplicate jobs )
SORT TTAB BY PERIOD TCODE TYPE USER REMOT_DEST JOBNAME.
LOOP AT TTAB INTO RECORD.
CURR_RECORD = RECORD.
TOTAL_USAGE = TOTAL_USAGE + CURR_RECORD-USAGE.
USAGE_PER_USER = USAGE_PER_USER + CURR_RECORD-USAGE.

*     When reaching to a new username ( the program stays
*     stays unchanged ) - put it into results table
AT END OF USER.
USERS-USERNAME = CURR_RECORD-USER.
USERS-USERUSAGE = USAGE_PER_USER.
APPEND USERS.
CLEAR USAGE_PER_USER.
ENDAT.

AT END OF REMOT_DEST.
CALLERS-CALLER_NAME = CURR_RECORD-REMOT_DEST.
APPEND CALLERS.
ENDAT.

*     When reaching to a new transaction print it
AT END OF TCODE.
MOVE-CORRESPONDING CURR_RECORD TO OUTREC.
OUTREC-USAGE = TOTAL_USAGE.
APPEND OUTREC TO DATATAB.

PERFORM ADD_ITAB_TO_XML TABLES DATATAB LT_USAGE_TCODE_NODES
USING G_IREF_PDOCUMENT USAGE_NODE
'USAGE_TCODE'.


PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LT_USAGE_TCODE_NODES-NODE_REF
'USERS'
CHANGING USERS_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES USERS
USING G_IREF_PDOCUMENT USERS_NODE
'USER'.

IF CURR_RECORD-TYPE = 'F'.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LT_USAGE_TCODE_NODES-NODE_REF
'CALLERS'
CHANGING CALLERS_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES CALLERS
USING G_IREF_PDOCUMENT CALLERS_NODE
'CALLER'.
ENDIF.
PERFORM EXTRACT_WEB_DATA USING RECORD-TCODE
RECORD-TYPE
LT_USAGE_TCODE_NODES-NODE_REF.
PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LT_USAGE_TCODE_NODES-NODE_REF 'X'.

CLEAR TOTAL_USAGE.
FREE DATATAB.
FREE: USERS, CALLERS.
FREE LT_USAGE_TCODE_NODES.

ENDAT.

ENDLOOP.

*   Clear TTAB.
REFRESH TTAB.
*   Clear g_web_data for next period
CLEAR G_WEB_DATA[].
ENDLOOP.
FREE G_WEB_DATA.

ENDFORM.                    " EXTRACT_USAGE_FOR_PERIOD

*&---------------------------------------------------------------------*
*&      Form  GET_ALL_USAGE_FOR_PERIOD
*&---------------------------------------------------------------------*
FORM GET_ALL_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
USING  P_START_DATE
P_INSTANCE
P_PERIOD
CHANGING T_TTAB TYPE TT_RECORD
P_IS_DATA.

DATA: INSTANCE_NAME LIKE SAPWLSERV-NAME,
PERIOD_TYPE   TYPE SAPWLACCPT,
PERIOD_DATE   TYPE DATUM.

DATA: BEGIN OF ENTRY_ID_TYPE,
TCODE_OR_REPORT LIKE SAPWLPFNRM-REPORT,
JOBNAME         LIKE SAPWLPFBTC-JOBNAME,
TYPE,           "T)code or R)eport F)unction?
END OF ENTRY_ID_TYPE.

DATA: RECORD TYPE TY_RECORD.

DATA: LS_FULL_USAGE TYPE SAPWLUSTCX.

DATA: LT_USERTCODE TYPE SWNCGL_T_AGGUSERTCODE,
LS_USERTCODE LIKE LINE OF LT_USERTCODE,
LT_RFCSRVR   TYPE SWNCGL_T_AGGRFCSRVR,
LS_RFCSRVR   LIKE LINE OF LT_RFCSRVR,
LT_WEBS      TYPE SWNCGL_T_AGGWEBCLNT,
LS_WEBS      LIKE LINE OF LT_WEBS.

DATA: LT_TEMP_WEBSD TYPE TABLE OF SWNCAGGWEBDEST.

DATA: LV_CURR_PATH TYPE CHAR250_D.

INSTANCE_NAME = P_INSTANCE.
PERIOD_TYPE   = P_PERIOD.
PERIOD_DATE   = P_START_DATE.

CLEAR: LT_USERTCODE[], LT_RFCSRVR[], LT_WEBS[], LT_TEMP_WEBSD[].

CALL FUNCTION 'SWNC_GET_WORKLOAD_STATISTIC' DESTINATION P_RFCDES
EXPORTING
SYSTEMID                     = RFC_SYSID
INSTANCE                     = INSTANCE_NAME
PERIODTYPE                   = PERIOD_TYPE
PERIODSTRT                   = PERIOD_DATE
IMPORTING
USERTCODE                    = LT_USERTCODE
RFCSRVR                      = LT_RFCSRVR
WEBS                         = LT_WEBS
WEBSD                        = LT_TEMP_WEBSD
EXCEPTIONS
*     UNKNOWN_PERIODTYPE           = 1
NO_DATA_FOUND                = 2
*     UNKNOWN_ERROR                = 3
OTHERS                       = 4.

IF SY-SUBRC = 4.
MESSAGE ID SY-MSGID TYPE 'E' NUMBER SY-MSGNO WITH SY-MSGV1
SY-MSGV2 SY-MSGV3 SY-MSGV4.
ENDIF.

APPEND LINES OF LT_TEMP_WEBSD TO G_WEB_DATA.
SORT LT_USERTCODE BY ENTRY_ID.

IF P_IS_DATA IS INITIAL AND NOT LT_USERTCODE[] IS INITIAL.
P_IS_DATA = 'X'.
ENDIF.

LOOP AT LT_USERTCODE INTO LS_USERTCODE.
CLEAR RECORD.
RECORD-PERIOD = PERIOD_DATE(6).
ENTRY_ID_TYPE = LS_USERTCODE-ENTRY_ID.
RECORD-JOBNAME = ENTRY_ID_TYPE-JOBNAME.
RECORD-TCODE = ENTRY_ID_TYPE-TCODE_OR_REPORT.
RECORD-TYPE = ENTRY_ID_TYPE-TYPE.
RECORD-USAGE = LS_USERTCODE-COUNT.
RECORD-USER = LS_USERTCODE-ACCOUNT.
COLLECT RECORD INTO T_TTAB.

*   Get lines for full usage only if wanted
*   Code is from FM: SAPWL_WORKLOAD_GET_STATISTIC
*   Convert the ls_usertcode to suit t_full_usage line type
IF NOT EXTRACT_FULL_USAGE IS INITIAL.
CATCH SYSTEM-EXCEPTIONS OTHERS = 1.
MOVE-CORRESPONDING LS_USERTCODE TO LS_FULL_USAGE.
LS_FULL_USAGE-TTYPE = LS_USERTCODE-TASKTYPE.
APPEND LS_FULL_USAGE TO T_FULL_USAGE.
ENDCATCH.
ENDIF.
ENDLOOP.

LOOP AT LT_RFCSRVR INTO LS_RFCSRVR.
CLEAR RECORD.
RECORD-PERIOD = PERIOD_DATE(6).
CLEAR RECORD-JOBNAME.
RECORD-TCODE = LS_RFCSRVR-FUNC_NAME.
RECORD-TYPE = 'F'.
RECORD-USAGE = 1.
RECORD-USER = LS_RFCSRVR-ACCOUNT.
RECORD-REMOT_DEST = LS_RFCSRVR-REMOT_DEST.
COLLECT RECORD INTO T_TTAB.
ENDLOOP.

LOOP AT LT_WEBS INTO LS_WEBS.
CLEAR: RECORD, LV_CURR_PATH.
LV_CURR_PATH = LS_WEBS-PATH.
TRANSLATE LV_CURR_PATH TO UPPER CASE.
IF NOT LV_CURR_PATH IN G_WEB_BLACKLIST.
RECORD-PERIOD = PERIOD_DATE(6).
RECORD-TCODE  = LS_WEBS-PATH.
RECORD-TYPE   = 'W'.
RECORD-USAGE  = LS_WEBS-COUNTER.
RECORD-USER   = LS_WEBS-ACCOUNT.
COLLECT RECORD INTO T_TTAB.
ENDIF.
ENDLOOP.

ENDFORM.                    "GET_ALL_USAGE_FOR_PERIOD

*&---------------------------------------------------------------------*
*&      Form  GET_TCODE_RFC_USAGE_FOR_PERIOD
*&---------------------------------------------------------------------*
FORM GET_TCODE_RFC_USAGE_FOR_PERIOD TABLES T_FULL_USAGE
USING P_START_DATE
P_INSTANCE
P_PERIOD
CHANGING T_TTAB TYPE TT_RECORD
P_IS_DATA.

DATA: INSTANCE_NAME LIKE SAPWLSERV-NAME,
PERIOD_TYPE   TYPE SAPWLACCPT,
PERIOD_DATE   TYPE DATUM.

DATA: BEGIN OF ENTRY_ID_TYPE,
TCODE_OR_REPORT LIKE SAPWLPFNRM-REPORT,
JOBNAME         LIKE SAPWLPFBTC-JOBNAME,
TYPE,           "T)code or R)eport F)unction?
END OF ENTRY_ID_TYPE.

DATA: TCODESTAT  TYPE TABLE OF SAPWLUSTCX,
RFC_STAT   TYPE TABLE OF SAPWLRFCS,
RFC_STAT_REC LIKE LINE OF RFC_STAT,
TCODE_LINE LIKE LINE OF TCODESTAT.

DATA: RECORD TYPE TY_RECORD.

INSTANCE_NAME = P_INSTANCE.
PERIOD_TYPE   = P_PERIOD.
PERIOD_DATE   = P_START_DATE.

REFRESH TCODESTAT.
REFRESH RFC_STAT.

CALL FUNCTION 'SAPWL_WORKLOAD_GET_STATISTIC' DESTINATION P_RFCDES
EXPORTING
PERIODTYPE            = PERIOD_TYPE
STARTDATE             = PERIOD_DATE
INSTANCE              = INSTANCE_NAME
TABLES
APPLICATION_STATISTIC = TCODESTAT
RFC_SERVER_STATISTIC  = RFC_STAT
EXCEPTIONS
NO_DATA_FOUND         = 2
OTHERS                = 4.

IF SY-SUBRC = 4.
MESSAGE ID SY-MSGID TYPE 'E' NUMBER SY-MSGNO WITH SY-MSGV1
SY-MSGV2 SY-MSGV3 SY-MSGV4.
ENDIF.

SORT TCODESTAT BY ENTRY_ID.

* Get lines for full usage only if wanted
IF NOT EXTRACT_FULL_USAGE IS INITIAL.
APPEND LINES OF TCODESTAT TO T_FULL_USAGE.
ENDIF.

IF P_IS_DATA IS INITIAL AND NOT TCODESTAT[] IS INITIAL.
P_IS_DATA = 'X'.
ENDIF.

LOOP AT TCODESTAT INTO TCODE_LINE.
CLEAR RECORD.
RECORD-PERIOD = PERIOD_DATE(6).
ENTRY_ID_TYPE = TCODE_LINE-ENTRY_ID.
RECORD-JOBNAME = ENTRY_ID_TYPE-JOBNAME.
RECORD-TCODE = ENTRY_ID_TYPE-TCODE_OR_REPORT.
RECORD-TYPE = ENTRY_ID_TYPE-TYPE.
RECORD-USAGE = TCODE_LINE-COUNT.
RECORD-USER = TCODE_LINE-ACCOUNT.
COLLECT RECORD INTO T_TTAB.
ENDLOOP.

LOOP AT RFC_STAT INTO RFC_STAT_REC.
CLEAR RECORD.
RECORD-PERIOD = PERIOD_DATE(6).
CLEAR RECORD-JOBNAME.
RECORD-TCODE = RFC_STAT_REC-FUNC_NAME.
RECORD-TYPE = 'F'.
RECORD-USAGE = 1.
RECORD-USER = RFC_STAT_REC-ACCOUNT.
RECORD-REMOT_DEST = RFC_STAT_REC-REMOT_DEST.
COLLECT RECORD INTO T_TTAB.
ENDLOOP.

ENDFORM.                    "GET_TCODE_RFC_USAGE_FOR_PERIOD

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROXIES
*&---------------------------------------------------------------------*
FORM EXTRACT_PROXIES.

DATA: L_STARTTIME LIKE SY-UZEIT.

DATA: SPROXDAT_ITAB TYPE TABLE OF SPROXDAT.

DATA: LT_TADIR_PROXY TYPE STANDARD TABLE OF TADIR,
LS_TADIR_PROXY TYPE TADIR,
LT_PROXIES TYPE TABLE OF SPROXHDR,
LS_PROXIES TYPE SPROXHDR.

FIELD-SYMBOLS: <SPROXHDR> LIKE LINE OF G_PROXY_HEADERS,
<SPROXDAT> LIKE LINE OF SPROXDAT_ITAB.

CHECK VANILLA = ''.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Proxies'.

* Get all customers dev classes
PERFORM GET_DEV_CLASS_DATA.
CHECK NOT LT_TDEVC[] IS INITIAL.

* Get all customers 'CLAS' & 'INTF' objects for proxy selection
SELECT OBJECT OBJ_NAME
FROM TADIR
INTO CORRESPONDING FIELDS OF TABLE LT_TADIR_PROXY
FOR ALL ENTRIES IN LT_TDEVC
WHERE DEVCLASS = LT_TDEVC-DEVCLASS
AND PGMID = 'R3TR'
AND OBJECT IN ('CLAS','INTF').

FREE: LT_TDEVC.
CHECK NOT LT_TADIR_PROXY[] IS INITIAL.

LOOP AT LT_TADIR_PROXY INTO LS_TADIR_PROXY.
CLEAR LS_PROXIES.
LS_PROXIES-OBJECT = LS_TADIR_PROXY-OBJECT.
LS_PROXIES-OBJ_NAME = LS_TADIR_PROXY-OBJ_NAME.
APPEND LS_PROXIES TO LT_PROXIES.
ENDLOOP.

PERFORM APPEND_STRING_TO_FILE USING '<PROXIES>'.

* Extract proxies header data
SELECT *
FROM SPROXHDR
INTO CORRESPONDING FIELDS OF TABLE G_PROXY_HEADERS
FOR ALL ENTRIES IN LT_PROXIES
WHERE OBJECT   = LT_PROXIES-OBJECT
AND OBJ_NAME = LT_PROXIES-OBJ_NAME.

IF SY-SUBRC = 0.
*   Clear unwaqnted data that might cuase XML errors
LOOP AT G_PROXY_HEADERS ASSIGNING <SPROXHDR>.
CLEAR: <SPROXHDR>-HASH_ID, <SPROXHDR>-ID,
<SPROXHDR>-FURTHER_DATA, <SPROXHDR>-BO_DATA.
ENDLOOP.
PERFORM APPEND_STRING_TO_FILE USING '<PROXY_HEADERS>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES G_PROXY_HEADERS
USING  G_IREF_PDOCUMENT
'SPROXHDR'.
PERFORM APPEND_STRING_TO_FILE USING '</PROXY_HEADERS>'.
ENDIF.

* Extract proxies data
PERFORM APPEND_STRING_TO_FILE USING '<PROXY_DATA>'.
SELECT *
FROM SPROXDAT PACKAGE SIZE PAC_SIZE
INTO CORRESPONDING FIELDS OF TABLE SPROXDAT_ITAB
FOR ALL ENTRIES IN LT_PROXIES
WHERE OBJECT   = LT_PROXIES-OBJECT
AND OBJ_NAME = LT_PROXIES-OBJ_NAME.

*   Clear unwaqnted data that might cuase XML errors
LOOP AT SPROXDAT_ITAB ASSIGNING <SPROXDAT>.
CLEAR: <SPROXDAT>-ID.
ENDLOOP.

PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES SPROXDAT_ITAB
USING  G_IREF_PDOCUMENT
'SPROXDAT'.
ENDSELECT.

PERFORM APPEND_STRING_TO_FILE USING '</PROXY_DATA>'.

* Extract SXMB_ADM parameters
PERFORM EXTRACT_PROXIES_PARAMS.

* Append closing XML tag for proxies data
PERFORM APPEND_STRING_TO_FILE USING '</PROXIES>'.

PERFORM ADD_TIME_STAT USING 'Extract Proxies' L_STARTTIME.

ENDFORM.                    " EXTRACT_PROXIES

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROXIES_USAGE
*&---------------------------------------------------------------------*
FORM EXTRACT_PROXIES_USAGE.

TYPES: BEGIN OF TY_PROXY_USAGE,
LAST_USED TYPE DATUM,
OBJECT(4) TYPE C,
OBJ_NAME(30) TYPE C,
INTERFACE(120) TYPE C,
NAMESPACE(255) TYPE C,
CALLER(100) TYPE C,
COUNT TYPE NUM10,
END OF TY_PROXY_USAGE,

BEGIN OF TY_PROXY_USAGE_OUT,
PERIOD(6) TYPE C,
TCODE(400) TYPE C,
TYPE(1) TYPE C,
USAGE TYPE NUM10,
END OF TY_PROXY_USAGE_OUT,

BEGIN OF TY_PROXY_CALLER,
CALLER_NAME(255) TYPE C,
CALLER_USAGE TYPE NUM10,
END OF TY_PROXY_CALLER.

DATA: L_STARTTIME LIKE SY-UZEIT,
LV_TABIX TYPE NUMC10.

DATA: LS_PROXY_HEADER LIKE LINE OF G_PROXY_HEADERS.

DATA: LT_PROXY_USAGE TYPE STANDARD TABLE OF TY_PROXY_USAGE,
LS_PROXY_USAGE TYPE TY_PROXY_USAGE,
LT_USAGE_CALLER TYPE TT_USAGE_CALLER,
LS_USAGE_CALLER TYPE TY_USAGE_CALLER.

DATA: LT_USAGE_OUT TYPE STANDARD TABLE OF TY_PROXY_USAGE_OUT,
LS_USAGE_OUT TYPE TY_PROXY_USAGE_OUT.

DATA: USAGE_CALLERS TYPE STANDARD TABLE OF TY_PROXY_CALLER,
USAGE_CALLER TYPE TY_PROXY_CALLER.

DATA: TOTAL_USAGE TYPE NUM10,
USAGE_PER_CALLER TYPE NUM10.

DATA: USAGE_NODE TYPE XML_ELEMENT,
CALLERS_NODE TYPE XML_ELEMENT,
LT_USAGE_TCODE_NODES TYPE HANDLES_TAB_TYPE WITH HEADER LINE.

CHECK VANILLA = ''.

* Extract proxy usage only if rfc system is ecc5 or higher
CHECK RFC_SAPRL GE '640'.

CHECK NOT G_PROXY_HEADERS[] IS INITIAL.

L_STARTTIME = SY-UZEIT.
PERFORM UPDATE_PROGRESS USING 'Extracting Proxies Usage'.

* Extract usage per proxy (interface)
LOOP AT G_PROXY_HEADERS INTO LS_PROXY_HEADER.

LV_TABIX = SY-TABIX.

*   When extraction isn't from production or we don't want to
*   extract callers, we'll get only partial data for the
*   first 100 proxies only
IF ( LV_TABIX GT 100 ) AND
( ( RFC_SYSID NE SY-SYSID ) OR
( EXTRACT_PROXY_CALLERS IS INITIAL ) ).
RETURN.
ENDIF.

CLEAR LS_PROXY_USAGE.
LS_PROXY_USAGE-OBJECT = LS_PROXY_HEADER-OBJECT.
LS_PROXY_USAGE-OBJ_NAME = LS_PROXY_HEADER-OBJ_NAME.
LS_PROXY_USAGE-INTERFACE = LS_PROXY_HEADER-IFR_NAME.
LS_PROXY_USAGE-NAMESPACE = LS_PROXY_HEADER-IFR_NSPCE.

CLEAR LT_USAGE_CALLER[].

*   Get the interface's usage (by caller)
PERFORM GET_USAGE_BY_MONTHS_BACK
USING LS_PROXY_HEADER-IFR_NSPCE
LS_PROXY_HEADER-IFR_NAME
''
''
'PROXIES'
CHANGING LT_USAGE_CALLER.

LOOP AT LT_USAGE_CALLER INTO LS_USAGE_CALLER.
MOVE-CORRESPONDING LS_USAGE_CALLER TO LS_PROXY_USAGE.
APPEND LS_PROXY_USAGE TO LT_PROXY_USAGE.
ENDLOOP.

ENDLOOP.

IF NOT LT_PROXY_USAGE[] IS INITIAL.
SORT LT_PROXY_USAGE
BY LAST_USED OBJECT OBJ_NAME INTERFACE NAMESPACE CALLER.

*   Extract the proxies usage like existing usage
*   With callers per interface
LOOP AT LT_PROXY_USAGE INTO LS_PROXY_USAGE.
ADD LS_PROXY_USAGE-COUNT TO TOTAL_USAGE.
ADD LS_PROXY_USAGE-COUNT TO USAGE_PER_CALLER.

AT END OF CALLER.
CLEAR USAGE_CALLER.
USAGE_CALLER-CALLER_NAME = LS_PROXY_USAGE-CALLER.
USAGE_CALLER-CALLER_USAGE = USAGE_PER_CALLER.
APPEND USAGE_CALLER TO USAGE_CALLERS.
CLEAR USAGE_PER_CALLER.
ENDAT.

AT END OF NAMESPACE.
CLEAR LS_USAGE_OUT.

LS_USAGE_OUT-PERIOD = LS_PROXY_USAGE-LAST_USED(6).
CONCATENATE LS_PROXY_USAGE-NAMESPACE '/'
LS_PROXY_USAGE-INTERFACE INTO LS_USAGE_OUT-TCODE.
LS_USAGE_OUT-TYPE = 'X'.
LS_USAGE_OUT-USAGE = TOTAL_USAGE.
APPEND LS_USAGE_OUT TO LT_USAGE_OUT.

PERFORM ADD_ITAB_TO_XML TABLES LT_USAGE_OUT
LT_USAGE_TCODE_NODES
USING G_IREF_PDOCUMENT USAGE_NODE
'USAGE_TCODE'.

IF NOT LS_PROXY_USAGE-CALLER IS INITIAL.
PERFORM CREATE_XML_NODE USING G_IREF_PDOCUMENT
LT_USAGE_TCODE_NODES-NODE_REF
'CALLERS'
CHANGING CALLERS_NODE.

PERFORM ADD_ITAB_TO_XML_SIMPLE TABLES USAGE_CALLERS
USING G_IREF_PDOCUMENT CALLERS_NODE
'CALLER'.
ENDIF.

PERFORM APPEND_XML_ELEMENT_TO_FILE USING
LT_USAGE_TCODE_NODES-NODE_REF 'X'.

CLEAR TOTAL_USAGE.
FREE: LT_USAGE_OUT[], USAGE_CALLERS[],
LT_USAGE_TCODE_NODES.
ENDAT.

ENDLOOP.

ENDIF.

FREE: G_PROXY_HEADERS[].
PERFORM ADD_TIME_STAT USING 'Extract Proxies Usage' L_STARTTIME.

ENDFORM.                    " EXTRACT_PROXIES_USAGE

*&---------------------------------------------------------------------*
*&      Form  GET_PROXY_USAGE_BY_DATES
*&---------------------------------------------------------------------*
FORM GET_PROXY_USAGE_BY_DATES USING NAMESPACE
INTERFACE
START_DATE TYPE DATUM
END_DATE TYPE DATUM
CHANGING CALLERS TYPE TT_USAGE_CALLER.

DATA: LV_TIMEZONE TYPE TIMEZONE.

DATA: LS_FILTER TYPE SXI_MESSAGE_FILTER,
LT_MESSAGE_LIST TYPE SXI_MESSAGE_DATA_LIST,
LV_SUBRC TYPE STRING,
LV_LINES TYPE I.

DATA: LS_CALLER TYPE TY_USAGE_CALLER.

DATA: LV_LOG_MESSAGE TYPE STRING.

FIELD-SYMBOLS: <CALLER> LIKE LINE OF CALLERS.

* Set dates for filter
CONVERT DATE START_DATE TIME '000000'
INTO TIME STAMP LS_FILTER-FROM_TIME TIME ZONE LV_TIMEZONE.
CONVERT DATE END_DATE TIME '235959'
INTO TIME STAMP LS_FILTER-TO_TIME TIME ZONE LV_TIMEZONE.

* Set Namespace and Interface
LS_FILTER-IB_NS = NAMESPACE.
LS_FILTER-IB_NAME = INTERFACE.

CONCATENATE 'PROXY USAGE - NAMESPACE:' NAMESPACE
'INTERFACE:' INTERFACE
'PERIOD:' START_DATE
'START TIME:' SY-UZEIT
INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

* If extraction is from prod, get the usage by direct SELECT
* with grouping by callers
IF RFC_SYSID = SY-SYSID AND NOT EXTRACT_PROXY_CALLERS IS INITIAL.
CONCATENATE LV_LOG_MESSAGE '- BY SELECT'
INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

SELECT EMAS~OB_SYSTEM AS CALLER
COUNT( DISTINCT EMAS~MSGGUID ) AS COUNT
FROM SXMSPMAST AS MAST
JOIN SXMSPEMAS AS EMAS ON EMAS~MSGGUID = MAST~MSGGUID
AND EMAS~PID = MAST~PID
INTO CORRESPONDING FIELDS OF TABLE CALLERS
WHERE MAST~EXETIMEST GE LS_FILTER-FROM_TIME
AND MAST~EXETIMEST LE LS_FILTER-TO_TIME
AND EMAS~IB_NAME = LS_FILTER-IB_NAME
AND EMAS~IB_NS = LS_FILTER-IB_NS
GROUP BY EMAS~OB_SYSTEM.

IF SY-SUBRC = 0.
LOOP AT CALLERS ASSIGNING <CALLER>.
<CALLER>-LAST_USED = END_DATE.
ENDLOOP.
ENDIF.
ELSE.
CONCATENATE LV_LOG_MESSAGE '- BY RFC'
INTO LV_LOG_MESSAGE SEPARATED BY SPACE.

*   If usage is selected via RFC, limit to max 50 messages
*   In this case, there will be no specific caller but only
*   number of messages
CALL FUNCTION 'SXMB_GET_MESSAGE_LIST' DESTINATION P_RFCDES
EXPORTING
IM_FILTER                  = LS_FILTER
IM_MESSAGE_COUNT           = 50
IMPORTING
EX_MESSAGE_DATA_LIST       = LT_MESSAGE_LIST
*       EX_RESULT                  =
*       EX_FIRST_TS                =
EXCEPTIONS
NOT_AUTHORIZED             = 1
INTERNAL_ERROR             = 2
TOO_MANY_MESSAGES          = 3
NO_MESSAGE                 = 4
OTHERS                     = 5.

IF SY-SUBRC EQ 0.
DESCRIBE TABLE LT_MESSAGE_LIST LINES LV_LINES.
IF LV_LINES > 0.
LS_CALLER-COUNT = LV_LINES.
LS_CALLER-LAST_USED = END_DATE.
APPEND LS_CALLER TO CALLERS.
ENDIF.
ELSE.
LV_SUBRC = SY-SUBRC.
CONCATENATE 'PROXY USAGE - NAMESPACE:' NAMESPACE 'INTERFACE:'
INTERFACE 'DATE:' START_DATE 'SUBRC:' LV_SUBRC
INTO GT_ETL_MESSAGE-MESSAGE SEPARATED BY SPACE.

PERFORM ADD_MESSAGE USING GT_ETL_MESSAGE-MESSAGE ABAP_FALSE.
ENDIF.
ENDIF.

PERFORM ADD_MESSAGE USING LV_LOG_MESSAGE ABAP_FALSE.

ENDFORM.                    " GET_PROXY_USAGE_BY_DATES

*&---------------------------------------------------------------------*
*&      Form  EXTRACT_PROXIES_PARAMS
*&---------------------------------------------------------------------*
FORM EXTRACT_PROXIES_PARAMS.

DATA: LT_SXMSCONFDF TYPE TABLE OF SXMSCONFDF,
LT_SXMSCONFVL TYPE TABLE OF SXMSCONFVL,
LT_SXMSARCITF TYPE TABLE OF SXMSARCITF2.

* Extract from direct SELECT or via RFC, depends extraction is from
* the same system like RFC (Prod to Prod)
IF ( RFC_SYSID = SY-SYSID ).
SELECT *
FROM SXMSCONFDF
INTO CORRESPONDING FIELDS OF TABLE LT_SXMSCONFDF.

SELECT *
FROM SXMSCONFVL
INTO CORRESPONDING FIELDS OF TABLE LT_SXMSCONFVL.

SELECT *
FROM SXMSARCITF2
INTO CORRESPONDING FIELDS OF TABLE LT_SXMSARCITF.
ELSE.
PERFORM GET_TABLE_DATA_VIA_RFC TABLES LT_SXMSCONFDF
USING 'SXMSCONFDF'.

PERFORM GET_TABLE_DATA_VIA_RFC TABLES LT_SXMSCONFVL
USING 'SXMSCONFVL'.

PERFORM GET_TABLE_DATA_VIA_RFC TABLES LT_SXMSARCITF
USING 'SXMSARCITF2'.
ENDIF.

* Default SXMB_ADM parameters
IF NOT LT_SXMSCONFDF[] IS INITIAL.
PERFORM APPEND_STRING_TO_FILE USING '<PROXY_PARAMS_DEFAULT>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXMSCONFDF
USING  G_IREF_PDOCUMENT
'SXMSCONFDF'.
PERFORM APPEND_STRING_TO_FILE USING '</PROXY_PARAMS_DEFAULT>'.
ENDIF.

* User non-default SXMB_ADM parameters
IF NOT LT_SXMSCONFVL[] IS INITIAL.
PERFORM APPEND_STRING_TO_FILE USING '<PROXY_PARAMS_VALUES>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXMSCONFVL
USING  G_IREF_PDOCUMENT
'SXMSCONFVL'.
PERFORM APPEND_STRING_TO_FILE USING '</PROXY_PARAMS_VALUES>'.
ENDIF.

* Interfaces for archive (not default delete)
IF NOT LT_SXMSARCITF[] IS INITIAL.
PERFORM APPEND_STRING_TO_FILE USING '<PROXY_ARC_INTERFACES>'.
PERFORM ADD_ITAB_TO_FILE_SIMPLE TABLES LT_SXMSARCITF
USING  G_IREF_PDOCUMENT
'SXMSARCITF'.
PERFORM APPEND_STRING_TO_FILE USING '</PROXY_ARC_INTERFACES>'.
ENDIF.

ENDFORM.                    " EXTRACT_PROXIES_PARAMS

*&---------------------------------------------------------------------*
*&      Form  CHECK_AUTH_WORKLOAD_STATISTIC
*&---------------------------------------------------------------------*
FORM CHECK_AUTH_WORKLOAD_STATISTIC.

DATA: RFC_ERROR TYPE RFCLOG_D,
MSG1 TYPE RFCLOG_D,
MSG2 TYPE RFCLOG_D.

* Check that web usage extraction is needed
* and that RFC target is 700 or higher
* to verify that the function exists in destination
IF NO_WEB_USAGE IS INITIAL
AND ( RFC_SAPRL > '700' OR RFC_SAPRL = '700' ).

CALL FUNCTION 'SWNC_GET_WORKLOAD_STATISTIC' DESTINATION P_RFCDES
EXCEPTIONS
UNKNOWN_PERIODTYPE      = 1
NO_DATA_FOUND           = 2
UNKNOWN_ERROR           = 3
SYSTEM_FAILURE          = 4  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE   = 5  MESSAGE RFC_ERROR
OTHERS                  = 6.

IF SY-SUBRC = 4 OR SY-SUBRC = 5.
MSG1 = RFC_ERROR(50).
MSG2 = RFC_ERROR+50.
MESSAGE E000(CONV) WITH MSG1 MSG2.
ENDIF.
ENDIF.

IF ( NOT EXTRACT_PROXY_DATA IS INITIAL )
AND ( RFC_SAPRL >= '700' OR RFC_SAPRL = '640' ).

CALL FUNCTION 'SXMB_GET_MESSAGE_LIST' DESTINATION P_RFCDES
EXCEPTIONS
NOT_AUTHORIZED             = 1
INTERNAL_ERROR             = 2
TOO_MANY_MESSAGES          = 3
NO_MESSAGE                 = 4
SYSTEM_FAILURE             = 5  MESSAGE RFC_ERROR
COMMUNICATION_FAILURE      = 6  MESSAGE RFC_ERROR
OTHERS                     = 7
.
IF SY-SUBRC = 1 .
MSG1 = 'The user has no authorizations reading proxies'.
IF P_RFCDES = 'NONE'.
MSG2 = ' usage in your current system.'.
ELSE.
CONCATENATE ' usage in system ' P_RFCDES '.'
INTO MSG2 SEPARATED BY SPACE.
ENDIF.
MESSAGE E000(CONV) WITH MSG1 MSG2.
ELSEIF SY-SUBRC = 5 OR SY-SUBRC = 6.
MSG1 = RFC_ERROR(50).
MSG2 = RFC_ERROR+50.
MESSAGE E000(CONV) WITH MSG1 MSG2.
ENDIF.
ENDIF.

ENDFORM.                    " CHECK_AUTH_WORKLOAD_STATISTIC
FORM EXTRACT_MODULE_APP_COMP.
ENDFORM.

FORM FIND_APPC_MODULE TABLES NODES STRUCTURE SNODETEXT
USING  APPC TYPE SNODETEXT
CHANGING MODULE TYPE SNODETEXT.
ENDFORM.

FORM EXTRACT_REL_DEV_CLASS_COMP.
ENDFORM.                    " EXTRACT_RELATION_DEV_CLASS_COMP

FORM EXTRACT_HR_DATA.
ENDFORM.                    " extract_hr_data

FORM extract_business_objects.
ENDFORM.                    " extract_business_objects
