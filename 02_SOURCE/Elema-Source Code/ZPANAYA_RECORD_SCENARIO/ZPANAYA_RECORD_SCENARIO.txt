*-------------------------------------------------------------------*
* Panaya Scenario Recorder tool                                     *
* Author: Panaya Ltd (www.panaya.com)                               *
*-------------------------------------------------------------------*
* Copyright (c) 2013 Panaya Ltd. All rights reserved.               *
*                                                                   *
* Warning: This computer program is  protected by copyright law and *
* international treaties. Unauthorized reproduction or distribution *
* of the program, or any  portion of it, may result in severe civil *
* and criminal  penalties, and  will be  prosecuted  to the maximum *
* extent possible under the law.                                    *
*-------------------------------------------------------------------*
* THIS COMPUTER PROGRAM IS PROVIDED TO YOU STRICTLY ON AN "AS IS"   *
* BASIS. ALL CONDITIONS, REPRESENTATIONS AND WARRANTIES, WHETHER    *
* EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT      *
* LIMITATION, ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR  *
* A PARTICULAR PURPOSE, OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS   *
* IN RELATION TO THIS COMPUTER PROGRAM, ARE HEREBY DISCLAIMED TO    *
* THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW BY PANAYA          *
* (INCLUDING ITS AFFILIATES, DIRECTORS, OFFICERS, EMPLOYEES, AGENTS,*
* CONTRACTORS, SUCCESSORS OR ASSIGNEES) AND ITS LICENSORS. WITHOUT  *
* DEROGATING FROM THE AFORESAID, PANAYA AND ITS LICENSORS MAKE NO   *
* REPRESENTATION, WARRANTY, OR GUARANTY AS TO THE RELIABILITY,      *
* QUALITY, SUITABILITY, AVAILABILITY, ACCURACY OR COMPLETENESS OF   *
* THIS COMPUTER PROGRAM. PANAYA (INCLUDING ITS AFFILIATES,          *
* DIRECTORS, OFFICERS, EMPLOYEES, AGENTS, CONTRACTORS, SUCCESSORS   *
* OR ASSIGNEES) AND ITS LICENSORS DO NOT REPRESENT OR WARRANT THAT  *
* (A) THE USE OF THIS COMPUTER PROGRAM WILL BE TIMELY,              *
* UNINTERRUPTED OR ERROR-FREE OR OPERATE IN COMBINATION WITH ANY    *
* OTHER HARDWARE, SOFTWARE, SYSTEM OR DATA, (B) THIS COMPUTER       *
* PROGRAM WILL MEET YOUR REQUIREMENTS OR EXPECTATIONS, (C) ERRORS   *
* OR DEFECTS WILL BE CORRECTED, OR (D) THIS COMPUTER PROGRAM IS     *
* FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS.                      *
*-------------------------------------------------------------------*
* This version of the program is valid for SAP ECC 6.0              *
*-------------------------------------------------------------------*
REPORT ZPANAYA_RECORD_SCENARIO.

*                                             =======
CONSTANTS: REL_SPECIFIC_VER(15) TYPE C VALUE '1_2005'.
*                                             =======

CONSTANTS:
CO_NEW_LINE TYPE ABAP_CHAR1 VALUE CL_ABAP_CHAR_UTILITIES=>NEWLINE.

TYPE-POOLS: SATRE.

*--------- Panaya Recorder Version ----------========---------------*
CONSTANTS: GENERAL_PART_VER(15) TYPE C VALUE  '1.62'.
*--------------------------------------------========---------------*

*-------------------------------------------------------
* Includes
*-------------------------------------------------------
INCLUDE <ICON>.

*-------------------------------------------------------
* Type-pools
*-------------------------------------------------------
TYPE-POOLS: ABAP.

*-------------------------------------------------------
* Class
*-------------------------------------------------------
CLASS CL_IXML DEFINITION LOAD.

*-------------------------------------------------------
* Constants
*-------------------------------------------------------
CONSTANTS:
CDATA_END_REPLACE(15)     TYPE C VALUE '&xml_cdata_end&',
SKIP_EMPTY_TAGS           TYPE C VALUE 'X',
C_LINE_FEED(3)            TYPE C VALUE '@.@' ,
WITH_BATCH_INPUT_AND_MSGS TYPE C VALUE ' ',
MAX_TIME_FOR_LOCKED_WP(4) TYPE N VALUE 1800,
C_MAX_BUFFER_SIZE         TYPE I VALUE 100000,
C_SCENARIO_NAME_DEFAULT   TYPE C VALUE ' ',
C_OFFLINE_MODE            TYPE C VALUE ' ',
GZIP_COMMAND              LIKE SXPGCOLIST-NAME
VALUE 'ZZ_COMPRESS',
EXTERNALLY_CALLED_START   TYPE TCODE VALUE '$PANAYA_START_REC$',
EXTERNALLY_CALLED_END     TYPE TCODE VALUE '$PANAYA_END$',
EXTERNALLY_CALLED_START_RTT TYPE TCODE VALUE '$PANAYA_START_RTT$',
RTT_WAIT_TIME               TYPE I VALUE 10,
EXTERNALLY_CALLED_RESTORE   TYPE TCODE VALUE '$PANAYA_RESTORE$',
G_DELIMITER(3)              TYPE C VALUE '~#~',
RECORDING                   TYPE C VALUE 'R',
RESUME_PAUSE                TYPE C VALUE 'P',
PAUSE_PLAY                  TYPE C VALUE 'P',
*    Flush the log data to client side file .log
GC_FLUSH_LOG                TYPE FLAG VALUE ABAP_TRUE,
*    For each line of the log except for control lines
*    write data to file or to internal table
GC_LOG_WRITE                TYPE FLAG VALUE ABAP_FALSE,
*    This will be used when writing trace in text mode ( for debugging )
SHOULD_ENCODE_BASE_64_DEBUG(1) TYPE C VALUE 'X',
*    States whether to run the runtime trace or not ( for debugging )
SHOULD_RUN_RUNTIME_TRACE(1)    TYPE C VALUE 'X',
*    Panaya's troubleshoot mode ( for debugging )
PANAYA_TROUBLESHOOT_MODE(1)    TYPE C VALUE ' '.

*-------------------------------------------------------
* Types
*-------------------------------------------------------
TYPES: BEGIN OF THFB_TRACE,
ID TYPE I,
WPTYPE(3),
LEVEL(2),
MAIN(1),
DIAG(1),
ABAP(1),
DB(1),
IPC(1),
ROLL(1),
PAGE(1),
BATCH(1),
ENQ(1),
SPOOL(1),
DYNP(1),
DBSL(1),
SNC(1),
EM(1),
DBG(1),
NLS(1),
VMC(1),
ITS(1),
ICF(1),
RES1(1),
END OF THFB_TRACE.
* The max size of SAP user parameter is 250
* if the size is changed from 250
* in 4.6c version add local types till the new length in ver_def
TYPES: BEGIN OF PARAM_VALUE,
ID        TYPE TPARA-PARAMID,
VALUE(250) TYPE C,
END OF PARAM_VALUE.
TYPES: PARAMS_VALUE_TAB TYPE TABLE OF PARAM_VALUE.
TYPES: BEGIN OF PARAMS_PER_GROUP,
GROUP_ID(25) TYPE C,
PID          TYPE TPARA-PARAMID,
VALUE(250)    TYPE C,
END OF PARAMS_PER_GROUP.

TYPES: PARAM_GROUP_TAB TYPE TABLE OF PARAMS_PER_GROUP.
TYPES:
BEGIN OF TIME_STATS_TYPE,
STEP(512) TYPE C,
STARTDATE TYPE AS4DATE,
STARTTIME TYPE AS4TIME,
ENDDATE TYPE AS4DATE,
ENDTIME TYPE AS4TIME,
END OF TIME_STATS_TYPE.
TYPES: HTML_REC_TYPE TYPE CHAR1024.
TYPES: HTML_TAB_TYPE TYPE TABLE OF HTML_REC_TYPE.
TYPES: SVAL_TAB TYPE TABLE OF SVAL.
TYPES:
BEGIN OF STRING_REC,
LINE(1024) TYPE C,
END OF STRING_REC,
STRING_TAB TYPE TABLE OF STRING_REC.
TYPES:  WPINFOTAB TYPE STANDARD TABLE OF SE30WPINFO,
WP_ID(8).
TYPES: BEGIN OF TY_MEASUREMENT_LOG,
TIME        TYPE STRING,
ACTION      TYPE STRING,
MODE        TYPE STRING,
TIME_MILI   TYPE STRING,
DESCRIPTION TYPE STRING,
VAR         TYPE STRING,
END OF TY_MEASUREMENT_LOG.

*-------------------------------------------------------
* Data definition
*-------------------------------------------------------
DATA: URL_PREF TYPE CHAR1024 VALUE
'https://my.panaya.com'.

DATA: PREV_MODE TYPE I.
DATA: PREV_COMP TYPE I.
DATA: ENCODING TYPE STRING.
DATA: GT_BDCDATA TYPE TABLE OF BDCDATA,
GT_MSG     TYPE TABLE OF BDCMSGCOLL,
G_XML_SIZE TYPE I.
DATA: CAB_FILEPATH TYPE STRING.
DATA: TH_TRCCOMPS(40)      TYPE C.
DATA: P_FILE TYPE STRING.
DATA: TH_OPCODE(1) TYPE X.
DATA: CURR_WP_NO TYPE I.
DATA: G_FIRST_REL_POS(12) TYPE N.
DATA: G_TRANS_INDEX(4) TYPE N.
DATA: MAX_TIME_FOR_LOCKED_WP_MIN(2) TYPE N,
G_IT_PARAMS_VALUES TYPE TABLE OF TPARA WITH HEADER LINE.
DATA: G_USERS_PARAMS TYPE PARAM_GROUP_TAB WITH HEADER LINE.
DATA: GT_TIME_STAT TYPE TABLE OF TIME_STATS_TYPE WITH HEADER LINE.
DATA: G_FILENAME TYPE STRING.
DATA: G_BUFFER_ITAB TYPE STRING_TAB.
DATA: G_WAS_FILE_CREATED.
DATA: G_STARTTIME LIKE SY-UZEIT.
DATA: G_FIELDS TYPE TABLE OF SVAL.
DATA: G_FIELD LIKE LINE OF G_FIELDS.
DATA: G_TRANS_ADDED_TO_FILE,
TEXT TYPE STRING,
G_OLD_TRACE_SIZE(8) TYPE N,
G_OLD_TRACE_TIME(6) TYPE N.
DATA: LEN TYPE I.
DATA: SEL_FILENAME      TYPE STRING,
INITIAL_DIRECTORY TYPE STRING,
DEFAULT_EXTENSION TYPE STRING,
DEFAULT_FILENAME  TYPE STRING,
FILE_FILTER       TYPE STRING,
USER_ACTION       TYPE I,
FULLPATH          TYPE STRING,
PATH              TYPE STRING,
SAP_WORK_DIR TYPE SDOK_CHTRD.
DATA: DIR_EXISTS        TYPE ABAP_BOOL,
DIRECTORY         TYPE STRING.
DATA: G_FILE_IS_APPEND_MODE_SERVER  TYPE CHAR01 VALUE SPACE.
DATA: G_FILE_IS_APPEND_MODE_CLIENT  TYPE CHAR01 VALUE SPACE.
DATA: TEMP_XML_FILENAME(250).
DATA: IS_ZIP_AVAILABLE.
DATA: VALID_CHARS TYPE STRING.
DATA: CALLED_EXTERNALLY_START.
DATA: CALLED_EXTERNALLY_END.
DATA: CALLED_EXTERNALLY_START_RTT.
DATA: G_LOG_FILENAME TYPE STRING.
*DATA: g_glob_params_filename TYPE string.
DATA: CALLED_EXTERNALLY_RESTORE.
DATA: G_PAUSE_XML_FILENAME TYPE STRING,
G_RECORDING_PARAM_DIRECTORY TYPE STRING,
G_RECORDING_PARAM_FILENAME TYPE STRING.
DATA: G_RESUME_PAUSE_FILENAME TYPE STRING.
DATA: G_APPEND_USER_PARAMS(1) TYPE C.

DATA: G_LOG_FILE_APPEND_MODE_CLIENT.
DATA: G_SHOW_TRANS_STATUS_APPEARS.
DATA: DECIMAL_FORMAT LIKE USR01-DCPFM VALUE '-',
DATE_FORMAT LIKE USR01-DATFM  VALUE '-'.
DATA: MAX_LOCK_ATTEMPTS VALUE 3.
DATA: G_XML_LOG_MESSAGES TYPE STRING_TAB.
DATA: WAS_RTT_ACTIVATED.
DATA: ATRA_FILENAME TYPE SE30FNAME.
DATA: ATRA_SESSION_ID TYPE SE30SESID.
DATA: ATRA_SESSION_TIME TYPE SE30SESTIM.
DATA: TASK_NAME TYPE STRING.
DATA: ATRA_ENDED.
DATA: ATRA_LOG1 TYPE STRING.
DATA: GV_VALIDATION_MODE TYPE FLAG,
GV_PGMNA           TYPE PROGRAM_ID.
DATA: GT_LOG_DATA        TYPE STRING_TAB,
GT_MEASUREMENT_LOG TYPE STANDARD TABLE OF TY_MEASUREMENT_LOG,
GV_LAST_MEASURE    TYPE I.
DATA: GV_UNICODE_SYSTEM  TYPE FLAG,
GV_SAP_APPL TYPE STRING,
GV_SAP_HR   TYPE STRING,
GV_EA_HR    TYPE STRING.

*-------------------------------------------------------
* Selection screen
*-------------------------------------------------------
SELECTION-SCREEN BEGIN OF BLOCK B1 WITH FRAME TITLE TIT1.

SELECTION-SCREEN SKIP 1.

* Transaction code
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_TCOD.
PARAMETERS: P_TCODE TYPE TCODE OBLIGATORY.
SELECTION-SCREEN END OF LINE.

* Scenario name
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_NAM.
PARAMETERS: P_SCENAR(132) TYPE C LOWER CASE.
SELECTION-SCREEN END OF LINE.

* Scenario description
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) DES_NAM.
PARAMETERS: P_DESC(128) TYPE C LOWER CASE.
SELECTION-SCREEN END OF LINE.

* Mode of zp_record execution - R = Recording mode
*                               P = Resume Pause when in start
*                                   / Pause Pressed when in end
*                               Empty = Running in old mode OR
*                                       Player(For new mode).
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_MODE.
PARAMETERS: P_MODE(1) TYPE C.
SELECTION-SCREEN END OF LINE.
* Group id - Used in restore mode so in the trace it will be visible
* what group id was used in this particular call.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_GRP.
PARAMETERS: P_PGRPID(20) TYPE C.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP 1.

* Offline mode
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 4.
PARAMETERS  C_OFF AS CHECKBOX USER-COMMAND OFF DEFAULT ' ' .
SELECTION-SCREEN COMMENT 6(12) TIT_OFF.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 4(20) TIT_OFFD.
PARAMETERS  P_OFF(128) TYPE C LOWER CASE.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK B1.

*Info
SELECTION-SCREEN BEGIN OF BLOCK B2 WITH FRAME TITLE TIT2.

SELECTION-SCREEN SKIP 1.

SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 1(79) TEXT1.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(79) TEXT2.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(79) TEXT3.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN SKIP 1.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(79) TEXT4.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 6(79) TEXT5.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN SKIP 1.

SELECTION-SCREEN END OF BLOCK B2.
*-------------------------------------------------------
* Initialization
*-------------------------------------------------------
INITIALIZATION.
PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'MEASUREMENT' '' 'Start of Measurement'.
PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'INITIALIZATION' '' 'Start of Initialization'.

* Get program run type - validation mode for se38/sa38
IF SY-TCODE = 'SE38' OR SY-TCODE = 'SA38'.
GV_VALIDATION_MODE = 'X'.
ELSE.
CLEAR : GV_VALIDATION_MODE.
ENDIF.

* Check that the transaction is not run in valdiation mode
* Texts initialization - user info for validation run
IF GV_VALIDATION_MODE = 'X'.

TIT2 = 'Info'.

CONCATENATE ICON_MESSAGE_INFORMATION
'Before you start recording or playing test scenarios'
INTO TEXT1 SEPARATED BY SPACE.

TEXT2 = 'your SAP system needs to be configured correctly.'.

CONCATENATE
'Please consult the installation guide for'
'the required installation steps.'
INTO TEXT3 SEPARATED BY SPACE.

TEXT4 = 'Run this program to check if the SAP system is setup'.

TEXT5 = 'for test recording and playback.'.
ENDIF.

* The recorder run from ZP_RECORD
CHECK GV_VALIDATION_MODE <> 'X'.

TIT1     = 'Parameters for recording'.
TIT_TCOD = 'Transaction code '.
TIT_NAM  = 'Scenario name '.
DES_NAM  = 'Scenario description'.
TIT_OFF  = 'Offline mode'.
TIT_OFFD = 'Location of files'.
VALID_CHARS =
'0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz_'.
MAX_TIME_FOR_LOCKED_WP_MIN = MAX_TIME_FOR_LOCKED_WP / 60.
TIT_MODE = 'Execution mode'.
TIT_GRP = 'Parameters group id'.

SAP_WORK_DIR = 'C:\'.
INITIAL_DIRECTORY = SAP_WORK_DIR.
P_OFF = INITIAL_DIRECTORY.

* Check that the program wasn't run in background
IF SY-BATCH = 'X'.
MESSAGE E001(00) WITH
'This program should not be run in background.'.
ENDIF.

* Check that 'Low-Speed Connection' is not turned on
DATA: LT_STUB_CLIENT_DATA TYPE STRING_TAB.
PERFORM CHECK_WAN_FLAG USING ABAP_TRUE
CHANGING LT_STUB_CLIENT_DATA.

* Initialize tcode field
G_FIELD-TABNAME = 'TSTC'.
G_FIELD-FIELDNAME = 'TCODE'.
G_FIELD-FIELD_OBL = 'X'.
APPEND G_FIELD TO G_FIELDS.

* Enable filename in offline mode
LOOP AT SCREEN.

*   C_OFF checkbox is shown according
*   to constant C_OFFLINE_MODE
IF  ( SCREEN-NAME = 'C_OFF' OR
SCREEN-NAME = 'TIT_OFF' )
AND ( C_OFFLINE_MODE IS INITIAL ).
SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '1'.
SCREEN-INVISIBLE = '1'.
MODIFY SCREEN.
ENDIF.
ENDLOOP.

* Get user's date and decimal format
SELECT SINGLE DCPFM DATFM FROM USR01
INTO (DECIMAL_FORMAT,DATE_FORMAT)
WHERE BNAME EQ SY-UNAME.

* Check if Show transfer appear in GUI_DOWNLOAD
PERFORM CHECK_SHOW_TRAN_STAT CHANGING G_SHOW_TRANS_STATUS_APPEARS.

* Check if previous recording was terminated by 'leave to transaction'
* and handle it.
PERFORM FINISH_PREV_RECORDING.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'INITIALIZATION' '' 'End of initialization'.
*-------------------------------------------------------
* At selection screen events
*-------------------------------------------------------
AT SELECTION-SCREEN OUTPUT.
*--------------------------

LOOP AT SCREEN.

*   Make scenario name mandatory - if needed
IF C_SCENARIO_NAME_DEFAULT  IS INITIAL
AND SCREEN-NAME = 'P_SCENAR'.
SCREEN-REQUIRED = '1'.
MODIFY SCREEN.
ENDIF.

*   C_OFF checkbox is shown according
*   to constant C_OFFLINE_MODE
IF  ( SCREEN-NAME = 'C_OFF' OR
SCREEN-NAME = 'TIT_OFF' )
AND ( C_OFFLINE_MODE IS INITIAL ).
SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '1'.
SCREEN-INVISIBLE = '1'.
MODIFY SCREEN.
ENDIF.

*   Offline directory is shown according to
*   C_OFF checkbox value
IF  ( SCREEN-NAME = 'P_OFF' OR
SCREEN-NAME = 'TIT_OFFD' )
AND  C_OFF IS INITIAL.
SCREEN-INPUT = '0'.
SCREEN-OUTPUT = '1'.
SCREEN-INVISIBLE = '1'.
MODIFY SCREEN.
ENDIF.

*   For vlaidation mode - se38/sa38 execution hide all fields
IF   GV_VALIDATION_MODE = 'X' AND
( SCREEN-NAME <> 'TEXT1' AND
SCREEN-NAME <> 'TEXT2' AND
SCREEN-NAME <> 'TEXT3' AND
SCREEN-NAME <> 'TEXT4' AND
SCREEN-NAME <> 'TEXT5' AND
SCREEN-NAME <> 'TIT2' ).
SCREEN-INPUT = '0'.
SCREEN-INVISIBLE = '1'.
MODIFY SCREEN.
ELSEIF ( SCREEN-NAME = 'TEXT1' OR
SCREEN-NAME = 'TEXT2' OR
SCREEN-NAME = 'TEXT3' OR
SCREEN-NAME = 'TEXT4' OR
SCREEN-NAME = 'TEXT5' OR
SCREEN-NAME = 'TIT2' ) AND
( GV_VALIDATION_MODE <> 'X' ).
SCREEN-INPUT = '0'.
SCREEN-INVISIBLE = '1'.
MODIFY SCREEN.
ENDIF.

ENDLOOP.

AT SELECTION-SCREEN ON P_TCODE.
DATA: TTEXT LIKE TSTCT-TTEXT.

* The program execute in non vlaidation mode
CHECK GV_VALIDATION_MODE <> 'X'.

* Don't check the transaction in case of external start and end
IF P_TCODE <> EXTERNALLY_CALLED_START  AND
P_TCODE <> EXTERNALLY_CALLED_END    AND
P_TCODE <> EXTERNALLY_CALLED_START_RTT AND
P_TCODE <> EXTERNALLY_CALLED_RESTORE.

IF PANAYA_TROUBLESHOOT_MODE IS INITIAL.
*     Show the message
CALL FUNCTION 'POPUP_TO_INFORM'
EXPORTING
TITEL         = 'Panaya recorder - ERROR'
TXT1          =
'Recording test scenarios directly from SAP is not supported.'
TXT2          =
'Please start the recording from the Panaya web '
TXT3          =
'application,'
TXT4          =
'by clicking the "Record Scenario" button.'.

LEAVE PROGRAM.
ENDIF.

*   Check transaction
PERFORM CHECK_TRANSACTION.

*   If scenario name was not set - add a default
IF ( P_SCENAR = ' ' ) AND ( P_TCODE <> ' ' ).
SELECT SINGLE TTEXT
FROM TSTCT
INTO TTEXT
WHERE TCODE = P_TCODE AND SPRSL = SY-LANGU.

IF SY-SUBRC IS INITIAL.
CONCATENATE 'Unit test for '
P_TCODE '-' TTEXT
INTO P_SCENAR
SEPARATED BY SPACE.
ENDIF.
ENDIF.
ENDIF.

AT SELECTION-SCREEN ON P_OFF.

* The program execute in non vlaidation mode
CHECK GV_VALIDATION_MODE <> 'X'.

IF ( P_TCODE <> EXTERNALLY_CALLED_START AND
P_TCODE <> EXTERNALLY_CALLED_END ).

*   Check that directory exists
PERFORM CHECK_DIRECTORY_EXISTS.

ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR P_OFF.
*------------------------------------------------
* Select directory
* Use INITIAL_DIRECTORY and not P_OFF, since P_OFF is cleaned here
CALL METHOD CL_GUI_FRONTEND_SERVICES=>DIRECTORY_BROWSE
EXPORTING
INITIAL_FOLDER  = INITIAL_DIRECTORY
CHANGING
SELECTED_FOLDER = PATH
EXCEPTIONS
CNTL_ERROR      = 1
ERROR_NO_GUI    = 2
OTHERS          = 3.

CALL METHOD CL_GUI_CFW=>FLUSH.

IF SY-SUBRC <> 0.
MESSAGE I000(CONV) WITH 'Error when choosing directory '
' for offline processing. Error message: ' SY-SUBRC.
ENDIF.

LEN = STRLEN( PATH ).

* Check the directory is not too long ( 128 - filename length(52) )
IF LEN > 76.
MESSAGE I000(CONV) WITH 'The chosen directory name too long.'
' Maximum length of the filename is 76 chars'.
ELSE.
P_OFF = PATH.

*   Synchronize INITIAL_DIRECTIRY with P_OFF to be used next time for
*   calling cl_gui_frontend_services=>directory_browse
INITIAL_DIRECTORY = P_OFF.
ENDIF.

*-------------------------------------------------------
* Start of selection event
*-------------------------------------------------------
START-OF-SELECTION.

* Perform ZP_RECORD settings validation
* Program executed from SE38 for validations only
IF GV_VALIDATION_MODE = 'X'.
PERFORM VALIDATION_CHECKS.
ENDIF.

* The program is run in non validation mode
CHECK GV_VALIDATION_MODE <> 'X'.

* Check if the program was called externally
PERFORM HADNLE_EXTERNALLY_CALLED.

* Save when recording was started
G_STARTTIME = SY-UZEIT.

* Process in case of external recording start
IF CALLED_EXTERNALLY_START = 'X'.
PERFORM EXTERNAL_START_REC.
IF NOT SHOULD_RUN_RUNTIME_TRACE IS INITIAL.
PERFORM START_RTT.
ELSE.
CLEAR WAS_RTT_ACTIVATED.
ENDIF.

* Process in case of external recording start
ELSEIF CALLED_EXTERNALLY_END = 'X'.
IF NOT SHOULD_RUN_RUNTIME_TRACE IS INITIAL.
PERFORM END_RTT.
ENDIF.
PERFORM EXTERNAL_END_REC.

* Process for activating ATRA when called in a different task
ELSEIF CALLED_EXTERNALLY_START_RTT = 'X'.
PERFORM START_RTT_FROM_ABAP4_CALL_TRAN.
ELSEIF CALLED_EXTERNALLY_RESTORE = 'X'.
DATA: DELETE_FILE TYPE C VALUE ' ',
ONLY_RESTORE_CALLED,
L_FILENAME(128) TYPE C.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE
'***STARTED RESTORE MODE***' '' '***STARTED RESTORE MODE***'.

*   Get the filename
GET PARAMETER ID 'PANAYA_SR22' FIELD L_FILENAME.
G_FILENAME = L_FILENAME.

*   Get the log file append mode
GET PARAMETER ID 'PANAYA_SR26' FIELD
G_LOG_FILE_APPEND_MODE_CLIENT.

*   Generate file names before writing to log, because the log
*   filename is generated here.
PERFORM GENERATE_UPARAMS_FILENAMES.

PERFORM ADD_TO_LOG USING '' GC_LOG_WRITE.
PERFORM ADD_TO_LOG USING
'**** Restore operation called. ****' GC_FLUSH_LOG.

PERFORM RESTORE_UPARAMS USING P_SCENAR
DELETE_FILE
GC_LOG_WRITE.

*   the log flush is executed after the measurements added
PERFORM ADD_MEASURES_TO_LOG.
* Other ( regular recording )
ELSE.

*   Check that the gzip is installed properally
PERFORM CHECK_GZIP USING 'X'.

*   Initializations before the recording
PERFORM INIT_RECORDING TABLES G_FIELDS.

*   Add log message
PERFORM ADD_TO_LOG USING
'Recording started in regular mode.'
GC_FLUSH_LOG.

*   Start the program
PERFORM MAIN USING P_TCODE.

ENDIF.
*---------------------------------------------------------------------*
*       FORM ADD_TIME_STAT                                            *
*---------------------------------------------------------------------*
FORM ADD_TIME_STAT USING P_STEP P_STARTTIME.

GT_TIME_STAT-STEP = P_STEP.
GT_TIME_STAT-STARTTIME = P_STARTTIME.
GT_TIME_STAT-ENDTIME = SY-UZEIT.
GT_TIME_STAT-STARTDATE = SY-DATUM.
GT_TIME_STAT-ENDDATE = SY-DATUM.
APPEND GT_TIME_STAT.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  check_transaction
*&---------------------------------------------------------------------*
FORM CHECK_TRANSACTION.

DATA: TEMP_TCODE LIKE SY-TCODE.

* Check transaction was set
IF P_TCODE IS INITIAL.
MESSAGE E000(26) WITH
'Please enter transaction'.
ENDIF.

* Check that transaction is valid
SELECT SINGLE TCODE
FROM TSTC
INTO TEMP_TCODE
WHERE TCODE = P_TCODE.

IF NOT SY-SUBRC IS INITIAL.
MESSAGE E001(00) WITH
'Transaction does not exist.'
' Please enter a valid transaction'.
ENDIF.

* Check if the user has authorizations on this transaction
CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
EXPORTING
TCODE  = P_TCODE
EXCEPTIONS
OK     = 1
NOT_OK = 2
OTHERS = 3.

IF SY-SUBRC <> 1.
CONCATENATE 'You are not authorized to run transaction  '
P_TCODE '.' INTO TEXT SEPARATED BY SPACE.

MESSAGE E001(00) WITH TEXT.
ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  main
*&---------------------------------------------------------------------*
FORM MAIN USING P_TCODE TYPE TCODE.

DATA: ANSWER(1)  TYPE C,
IS_TRANSACTION_CHOSEN(1)  TYPE C,
FIELDS TYPE TABLE OF SVAL,
QUESTION TYPE STRING.

DO.

*   Record current transaction and add it to the result html file
*   The answer is whether new transaction should be added or not.
PERFORM RECORD_AND_WRITE_TRANSACTION CHANGING ANSWER.

*   If yes - add new transaction
IF ANSWER = '1'.

*     Set the trace parameters
PERFORM SET_DIAG_TRACE.

*     Choose new transaction and change p_tcode parameter accordingly
PERFORM CHOOSE_NEW_TRANSACTION CHANGING IS_TRANSACTION_CHOSEN.

IF IS_TRANSACTION_CHOSEN = SPACE.
EXIT.
ENDIF.

*   Do not add another transaction
ELSEIF ANSWER = '2'.
EXIT.
ENDIF.
ENDDO.

* Reset trace and transaction data
PERFORM RESET_DIAG_TRACE USING CURR_WP_NO.

* Restore the SPA/GPA values form before the recording
PERFORM RESTORE_GLOBAL_PARAMS.

* Ask if should upload to Panaya ( only if transaction was added
* to file )
IF G_TRANS_ADDED_TO_FILE = 'X'.

PERFORM POPUP_RECORDING_COMPLETED.

* If transaction was not added to file - delete the file
ELSE.
PERFORM DELETE_XML.
MESSAGE S001(00) WITH 'No transactions were added to trace'.
ENDIF.
ENDFORM.                    "main

*&---------------------------------------------------------------------*
*&      Form  ENABLE_DIAG_PARSER_TRACE
*&---------------------------------------------------------------------*
FORM SET_DIAG_TRACE.

DATA: CURR_TRACE TYPE THFB_TRACE,
SUCC LIKE SY-SUBRC,
PROCESS_LOCKED,
TEMP_CURR_WP_NO TYPE I,
COUNT TYPE I,
MSG TYPE STRING,
MSG1 TYPE STRING,
MSG2 TYPE STRING,
C_CURR_WP(4) TYPE C.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'SET DIAG TRACE' ''
'Start of setting diag trace:find current wp,lock wp,activate trace'.

* Delete trace files ( if there are no other Work processes that
* are traced )
PERFORM DELETE_TRACE_FILES.

* Find current WP
CALL FUNCTION 'TH_GET_OWN_WP_NO'
IMPORTING
SUBRC    = SUCC
WP_INDEX = CURR_WP_NO.

IF SY-SUBRC <> 0.
MSG = SUCC.
CONCATENATE :
'Error fetching current Work Process. Error code:'
MSG
INTO
MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH
'Error fetching current Work Process. Error code:'
' '
SUCC.
ELSE.
MSG = CURR_WP_NO.
CONCATENATE 'Current wp:' MSG INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ENDIF.

* Attempt to lock own process up to a fixed number of attempts
WHILE PROCESS_LOCKED = ''.

ADD 1 TO COUNT.

IF COUNT > MAX_LOCK_ATTEMPTS.
PERFORM SHOW_ERROR USING
'Error : Current work process could not be locked.'
'Please contact Panaya.' '' ''.
EXIT.
ENDIF.

*   Lock current WP
PERFORM TH_LOCK_WP.

*   Verify that work process has not changed
CALL FUNCTION 'TH_GET_OWN_WP_NO'
IMPORTING
SUBRC    = SUCC
WP_INDEX = TEMP_CURR_WP_NO.

IF TEMP_CURR_WP_NO = CURR_WP_NO.
PROCESS_LOCKED = 'X'.
MSG = CURR_WP_NO.
CONCATENATE 'Verified locking of wp:' MSG INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
*     Save the current workprocess  to memory
C_CURR_WP = CURR_WP_NO.
SET PARAMETER ID 'PANAYA_SR31' FIELD C_CURR_WP.
ELSE.
*     Write log
MSG1 = CURR_WP_NO.
MSG2 = TEMP_CURR_WP_NO.
CONCATENATE 'Lock Failed. Current work process changed from '
MSG1  ' to '  MSG2 INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CURR_WP_NO = TEMP_CURR_WP_NO.
ENDIF.

ENDWHILE.

* Activate trace
PERFORM TH_SET_WP_TRACE.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'SET DIAG TRACE' '' 'End of setting diag trace'.

ENDFORM.                    "SET_DIAG_TRACE
*&---------------------------------------------------------------------*
*&      Form  DISABLE_DIAG_PARSER_TRACE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM RESET_DIAG_TRACE USING WP_NO TYPE I.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'RESET DIAG TRACE' ''
'Start of reset diag trace: unlock wp, reset wp, reset panaya params'.

* Unlock the WP
PERFORM TH_UNLOCK_WP USING WP_NO.

* Return the Diag trace to level 1
PERFORM TH_RESET_WP_TRACE USING WP_NO.

* Reset transaction info
PERFORM RESET_TRANS_INFO.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'RESET DIAG TRACE' ''
'End of reset diag trace'.

ENDFORM.                    "RESET_DIAG_TRACE
*&---------------------------------------------------------------------*
*&      Form  record_transaction
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->IT_BDCDATA text
*      -->IT_MSG     text
*      -->P_TCODE    text
*----------------------------------------------------------------------*
FORM RECORD_TRANSACTION TABLES IT_BDCDATA STRUCTURE BDCDATA
IT_MSG     STRUCTURE BDCMSGCOLL
USING P_TCODE TYPE TCODE
CHANGING P_WAS_RECORDED.

DATA: OPTIONS_WA TYPE CTU_PARAMS,
TEXT TYPE STRING,
MSG TYPE STRING.

* Write to xml log
CONCATENATE 'Starting to record transaction' P_TCODE
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CLEAR P_WAS_RECORDED.

* Check if the user has authorizations on this transaction
CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
EXPORTING
TCODE  = P_TCODE
EXCEPTIONS
OK     = 1
NOT_OK = 2
OTHERS = 3.

IF SY-SUBRC <> 1.
CONCATENATE 'You are not authorized to run transaction  '
P_TCODE '.' INTO TEXT SEPARATED BY SPACE.

MESSAGE I001(00) WITH TEXT.
ELSE.

IF WITH_BATCH_INPUT_AND_MSGS IS INITIAL.

*     Record only using the trace
CALL TRANSACTION P_TCODE.

*     Recording was performed
P_WAS_RECORDED = 'X'.

ELSE.
*     Record the batch input and messages in addition to the trace.

*     This flags should be flagged on to show report
*     results properally.
*     OPTIONS_WA-NOBINPT = 'X'.
OPTIONS_WA-RACOMMIT = 'X'.

CALL FUNCTION 'BDC_RECORD_TRANSACTION'
EXPORTING
TCODE               = P_TCODE
OPTIONS             = OPTIONS_WA
MODE                = 'A'
TABLES
DYNPROTAB           = IT_BDCDATA
MESSTAB             = IT_MSG
EXCEPTIONS
SYSTEM_FAILURE      = 1
INVALID_TRANSACTION = 2
INVALID_MODE        = 3
INVALID_UPDATE      = 4
NO_AUTHORITY_TCODE  = 5
OTHERS              = 6.

IF SY-SUBRC <> 0.
PERFORM SHOW_ERROR USING 'Error while recording'
'transaction. Error :' SY-SUBRC ' '.
ELSE.
*       Recording was performed
P_WAS_RECORDED = 'X'.
ENDIF.

ENDIF.

ENDIF.

* Write to xml log
CONCATENATE 'End of recording of transaction' P_TCODE
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

ENDFORM.                    "record_transaction
*&---------------------------------------------------------------------*
*&      Form  add_transaction_to_xml
*&---------------------------------------------------------------------*
FORM ADD_TRANSACTION_TO_XML TABLES T_BDCDATA STRUCTURE BDCDATA
T_MSG STRUCTURE BDCMSGCOLL
USING    P_TCODE TYPE TCODE
P_SHOULD_ADD_TRANS TYPE FLAG
CHANGING C_XML_SIZE TYPE I.
DATA:  TCODE_STR TYPE STRING,
LV_STRING TYPE STRING,
STEP_NO TYPE STRING,
L_NO_OF_LINES TYPE I,
L_NO_OF_ADDED_LINES TYPE I,
PWP_INDEX(5) TYPE C,
FULL_TRACE_FILENAME LIKE RLGRAP-FILENAME,
CURR_LINE TYPE STRING,
CURR_LINE_LEN TYPE I,
L_IS_FIRST_TRACE_LINE,
L_TRANS_HEADER TYPE STRING,
MSG TYPE STRING,
LOG_MESSAGE TYPE STRING,
L_READ_ALSO_OLD_TRACE TYPE C,
L_OLD_TRACE_FILENAME LIKE RSMRGSTR-NAME,
L_TRACE_FILENAME LIKE RLGRAP-FILENAME,
L_CURR_OLD_TRACE_SIZE TYPE RSFILLST-LEN,
L_CURR_OLD_TRACE_TIME TYPE RSFILLST-MTIME.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'ADD TRACE DATA TO XML' ''
'start adding work process trace data to xml file'.

* Write current transaction data
TCODE_STR = P_TCODE.
STEP_NO = G_TRANS_INDEX.

IF P_SHOULD_ADD_TRANS = 'X'.
L_TRANS_HEADER = '  <TRANSACTION'.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'Index' STEP_NO
CHANGING L_TRANS_HEADER.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'Name' TCODE_STR
CHANGING L_TRANS_HEADER.

CONCATENATE L_TRANS_HEADER '>' INTO L_TRANS_HEADER.

PERFORM APPEND_XML_TO_BUFFER USING L_TRANS_HEADER.

*   No bdc data or messages are currently printed
PERFORM APPEND_XML_TO_BUFFER USING '    <INPUT_SEQUENCE/>'.
PERFORM APPEND_XML_TO_BUFFER USING '    <MESSAGES/>'.

ENDIF.

* Write Trace data
PERFORM APPEND_XML_TO_BUFFER USING '    <TRACE>'.
PERFORM APPEND_XML_TO_BUFFER USING '      <![CDATA['.

* Get filename
WRITE CURR_WP_NO TO PWP_INDEX LEFT-JUSTIFIED.
PERFORM GET_FILENAME USING PWP_INDEX CHANGING FULL_TRACE_FILENAME.

* Write log:
MSG = G_FIRST_REL_POS.
SHIFT MSG LEFT DELETING LEADING '0'.
CONCATENATE 'Attempting to read trace data from file'
FULL_TRACE_FILENAME 'from line number' MSG
'. Current process number is' PWP_INDEX INTO MSG
SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

* Continue only if filename exists
IF ( NOT FULL_TRACE_FILENAME IS INITIAL ).

PERFORM GET_TRACE_FILENAME CHANGING L_TRACE_FILENAME.
PERFORM GET_OLD_TRACE_FILENAME CHANGING L_OLD_TRACE_FILENAME.

*   Check which trace file/s we need to read.
*   In case there was an .old trace when we started the recording and
*   it was changed, or, there was no .old trace when recording started
*   but there is now (recording end) - we need to read trace data both
*   from the 'dev_wxx' and 'dev_wxx.old' files. Otherwise, read only
*   the 'dev_wxx'
PERFORM CHECK_READ_ALSO_OLD_TRACE CHANGING L_READ_ALSO_OLD_TRACE.

*   Add wps in system status to log
PERFORM ADD_WPS_STATUS_TO_LOG.

*   Flush buffer to temp file
*   the buffer is of type string
*   the trace data will be read in binary way and will be added
*   to temp file in binary
*   emsures all prevoius data will be in temp file prior to trace
PERFORM FLUSH_BUFFER USING ' ' ' '.

IF L_READ_ALSO_OLD_TRACE = 'X'.
PERFORM ADD_TRACE_TO_BUFFER USING L_OLD_TRACE_FILENAME
G_FIRST_REL_POS.
PERFORM ADD_TRACE_TO_BUFFER USING L_TRACE_FILENAME 1.
ELSE.
PERFORM ADD_TRACE_TO_BUFFER USING L_TRACE_FILENAME
G_FIRST_REL_POS.
ENDIF.

*   Check if the .old trace file changed while we read it.
PERFORM READ_TRACE_INFO USING L_OLD_TRACE_FILENAME
CHANGING L_CURR_OLD_TRACE_SIZE
L_CURR_OLD_TRACE_TIME.

*   Add suffixes and add to file.
PERFORM APPEND_XML_TO_BUFFER USING ']]>'.
PERFORM APPEND_XML_TO_BUFFER USING '    </TRACE>'.

ELSE.
PERFORM SHOW_ERROR USING
'Trace filename was not found. ' ' ' ' ' ' '.
ENDIF.

* Add the end measurements data to log file
* the log flush is executed after the measurements added
PERFORM ADD_MEASURES_TO_LOG.

* Adding the log data to xml - Done on player application
*  perform add_log_to_xml.

IF P_SHOULD_ADD_TRANS = 'X'.

*   Add last transaction
PERFORM APPEND_XML_TO_BUFFER USING '  </TRANSACTION>'.
ENDIF.

* Add indicator that transaction was added to file
G_TRANS_ADDED_TO_FILE = 'X'.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'ADD TRACE DATA TO XML' ''
'end adding work process trace data to xml file'.

ENDFORM.                    "ADD_TRANSACTION_TO_XML


*---------------------------------------------------------------------*
*       FORM add_trace_to_buffer                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_FILENAME                                                    *
*  -->  P_START_LINE                                                  *
*---------------------------------------------------------------------*
FORM ADD_TRACE_TO_BUFFER USING P_FILENAME
P_START_POS.

* Open file
DATA: FILE_OPENED   TYPE C,
LV_X(65535)   TYPE X,
LV_EOF_SUBRC  TYPE I,
L_NO_OF_READS TYPE I,
LEN           TYPE I,
CURR_LINE     TYPE STRING,
CURR_LINE_LEN TYPE I,
MSG           TYPE STRING.

MSG = P_FILENAME.
PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'READ TRACE FILE DATA' MSG
'Start read trace file data'.
CLEAR : MSG.

PERFORM CHECK_UNICODE_SYSTEM.

PERFORM OPEN_FILE USING P_FILENAME
P_START_POS
CHANGING FILE_OPENED.

DO.
*   Read trace file data
IF NOT GV_UNICODE_SYSTEM IS INITIAL.
*     Unicode read the data in binary
READ DATASET P_FILENAME INTO LV_X LENGTH LEN.
ELSE.
*     Non unicode read the data in textual
READ DATASET P_FILENAME INTO CURR_LINE LENGTH CURR_LINE_LEN.
ENDIF.

*   Check if reached end of wp file
IF SY-SUBRC <> 0.
LV_EOF_SUBRC = SY-SUBRC.
IF LEN = 0 AND
CURR_LINE_LEN = 0.
EXIT.
ENDIF.
ENDIF.

*   Write trace data to temp file at the server
IF NOT GV_UNICODE_SYSTEM IS INITIAL.
*     The system is unicode open the temp file as binary
*     write binary trace data
IF G_FILE_IS_APPEND_MODE_SERVER IS INITIAL.
OPEN DATASET TEMP_XML_FILENAME FOR OUTPUT IN BINARY MODE.
G_FILE_IS_APPEND_MODE_SERVER = 'X'.
ELSE.
OPEN DATASET TEMP_XML_FILENAME FOR APPENDING IN BINARY MODE.
ENDIF.

TRANSFER LV_X(LEN) TO TEMP_XML_FILENAME.
ELSE.
*     System is non unicode - open textual temp file
*     write text trace file data
PERFORM APPEND_XML_TO_BUFFER USING CURR_LINE.
ENDIF.

IF G_WAS_FILE_CREATED IS INITIAL.
G_WAS_FILE_CREATED = 'X'.
ENDIF.

ADD 1 TO L_NO_OF_READS.

*   Close temp file
CLOSE DATASET TEMP_XML_FILENAME.
*   End of wp file
IF LV_EOF_SUBRC <> 0.
EXIT.
ENDIF.
ENDDO.

* Write log:
MSG = L_NO_OF_READS.
CONCATENATE 'Total number of read execution from file'
P_FILENAME ':' MSG 'added to file in server:'
TEMP_XML_FILENAME
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

* Close wp file
CLOSE DATASET P_FILENAME.

MSG = P_FILENAME.
PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'READ TRACE FILE DATA' MSG
'End read trace file data'.
CLEAR : MSG.
ENDFORM.
*---------------------------------------------------------------------*
*       FORM check_read_also_old_trace                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_READ_ALSO_OLD_TRACE                                         *
*---------------------------------------------------------------------*
FORM CHECK_READ_ALSO_OLD_TRACE CHANGING P_READ_ALSO_OLD_TRACE TYPE C.

DATA: OLD_TRACE_CHANGED TYPE C,
L_CURR_OLD_TRACE_SIZE(8) TYPE N,
L_CURR_OLD_TRACE_TIME(6) TYPE N,
L_OLD_TRACE_FILENAME LIKE RSMRGSTR-NAME,
MSG TYPE STRING.

CLEAR P_READ_ALSO_OLD_TRACE.

PERFORM GET_OLD_TRACE_FILENAME CHANGING L_OLD_TRACE_FILENAME.

* Check if there is an .old trace at end of recording
PERFORM READ_TRACE_INFO USING L_OLD_TRACE_FILENAME
CHANGING L_CURR_OLD_TRACE_SIZE
L_CURR_OLD_TRACE_TIME.

* .old trace is different between start & end of recording
* (it was either created or changed during recording)
IF L_CURR_OLD_TRACE_SIZE <> G_OLD_TRACE_SIZE OR
L_CURR_OLD_TRACE_TIME <> G_OLD_TRACE_TIME.
P_READ_ALSO_OLD_TRACE = 'X'.
ENDIF.

* Print result to log
CONCATENATE 'Start .old trace: size=' G_OLD_TRACE_SIZE
', time=' G_OLD_TRACE_TIME
'. end .old trace: size=' L_CURR_OLD_TRACE_SIZE
', time=' L_CURR_OLD_TRACE_TIME
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
IF P_READ_ALSO_OLD_TRACE = 'X'.
PERFORM ADD_TO_LOG USING 'Decided to read also .old trace file'
GC_LOG_WRITE.
ELSE.
PERFORM ADD_TO_LOG USING 'Decided not to read also .old trace file'
GC_LOG_WRITE.
ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
*       FORM build_xml_header
*---------------------------------------------------------------------*
FORM BUILD_XML_HEADER.

DATA:
L_SIMPLE_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_ELEM TYPE REF TO IF_IXML_ELEMENT,
L_RESULT  TYPE I,
L_NAME  TYPE STRING,
L_CODE_VERSION(20)  TYPE C,
L_DATE_FORMAT LIKE USR01-DATFM,
L_STRING TYPE STRING,
L_ENCODING TYPE STRING,
LT_EMPTY_TAB TYPE STRING_TAB.

* Get the encoding
PERFORM GET_CURRENT_ENCODING CHANGING L_ENCODING.

* Add the XML definitions
CONCATENATE '<?xml version="1.0" encoding="'
L_ENCODING
'"?>'
INTO L_STRING.
PERFORM APPEND_XML_TO_BUFFER USING L_STRING.
CLEAR L_STRING.

L_STRING = '<ROOT '.

* Username
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'User' SY-UNAME
CHANGING L_STRING.

* Current date and time
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'Date' SY-DATUM
CHANGING L_STRING.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'Time' SY-UZEIT
CHANGING L_STRING.

* Date format
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'UserDateFormat'
DATE_FORMAT
CHANGING L_STRING.

* Decimal format
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'UserDecimalFormat'
DECIMAL_FORMAT
CHANGING L_STRING.

* Application server
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'ApplicationServer'
SY-HOST
CHANGING L_STRING.

* System name
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'SystemName' SY-SYSID
CHANGING L_STRING.

* Client
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'Client' SY-MANDT
CHANGING L_STRING.

* Scenario name
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'ScenarioName' P_SCENAR
CHANGING L_STRING.

* Scenario Description
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'ScenarioDesc' P_DESC
CHANGING L_STRING.

* Sap version
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'SAPVersion' SY-SAPRL
CHANGING L_STRING.

* Scenario Recorder version
CONCATENATE GENERAL_PART_VER REL_SPECIFIC_VER
INTO L_CODE_VERSION SEPARATED BY '.'.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'RecorderVersion'
L_CODE_VERSION
CHANGING L_STRING.

PERFORM GET_SYSTEM_VERSION CHANGING LT_EMPTY_TAB.

* Patches data - filled only in ECC6
IF NOT GV_SAP_APPL IS INITIAL.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'SAP_APPL'
GV_SAP_APPL
CHANGING L_STRING.
ENDIF.

IF NOT GV_SAP_HR IS INITIAL.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'SAP_HR'
GV_SAP_HR
CHANGING L_STRING.
ENDIF.

IF NOT GV_EA_HR IS INITIAL.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'EA_HR'
GV_EA_HR
CHANGING L_STRING.
ENDIF.
CONCATENATE L_STRING '>' INTO L_STRING.

* Add the string to file
PERFORM APPEND_XML_TO_BUFFER USING L_STRING.

ENDFORM.                          " xml_header

*---------------------------------------------------------------------*
*       FORM APPEND_ATTRIBUTE_TO_XML_TAG                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_ATT_NAME                                                    *
*  -->  P_ATT_VAL                                                     *
*  -->  P_STRING                                                      *
*---------------------------------------------------------------------*
FORM APPEND_ATTRIBUTE_TO_XML_TAG USING P_ATT_NAME P_ATT_VAL
CHANGING P_STRING.

DATA: L_ATT_VAL TYPE STRING.

L_ATT_VAL = P_ATT_VAL.

PERFORM REPLACE_WITH_SPACE USING '&' '#$$cafe#$$babe#'
CHANGING L_ATT_VAL.
PERFORM REPLACE_WITH_SPACE USING '#$$cafe#$$babe#' '&amp;'
CHANGING L_ATT_VAL.

PERFORM REPLACE_WITH_SPACE USING '<' '&lt;'
CHANGING L_ATT_VAL.

PERFORM REPLACE_WITH_SPACE USING '>' '&gt;'
CHANGING L_ATT_VAL.

PERFORM REPLACE_WITH_SPACE USING '''' '&apos;'
CHANGING L_ATT_VAL.

PERFORM REPLACE_WITH_SPACE USING '"' '&quot;'
CHANGING L_ATT_VAL.

CONCATENATE P_STRING P_ATT_NAME INTO P_STRING SEPARATED BY SPACE.
CONCATENATE P_STRING '="' L_ATT_VAL '"' INTO P_STRING.

ENDFORM.

*&---------------------------------------------------------------------
*&      Form  GET_FILENAME_FROM_PATH
*&---------------------------------------------------------------------
FORM GET_FILENAME_FROM_PATH USING FILEPATH TYPE STRING
CHANGING FILENAME TYPE STRING.
DATA: PATH_TAB TYPE TABLE OF STRING,
PATH_LENGTH TYPE I.

* Get the filename from filepath
SPLIT FILEPATH AT '\' INTO TABLE PATH_TAB.

* In windows the file separator should be always \,
* but in any case try also the other one
IF PATH_TAB[] IS INITIAL.
SPLIT FILEPATH AT '/' INTO TABLE PATH_TAB.
ENDIF.

DESCRIBE TABLE PATH_TAB LINES PATH_LENGTH.

READ TABLE PATH_TAB INDEX PATH_LENGTH INTO FILENAME.

ENDFORM.                    " GET_FILENAME_FROM_PATH

*&---------------------------------------------------------------------*
*&      Form  th_get_trace_setting
*&---------------------------------------------------------------------*
FORM TH_GET_TRACE_SETTING USING WP_NO TYPE I
CHANGING  TRC TYPE THFB_TRACE.

CONSTANTS:
OPCODE_WP_TRCINFO LIKE TH_OPCODE VALUE 11.

DATA: ACT LIKE TH_TRCCOMPS,
MOD LIKE TH_TRCCOMPS,
ACT_TRC(2),
MOD_TRC(2),
WP_INDEX LIKE WPINFO-WP_INDEX,
WPTYPE LIKE SM04DIC-WP_TYPE.

CALL 'ThWpInfo' ID 'OPCODE'    FIELD OPCODE_WP_TRCINFO
ID 'WP_INDEX'  FIELD WP_NO
ID 'ACTCOMPS'  FIELD ACT
ID 'MODCOMPS'  FIELD MOD
ID 'ACTLEVEL'  FIELD ACT_TRC
ID 'MODLEVEL'  FIELD MOD_TRC.

IF SY-SUBRC <> 0.
PERFORM SHOW_ERROR USING 'Error while retrieving trace '
'settings. Error code: ' SY-SUBRC ' '.
ENDIF.

IF MOD <> SPACE.
ACT = MOD.
ACT_TRC = MOD_TRC.
ENDIF.

IF NOT ACT_TRC(1) CO '0123'. ACT_TRC = '0'. ENDIF.

CLEAR TRC.
TRC-ID     = CURR_WP_NO.
TRC-LEVEL  = ACT_TRC.
TRC-WPTYPE = WPTYPE.

IF ACT(3) = 'all'.
IF ACT+4 CS 'D'. TRC-DIAG  = 'X'. ENDIF.
ELSE.
TRC-DIAG  = 'X'.
IF ACT+4 CS 'D'. TRC-DIAG  = ' '. ENDIF.
ENDIF.

ENDFORM.                    " th_get_trace_setting

*&---------------------------------------------------------------------*
*&      Form  th_set_wp_trace
*&---------------------------------------------------------------------*
FORM TH_SET_WP_TRACE.

CONSTANTS:
OPCODE_WP_TRCSWITCH LIKE TH_OPCODE VALUE 10.
DATA : MSG TYPE STRING,
LV_SUBRC TYPE STRING.

CALL 'ThWpInfo' ID 'OPCODE'   FIELD OPCODE_WP_TRCSWITCH
ID 'WP_INDEX' FIELD CURR_WP_NO
ID 'COMPS'    FIELD 'all, D'
ID 'LEVEL'    FIELD '2'.

IF NOT SY-SUBRC IS INITIAL.
LV_SUBRC = SY-SUBRC.
CONCATENATE : 'Error while setting the trace.'
'RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH 'Error while setting the trace. '
' Error code: ' LV_SUBRC.
ENDIF.

ENDFORM.                    " th_set_wp_trace
*&---------------------------------------------------------------------*
*&      Form  th_reset_wp_trace
*&---------------------------------------------------------------------*
FORM TH_RESET_WP_TRACE USING VALUE(WP_NO) TYPE I.

CONSTANTS:
OPCODE_WP_TRCSWITCH LIKE TH_OPCODE VALUE 10.
DATA: MSG TYPE STRING,
LV_SUBRC TYPE STRING.

MSG = WP_NO.
CONCATENATE 'Resetting trace for work process:' MSG
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CALL 'ThWpInfo' ID 'OPCODE'   FIELD OPCODE_WP_TRCSWITCH
ID 'WP_INDEX' FIELD WP_NO
ID 'COMPS'    FIELD 'all, D'
ID 'LEVEL'    FIELD '1'.

IF NOT SY-SUBRC IS INITIAL.
CLEAR: MSG.
LV_SUBRC = SY-SUBRC .
CONCATENATE : 'Error while resetting the trace.'
'RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.
ENDIF.

ENDFORM.                    " th_reset_wp_trace
*&---------------------------------------------------------------------*
*&      Form  delete_trace_files
*&---------------------------------------------------------------------*
FORM DELETE_TRACE_FILES.

DATA: WP_LIST TYPE TABLE OF WPINFO WITH HEADER LINE,
WP_ID TYPE I,
CURR_TRACE TYPE THFB_TRACE,
FOUND_WP_WITH_TRACE,
MSG TYPE STRING,
LV_SUBRC TYPE STRING.

* Check that there is no other active session, and only so - delete
* all files. The reason that we do not just delete is that the deletion
* is for all trace files and we want to enable parallel working
CALL FUNCTION 'TH_GET_WPINFO'
TABLES
WPLIST = WP_LIST.

IF SY-SUBRC IS INITIAL.
CLEAR FOUND_WP_WITH_TRACE.

*   Go over all Dialog processes and check if trace is enabled
*   for any of them
LOOP AT WP_LIST WHERE WP_TYP = 'DIA'.
PERFORM TH_GET_TRACE_SETTING USING WP_LIST-WP_INDEX
CHANGING CURR_TRACE.

IF ( CURR_TRACE-LEVEL = '2' OR CURR_TRACE-LEVEL = '3' )
AND CURR_TRACE-DIAG = 'X'.
FOUND_WP_WITH_TRACE = 'X'.
EXIT.
ENDIF.
ENDLOOP.

*   If no trace was enabled for any work process, delete the trace files
IF FOUND_WP_WITH_TRACE IS INITIAL.
CONCATENATE 'Deleting all trace files (dev_w*) since no other wp'
'with enabled trace was found' INTO MSG
SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CALL FUNCTION 'TH_RESET_TRACE'.
IF SY-SUBRC <> 0.
CLEAR: MSG.
LV_SUBRC = SY-SUBRC .
CONCATENATE : 'Error while resetting the trace.'
'RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.
ENDIF.
ENDIF.
ELSE.
CLEAR: MSG.
LV_SUBRC = SY-SUBRC .
CONCATENATE : 'Error while getting list of WP'
'RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH 'Error while getting list of WP'
'Error code: ' LV_SUBRC.
ENDIF.
ENDFORM.                    " delete_trace_files

*&---------------------------------------------------------------------*
*&      Form  TH_LOCK_WP
*&---------------------------------------------------------------------*
FORM TH_LOCK_WP.

DATA:
OPCODE TYPE X,
STATE TYPE I,
WP TYPE I,
STAMP(14),
MSG TYPE STRING,
LV_SUBRC TYPE STRING.

* Write Log
MSG = CURR_WP_NO.
CONCATENATE 'Locking work process: ' MSG INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

OPCODE = 26.
CALL 'ThUsrInfo' ID 'OPCODE'     FIELD OPCODE
ID 'LOCK_STATE' FIELD STATE
ID 'WP_ID'      FIELD CURR_WP_NO
ID 'STAMP'      FIELD STAMP.

IF STATE = 0.
CLEAR: MSG.
LV_SUBRC = SY-SUBRC .
CONCATENATE : 'Error while locking work process. RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH
'Error while locking work process. Error code : '
LV_SUBRC.
ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  TH_UNLOCK_WP
*&---------------------------------------------------------------------*
FORM TH_UNLOCK_WP USING VALUE(WP_NO) TYPE I.

DATA:
OPCODE TYPE X,
STATE TYPE I,
WP TYPE I,
STAMP(14),
MSG TYPE STRING,
LV_SUBRC TYPE STRING.

* Write Log
MSG = WP_NO.
CONCATENATE 'Unlocking work process: ' MSG INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

OPCODE = 27.
CALL 'ThUsrInfo' ID 'OPCODE'     FIELD OPCODE
ID 'LOCK_STATE' FIELD STATE
ID 'WP_ID'      FIELD WP_NO
ID 'STAMP'      FIELD STAMP.

IF STATE = 1.
CLEAR: MSG.
LV_SUBRC = SY-SUBRC .
CONCATENATE :'Error while unlocking work process. RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH
'Error while unlocking work process. Error code : '
LV_SUBRC.
ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  TH_DELETE_MODE
*&---------------------------------------------------------------------*
FORM TH_DELETE_MODE USING VALUE(WP_NO) TYPE I.

DATA:
OPCODE TYPE X,
MSG TYPE STRING,
LV_SUBRC TYPE STRING.

* Write Log
MSG = WP_NO.
CONCATENATE 'Deleting work process:' MSG INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

OPCODE = 05.
CALL 'ThWpInfo' ID 'OPCODE'     FIELD OPCODE
ID 'WP_INDEX'      FIELD WP_NO.

IF SY-SUBRC <> 0.
CLEAR: MSG.
LV_SUBRC = SY-SUBRC .
CONCATENATE :'Error while deleting mode. RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.
ENDIF.
ENDFORM.
*---------------------------------------------------------------------*
*       FORM READ_TRACE_INFO                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_FILENAME                                                    *
*  -->  P_TRACE_SIZE                                                  *
*  -->  P_TRACE_TIME                                                  *
*---------------------------------------------------------------------*
FORM READ_TRACE_INFO USING P_FILENAME TYPE RSMRGSTR-NAME
CHANGING P_TRACE_SIZE TYPE RSFILLST-LEN
P_TRACE_TIME TYPE RSFILLST-MTIME.

DATA: DIRNAME TYPE EPSDIRNAM,
FILENAME TYPE EPSFILNAM,
SIZE TYPE EPSFILSIZ,
WORKDIR(120),
MSG TYPE STRING,
WP TYPE STRING,
RC(2) TYPE C.

* Reset previous file attributes
CLEAR : P_TRACE_SIZE ,
P_TRACE_TIME.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'READ TRACE FILE INFO'
'EPS_GET_FILE_ATTRIBUTES'
'Start read trace file info'.

PERFORM GET_SAP_WORKDIR_ON_SERVER CHANGING WORKDIR.

DIRNAME = WORKDIR.
FILENAME = P_FILENAME.

* Get current work procces file attributes values
CALL FUNCTION 'EPS_GET_FILE_ATTRIBUTES'
EXPORTING
FILE_NAME                    = FILENAME
DIR_NAME                     = DIRNAME
IMPORTING
FILE_SIZE                    = SIZE
*     FILE_OWNER                   =
*     FILE_MODE                    =
*     FILE_TYPE                    =
FILE_MTIME                   = P_TRACE_TIME
EXCEPTIONS
READ_DIRECTORY_FAILED        = 1
READ_ATTRIBUTES_FAILED       = 2
OTHERS                       = 3.

IF SY-SUBRC <> 0.
RC = SY-SUBRC.
CONCATENATE 'Problem reading list of files in' DIRNAME
'.subrc=' RC '. assuming file is missing:' P_FILENAME
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ELSE.
P_TRACE_SIZE = SIZE.
CONCATENATE 'Found trace:' P_FILENAME ', size:' P_TRACE_SIZE
', time:' P_TRACE_TIME INTO MSG
SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'READ TRACE FILE INFO'
'EPS_GET_FILE_ATTRIBUTES'
'Start read trace file info'.

ENDFORM.

*---------------------------------------------------------------------*
*       FORM GET_OLD_TRACE_FILENAME                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_FILENAME                                                    *
*---------------------------------------------------------------------*
FORM GET_OLD_TRACE_FILENAME CHANGING P_FILENAME.

DATA: WP TYPE STRING.

CLEAR P_FILENAME.

WP = CURR_WP_NO.
CONCATENATE 'dev_w' WP '.old' INTO P_FILENAME.
CONDENSE P_FILENAME NO-GAPS.

ENDFORM.

*---------------------------------------------------------------------*
*       FORM GET_TRACE_FILENAME                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_FILENAME                                                    *
*---------------------------------------------------------------------*
FORM GET_TRACE_FILENAME CHANGING P_FILENAME.

DATA: WP TYPE STRING.

CLEAR P_FILENAME.

WP = CURR_WP_NO.
CONCATENATE 'dev_w' WP INTO P_FILENAME.
CONDENSE P_FILENAME NO-GAPS.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  calc_relevant_pos_in_trace
*&---------------------------------------------------------------------*
FORM CALC_RELEVANT_POS_IN_TRACE.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'CALCULATE TRACE FILE POSITION' ''
'start of read first line of current work process file'.

* Get the length of the file BEFORE the recording started and update
* the relevant position of the trace file
DATA: FULL_TRACE_FILE TYPE STRING_TAB,
TRACE_POS TYPE I.

* Read the trace file from the relevant location
PERFORM GET_TRACE_SIZE CHANGING TRACE_POS.

* Calculate first position after the exsiting file
G_FIRST_REL_POS = TRACE_POS + 1.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'CALCULATE TRACE FILE POSITION' ''
'end of read first line in work process'.
ENDFORM.                    " calc_relevant_pos_in_trace

*&---------------------------------------------------------------------*
*&      Form  show_error
*&---------------------------------------------------------------------*
FORM SHOW_ERROR USING VALUE(MSG_TEXT1) VALUE(MSG_TEXT2)
VALUE(MSG_TEXT3) VALUE(MSG_TEXT4).
DATA: MSG TYPE STRING.
PERFORM RESTORE_GLOBAL_PARAMS.
PERFORM RESET_DIAG_TRACE USING CURR_WP_NO.
MESSAGE E001(00) WITH MSG_TEXT1 MSG_TEXT2 MSG_TEXT3 MSG_TEXT4.
CONCATENATE  MSG_TEXT1 MSG_TEXT2 MSG_TEXT3 MSG_TEXT4
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  release_locked_wps
*&---------------------------------------------------------------------*
FORM RELEASE_LOCKED_WPS.

DATA: WP_LIST        TYPE TABLE OF WPINFO WITH HEADER LINE,
WP_ID          TYPE I,
CURR_TRACE     TYPE THFB_TRACE,
TIME_TYPE_N(6) TYPE N,
ANSWER(1)      TYPE C,
QUESTION       TYPE STRING,
MSG            TYPE STRING,
LV_SUBRC       TYPE STRING,
LV_WPS_NUM       TYPE I,
LV_LOCKED_WPS(3) TYPE N,
LV_DIALOG_WPS(3) TYPE N,
LV_TRACE2_WPS(3) TYPE N.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'RESET LOCKED WPS' ''
'Start of reset wps get wps and release the wps'.

* Check that there are no Dialog Work processes that are locked for
* more than a certain amount of time. This shoudl prevent a situation
* when a Dump occured in the middle of a recording but te WP remained
* locked and with enabled log.
CALL FUNCTION 'TH_GET_WPINFO'
TABLES
WPLIST = WP_LIST.

IF SY-SUBRC IS INITIAL.

DESCRIBE TABLE WP_LIST LINES LV_WPS_NUM.

MSG = LV_WPS_NUM.
CONCATENATE 'Number of work processs:'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

*   Go over all Dialog processes and check if trace is enabled
*   for them and the process is locked for more than the maximum
*   time
LOOP AT WP_LIST.
IF WP_LIST-WP_TYP = 'DIA'.
LV_DIALOG_WPS = LV_DIALOG_WPS + 1.
PERFORM TH_GET_TRACE_SETTING USING WP_LIST-WP_INDEX
CHANGING CURR_TRACE.

TIME_TYPE_N = WP_LIST-WP_ELTIME.

IF CURR_TRACE-LEVEL = '2'
AND CURR_TRACE-DIAG = 'X'.

LV_TRACE2_WPS = LV_TRACE2_WPS + 1.

IF WP_LIST-WP_WAITING = 'LOCK'.
LV_LOCKED_WPS = LV_LOCKED_WPS + 1.

*           Release locked wp
IF TIME_TYPE_N >= MAX_TIME_FOR_LOCKED_WP.
*             write log
CLEAR : MSG.
MSG = WP_LIST-WP_INDEX.
CONCATENATE 'Releasing locked work process:'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

*             Delete the session ( since unlocknig for different
*             session is not possible )
PERFORM TH_DELETE_MODE USING WP_LIST-WP_INDEX.

*             Return the Diag trace to level 1
PERFORM TH_RESET_WP_TRACE USING WP_LIST-WP_INDEX.
ENDIF.
ENDIF.
ENDIF.
ENDIF.
PERFORM WRITE_WP_TO_LOG USING WP_LIST.
ENDLOOP.

CLEAR : MSG.
MSG = LV_DIALOG_WPS.
CONCATENATE 'Number of dialog wps:'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CLEAR : MSG.
MSG = LV_TRACE2_WPS.
CONCATENATE 'Number of dialog wps with trace level 2:'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CLEAR : MSG.
MSG = LV_LOCKED_WPS.
CONCATENATE 'Number of locked dialog wps with trace level 2'
'(before process lock):'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ELSE.
CLEAR: MSG.
LV_SUBRC = SY-SUBRC .
CONCATENATE :'Error while getting list of WP. RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH 'Error while getting list of WP'
'Error code: ' LV_SUBRC.
ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'RESET LOCKED WPS' ''
'End of reset work processes'.

ENDFORM.                    " release_locked_wps
*&---------------------------------------------------------------------*
*&      Form  replace_with_space
*&---------------------------------------------------------------------*
FORM REPLACE_WITH_SPACE USING PATTERN
SUBSTITUTE
CHANGING TEXT.

DO.
REPLACE PATTERN WITH SUBSTITUTE INTO TEXT.
IF SY-SUBRC <> 0. EXIT. ENDIF.
ENDDO.


ENDFORM.                    " replace_with_space
*---------------------------------------------------------------------*
*       FORM CHECK_WAN_FLAG                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM CHECK_WAN_FLAG
USING
IV_FROM_INIT TYPE FLAG
CHANGING CT_CLIENT_DATA_ITAB TYPE STRING_TAB.

DATA: WAN_FLAG TYPE  AS4FLAG,
FIRST_LINE TYPE STRING,
THIRD_LINE TYPE STRING,
FORTH_LINE TYPE STRING,
CLIENT_DATA_LINE TYPE STRING_REC.

CALL FUNCTION 'SAPGUI_GET_WAN_FLAG'
IMPORTING
WAN_FLAG = WAN_FLAG.

IF NOT WAN_FLAG IS INITIAL.
*   User front end message at initialization
IF IV_FROM_INIT <> ABAP_FALSE.
CONCATENATE ICON_MESSAGE_ERROR
'''Low-Speed Connection'' flag is turned on in your SAP logon.'
INTO FIRST_LINE SEPARATED BY SPACE.

*      CONCATENATE
*      'Turn off the flag by right clicking on the system name'
*      '(in SAP logon)'
*      INTO THIRD_LINE SEPARATED BY SPACE.
*
*      FORTH_LINE =
*      '-> Properties -> Advanced -> uncheck ''Low-Speed Connection'''.

CONCATENATE
'For more information please refer to'
'''Test scenario recorder guide'', located in:'
INTO THIRD_LINE SEPARATED BY SPACE.

CONCATENATE
'https://my.panaya.com/help/guides/'
'TestScenarioRecorderSetupGuide.pdf'
INTO FORTH_LINE.

*     Show the message
CALL FUNCTION 'POPUP_TO_INFORM'
EXPORTING
TITEL         = 'Inform on low speed connection flag'
TXT1          = FIRST_LINE
TXT2          =
'This flag must be turned off, for the recorder to run properly.'
TXT3          = THIRD_LINE
TXT4          = FORTH_LINE.

LEAVE PROGRAM.
ELSE.
*     SE38 validation checks mode
CONCATENATE 'Low-Speed Connection'
' flag is turned on in your SAP logon'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  clear_params
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IT_PARAMS_VALUES  text
*----------------------------------------------------------------------*
FORM CLEAR_GLOBAL_PARAMS.

DATA: IS_PARAM_VALUE TYPE PARAM_VALUE.
DATA: IT_PARAMS TYPE TABLE OF TPARA WITH HEADER LINE,
MSG TYPE STRING.

PERFORM ADD_TO_LOG USING
'Start clearing global parameters' GC_LOG_WRITE.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'CLEAR USER GLOBAL PARAMS' ''
'start of clear user parameters (executed only if p_mode is empty)'.

* Get the parameter ids
SELECT * FROM TPARA INTO TABLE IT_PARAMS.
* Save the parameters' values and clear them.
LOOP AT IT_PARAMS.
CLEAR IS_PARAM_VALUE.
GET PARAMETER ID IT_PARAMS-PARAMID FIELD IS_PARAM_VALUE-VALUE.

IF SY-SUBRC IS INITIAL
AND NOT IT_PARAMS-PARAMID = 'GR0'
AND NOT IT_PARAMS-PARAMID = 'AVW'
AND NOT IT_PARAMS-PARAMID = 'UGR'
AND NOT IT_PARAMS-PARAMID = 'MOL'
AND NOT IT_PARAMS-PARAMID = 'RUN'
AND NOT IT_PARAMS-PARAMID = 'PRJ'
AND NOT IT_PARAMS-PARAMID = 'KPO'
AND NOT IT_PARAMS-PARAMID = 'KNR'
AND NOT IT_PARAMS-PARAMID = 'EFB'
AND NOT IT_PARAMS-PARAMID = 'EVO'
AND NOT IT_PARAMS-PARAMID CP 'GUI*'
*       Don't clear parameters that are flags (like FOP and FO2)
AND IS_PARAM_VALUE-VALUE CN 'X '
AND ( NOT ( IT_PARAMS-PARAMID = 'ENJ_CALL_ME23N'
AND CALLED_EXTERNALLY_START = 'X' ) )
AND ( NOT ( IT_PARAMS-PARAMID = 'ENJ_CALL_ME53N'
AND CALLED_EXTERNALLY_START = 'X' ) )
.

CONCATENATE IT_PARAMS-PARAMID '=' IS_PARAM_VALUE-VALUE INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

SET PARAMETER ID IT_PARAMS-PARAMID FIELD SPACE.
*      Save the cleared value to restore it later after the recording
IS_PARAM_VALUE-ID = IT_PARAMS-PARAMID.
APPEND IS_PARAM_VALUE TO G_IT_PARAMS_VALUES.

ELSE.
*      If 'ENJ_CALL_ME53N' and 'ENJ_CALL_ME23N' didn't exist,
*      add them with space
IF ( IT_PARAMS-PARAMID = 'ENJ_CALL_ME53N' OR
IT_PARAMS-PARAMID = 'ENJ_CALL_ME23N' )
AND CALLED_EXTERNALLY_START = ''.

CONCATENATE IT_PARAMS-PARAMID '=' IS_PARAM_VALUE-VALUE INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

SET PARAMETER ID IT_PARAMS-PARAMID FIELD SPACE.
IS_PARAM_VALUE-ID = IT_PARAMS-PARAMID.

*          In case of ENJ_CALL_ME53N the default behavior is when
*          it is set to 'X'. In ENJ_CALL_ME23N - it is space so
*          we don't need to save its value in G_IT_PARAMS_VALUES,
*          because it will stay space.
IF ( IT_PARAMS-PARAMID = 'ENJ_CALL_ME53N' ).
IS_PARAM_VALUE-VALUE = 'X'.
APPEND IS_PARAM_VALUE TO G_IT_PARAMS_VALUES.
ENDIF.

ENDIF.

ENDIF.

ENDLOOP.

* The F4 screens are recorded in the trace file only if they are not
* ActiveX screens.
SET PARAMETER ID 'F4METHOD' FIELD 'NoActiveX'.

PERFORM ADD_TO_LOG USING 'End clearing global parameters'
GC_LOG_WRITE.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'CLEAR USER GLOBAL PARAMS' ''
'end of clear user parameters empty p_mode'.

ENDFORM.                    " clear_params
*&---------------------------------------------------------------------*
*&      Form  restore_params
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IT_PARAMS_VALUES  text
*----------------------------------------------------------------------*
FORM RESTORE_GLOBAL_PARAMS.

DATA: IS_PARAM_VALUE TYPE PARAM_VALUE.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'RESTORE USER GLOBAL PARAMS' ''
'start of restore user parameters'.

LOOP AT G_IT_PARAMS_VALUES INTO IS_PARAM_VALUE.
PERFORM SET_PARAMETER USING IS_PARAM_VALUE.
ENDLOOP.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'RESTORE USER GLOBAL PARAMS' ''
'end of restore user parameters'.

CLEAR G_IT_PARAMS_VALUES[].
ENDFORM.                    " restore_params
*&---------------------------------------------------------------------*
*&      Form  ADD_TIME_STAT_TO_XML
*&---------------------------------------------------------------------*
FORM ADD_TIME_STAT_TO_XML USING STARTIME LIKE SY-UZEIT.

DATA: R_TIME_STAT LIKE LINE OF GT_TIME_STAT,
L_STRING TYPE STRING.

PERFORM ADD_TIME_STAT USING 'All recording' STARTIME.

PERFORM APPEND_XML_TO_BUFFER USING '<TIME_STATS>'.

LOOP AT GT_TIME_STAT INTO R_TIME_STAT.
L_STRING = '  <TIME_STAT '.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'STEP'
R_TIME_STAT-STEP
CHANGING L_STRING.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'STARTDATE'
R_TIME_STAT-STARTDATE
CHANGING L_STRING.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'STARTTIME'
R_TIME_STAT-STARTTIME
CHANGING L_STRING.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'ENDDATE'
R_TIME_STAT-ENDDATE
CHANGING L_STRING.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'ENDTIME'
R_TIME_STAT-ENDTIME
CHANGING L_STRING.

CONCATENATE L_STRING '/>' INTO L_STRING.

PERFORM APPEND_XML_TO_BUFFER USING L_STRING.
ENDLOOP.

PERFORM APPEND_XML_TO_BUFFER USING '</TIME_STATS>'.

ENDFORM.                    " ADD_TIME_STAT_TO_XML

*&---------------------------------------------------------------------*
*&      Form  set_filename
*&---------------------------------------------------------------------*
FORM SET_FILENAME.

DATA: WORKDIR(120),
PLATFORM TYPE STRING,
SCEN_NAME_TRUNC(20) TYPE C,
SCEN_NAME_TRUNC_STR TYPE STRING,
TEMP_STR TYPE STRING,
CURR_IDX TYPE I,
TOTAL_STR_LENGTH TYPE I,
CURR_CHAR,
PREV_CHAR,
SERVER_WORKDIR_LEN TYPE I,
LOCAL_WORKDIR_LEN TYPE I,
MAX_WORKDIR_LEN TYPE I,
MAX_SCEN_LEN TYPE I,
TEMP_STR_LEN TYPE I.

* The filename is fixed so it will be replaced with each recording.
* We don't need it after it is being sent to Panaya

* Sap workdir wasn't set at initialization set C as default
IF SAP_WORK_DIR IS INITIAL.
SAP_WORK_DIR = 'C:'.
ENDIF.

* Get sapworkdir on server ( for writing the xml file )
PERFORM GET_SAP_WORKDIR_ON_SERVER_SEP CHANGING WORKDIR.

* Get the first 20 chars of the scenario name OR the maximum
* possible given the user sapworkdir length
* Then - leave only the alpha numeric fields of the name.
* If no alpha numeric fields were found - fallback to the last
* transaction

* Leave only first 20 chars
SCEN_NAME_TRUNC = P_SCENAR.

* Put into string - to remove all the last spaces
SCEN_NAME_TRUNC_STR = P_SCENAR.

* Change the spaces within the name to _
TRANSLATE SCEN_NAME_TRUNC_STR USING ' _'.

* No go over the string and remove all cahracters that are
* not alphanumeric
TOTAL_STR_LENGTH = STRLEN( SCEN_NAME_TRUNC_STR ).
CURR_IDX = 0.
CLEAR TEMP_STR.
WHILE CURR_IDX < TOTAL_STR_LENGTH.
CURR_CHAR = SCEN_NAME_TRUNC_STR+CURR_IDX(1).
IF CURR_CHAR CO VALID_CHARS.

*     Don't add two subsiding underlines (_)
IF PREV_CHAR <> '_' OR CURR_CHAR <> '_'.
CONCATENATE TEMP_STR CURR_CHAR INTO TEMP_STR.
PREV_CHAR = CURR_CHAR.
ENDIF.

ENDIF.
ADD 1 TO CURR_IDX.
ENDWHILE.

* If no characters are left - fallback to transaction name
IF TEMP_STR IS INITIAL OR TEMP_STR CO '_'.
TEMP_STR = P_TCODE.
ENDIF.

* Calucalte the length possible by given ( local or server, depends
* on which one is longer )
* In case of Oflline we already reensured in the selection screen
* that the length is not longer than 76
SERVER_WORKDIR_LEN = STRLEN( WORKDIR ).
LOCAL_WORKDIR_LEN = STRLEN( SAP_WORK_DIR ).
IF SERVER_WORKDIR_LEN > LOCAL_WORKDIR_LEN.
MAX_WORKDIR_LEN = SERVER_WORKDIR_LEN.
ELSE.
MAX_WORKDIR_LEN = LOCAL_WORKDIR_LEN.
ENDIF.

* Maximum scenario length is 128 ( max filename length ) - 44
* (length of panaya_rec_XXX_UUUUUUUUUUUU_YYYYMMDD_HHMMSS ) - max workdir
* length
* OR 20.
MAX_SCEN_LEN = 84 - MAX_WORKDIR_LEN.
IF MAX_SCEN_LEN > 20.
MAX_SCEN_LEN = 20.
ENDIF.

TEMP_STR_LEN = STRLEN( TEMP_STR ).
IF TEMP_STR_LEN > MAX_SCEN_LEN.
TEMP_STR = TEMP_STR(MAX_SCEN_LEN).
ENDIF.

* build the filename of the temporary xml file
CONCATENATE WORKDIR 'temp_panaya_xml_' TEMP_STR '_'
SY-SYSID  '_' SY-UNAME '_' SY-DATUM '_' SY-UZEIT '.xml'
INTO TEMP_XML_FILENAME.

* build the filename of the recording
IF C_OFF IS INITIAL.
CONCATENATE SAP_WORK_DIR '\panaya_rec_' TEMP_STR '_'
SY-SYSID  '_' SY-DATUM '_' SY-UZEIT '.html'
INTO G_FILENAME.
ELSE.
CONCATENATE P_OFF '\panaya_rec_' TEMP_STR '_'
SY-SYSID  '_' SY-DATUM '_' SY-UZEIT '.html'
INTO G_FILENAME.
ENDIF.

* Set log file name
CONCATENATE G_FILENAME '.log' INTO G_LOG_FILENAME.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  build_html_header
*&---------------------------------------------------------------------*
FORM BUILD_HTML_HEADER USING IS_ZIP_SUCC.

DATA: LONG_STR TYPE STRING,
URL_STR TYPE STRING,
FLASH_STR TYPE STRING,
L_ENCODING TYPE STRING.

CLEAR G_BUFFER_ITAB[].

* Add Mark Of The Web comment (MOTW)
PERFORM APPEND_STRING_TO_BUFFER
USING '<!-- saved from url=(0014)about:internet -->' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING '<html>' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING ' <head>' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING
'  <title>Sending record to Panaya</title>' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING ' </head>' 'X' 'X'.

* Get the encoding
PERFORM GET_CURRENT_ENCODING CHANGING L_ENCODING.

* Add the HTML definitions
CONCATENATE
' <meta http-equiv="Content-Type" content="text/html; charset='
L_ENCODING
'" />'
INTO LONG_STR.
PERFORM APPEND_STRING_TO_BUFFER USING LONG_STR 'X' 'X'.
CLEAR LONG_STR.

PERFORM APPEND_STRING_TO_BUFFER USING
'<body onload="javascript:document.forms.f.submit()">' 'X' 'X'.

CONCATENATE '<iframe src ="'
URL_PREF
'/recorder/app/pages/PanayaFromRecording.html" width="'
'100%" height="90%" frameborder="0">'
INTO FLASH_STR.

PERFORM APPEND_STRING_TO_BUFFER USING FLASH_STR 'X' 'X'.

PERFORM APPEND_STRING_TO_BUFFER USING
'Sending record to Panaya...<br>' 'X' 'X'.

PERFORM APPEND_STRING_TO_BUFFER USING '</iframe>' 'X' 'X'.

PERFORM APPEND_STRING_TO_BUFFER USING '<form action="' 'X' 'X'.

CONCATENATE URL_PREF
'/site/pages/scenarioRecorder.jsf'
INTO URL_STR.

PERFORM APPEND_STRING_TO_BUFFER USING  URL_STR 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING  '" name="f" method="post" >'
'X' 'X'.

* Send the file name as a parameter
CONCATENATE '<input type="hidden" name="recordFileName" value="'
G_FILENAME '" >' INTO LONG_STR.
PERFORM APPEND_STRING_TO_BUFFER USING  LONG_STR 'X' 'X'.
CLEAR LONG_STR.

* Send the encoding as parameter
CONCATENATE '<input type="hidden" name="fileEncoding" value="'
L_ENCODING '" >' INTO LONG_STR.
PERFORM APPEND_STRING_TO_BUFFER USING  LONG_STR 'X' 'X'.
CLEAR LONG_STR.

* If zipping was sucessfull - add it as parameter. If zipping
* was sucessfully performed - it means also that BASE64 encoding
* was done
IF NOT IS_ZIP_AVAILABLE IS INITIAL AND
NOT IS_ZIP_SUCC IS INITIAL.
PERFORM APPEND_STRING_TO_BUFFER USING
'<input type="hidden" name="isZipped" value="true" >' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING
'<input type="hidden" name="isConvertedToBase64" value="true" >'
'X' 'X'.
ELSEIF NOT SHOULD_ENCODE_BASE_64_DEBUG IS INITIAL.
PERFORM APPEND_STRING_TO_BUFFER USING
'<input type="hidden" name="isConvertedToBase64" value="true" >'
'X' 'X'.
ENDIF.

CONCATENATE '<input type="text" readonly="true" style="display:none"'
' name="recordXml"'
INTO LONG_STR.
PERFORM APPEND_STRING_TO_BUFFER USING  LONG_STR 'X' 'X'.

PERFORM APPEND_STRING_TO_BUFFER USING  'value="' 'X' 'X'.

* Flush the buffer using in client asc mode
PERFORM FLUSH_BUFFER USING 'X' 'X'.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  build_html_suffix
*&---------------------------------------------------------------------*
FORM BUILD_HTML_SUFFIX.

PERFORM APPEND_STRING_TO_BUFFER USING '" width="200" height="500"/>'
'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING '<br><br>' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING '</form>' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING '</body>' 'X' 'X'.
PERFORM APPEND_STRING_TO_BUFFER USING '</html>' 'X' 'X'.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  build_xml_suffix
*&---------------------------------------------------------------------*
FORM BUILD_XML_SUFFIX.
PERFORM APPEND_XML_TO_BUFFER USING '</ROOT>'.
PERFORM FLUSH_BUFFER USING ' ' ' '.
ENDFORM.                    " build_xml_suffix

*&---------------------------------------------------------------------*
*&      Form  build_html
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_L_XML  text
*----------------------------------------------------------------------*
FORM CALL_BROWSER.

DATA: L_FILENAME(256) TYPE C.
L_FILENAME = G_FILENAME.
CALL FUNCTION 'CALL_BROWSER'
EXPORTING
URL = L_FILENAME.

ENDFORM.                    " build_html

*&---------------------------------------------------------------------*
*&      Form  DELETE_HTML
*&---------------------------------------------------------------------*
FORM DELETE_XML.

DATA: L_FILENAME LIKE RLGRAP-FILENAME,
RC TYPE I,
MSG TYPE STRING.

* Delete only if it was created
IF G_WAS_FILE_CREATED = 'X'.
L_FILENAME = G_FILENAME.

DELETE DATASET TEMP_XML_FILENAME.

IF SY-SUBRC <> 0.
RC = SY-SUBRC.
MSG = SY-SUBRC .
CONCATENATE :'Error while deleting the created. RC:'
MSG
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH 'Error while deleting the created'
' html file.' 'Error code: ' RC.
ENDIF.
ENDIF.

ENDFORM.                    " DELETE_HTML

*&---------------------------------------------------------------------*
*&      Form  INIT_RECORDING
*&---------------------------------------------------------------------*
FORM INIT_RECORDING TABLES FIELDS TYPE SVAL_TAB.

DATA: FIELD LIKE LINE OF FIELDS,
MSG TYPE STRING.

* Set filename
PERFORM SET_FILENAME.

CONCATENATE 'Filename in server: ' TEMP_XML_FILENAME INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

* Reset the SPA/GPA
PERFORM CLEAR_GLOBAL_PARAMS.

* Build XML root
PERFORM BUILD_XML_HEADER.

* Flush the buffer into the file
PERFORM FLUSH_BUFFER USING ' ' ' '.

* Release locked processes, if exist
PERFORM RELEASE_LOCKED_WPS.

* Set the trace parameters
PERFORM SET_DIAG_TRACE.

* Clear that transaction was added to file
CLEAR G_TRANS_ADDED_TO_FILE.

* Reminder of the limitions to the user, before the recording starts.
MESSAGE I001(00) WITH
'The recording is starting now.'
'                    Please remember not to'
' use the command field during the recording, and'
' not to leave the session idle for a long time.'.

ENDFORM.                    " INIT_RECORDING

*&---------------------------------------------------------------------*
*&      Form  RECORD_AND_WRITE_TRANSACTION
*&---------------------------------------------------------------------*
FORM RECORD_AND_WRITE_TRANSACTION CHANGING ANSWER.

DATA: QUESTION   TYPE STRING,
WAS_RECORDED.

ADD 1 TO G_TRANS_INDEX.
CLEAR : GT_BDCDATA[], GT_MSG[].

*   Calculate where starts the relevant trace
PERFORM CALC_RELEVANT_POS_IN_TRACE.

*   Save transaction information in memory for cases that
*   'leave transaction' terminates the recording
PERFORM SET_TRANS_INFO.

*   Record the transaction
PERFORM RECORD_TRANSACTION TABLES GT_BDCDATA GT_MSG
USING P_TCODE
CHANGING WAS_RECORDED.

*   If recording finished successfully - give this message
IF WAS_RECORDED = 'X'.
CONCATENATE 'Recording of transaction'
P_TCODE
'completed sucessfully.'
'Add another transaction to scenario?'
INTO QUESTION SEPARATED BY SPACE.

*   If failed - give this message
ELSE.
CONCATENATE 'Recording of transaction'
P_TCODE
'was terminated.'
'Add another transaction to scenario?'
INTO QUESTION SEPARATED BY SPACE.

ENDIF.

*   Check if new transaction should be added
CALL FUNCTION 'POPUP_TO_CONFIRM'
EXPORTING
TEXT_QUESTION         = QUESTION
TEXT_BUTTON_1         = 'New Transaction'
TEXT_BUTTON_2         = 'Finish'
DISPLAY_CANCEL_BUTTON = ' '
IMPORTING
ANSWER                = ANSWER.

*   Add current transaction data to xml only if transaction was recorded
IF WAS_RECORDED = 'X'.
PERFORM ADD_TRANSACTION_TO_XML
TABLES   GT_BDCDATA GT_MSG
USING    P_TCODE 'X'
CHANGING G_XML_SIZE.
ENDIF.

* Reset trace
PERFORM RESET_DIAG_TRACE USING CURR_WP_NO.

ENDFORM.                    " RECORD_AND_WRITE_TRANSACTION

*&---------------------------------------------------------------------*
*&      Form  CHOOSE_NEW_TRANSACTION
*&---------------------------------------------------------------------*
FORM CHOOSE_NEW_TRANSACTION CHANGING P_IS_TRANSACTION_CHOSEN.

DATA: ANSWER(1)  TYPE C,
FIELD  LIKE LINE OF G_FIELDS.

CLEAR P_IS_TRANSACTION_CHOSEN.

CALL FUNCTION 'POPUP_GET_VALUES_DB_CHECKED'
EXPORTING
POPUP_TITLE     = 'Choose transaction'
START_COLUMN    = '3'
IMPORTING
RETURNCODE      = ANSWER
TABLES
FIELDS          = G_FIELDS
EXCEPTIONS
ERROR_IN_FIELDS = 1
OTHERS          = 2.

IF SY-SUBRC <> 0.
PERFORM SHOW_ERROR USING 'Error while '
'choosing next transaction '
'Error code: '
SY-SUBRC.
ENDIF.

* If 'Cancel' was pressed instead of new transaction, don't
* continue with new transaction
IF ANSWER = 'A'.
EXIT.
ELSE.
*   If transaction was entered, get it
READ TABLE G_FIELDS INTO FIELD INDEX 1.
IF SY-SUBRC IS INITIAL.
P_TCODE = FIELD-VALUE.
P_IS_TRANSACTION_CHOSEN = 'X'.
ELSE.
PERFORM SHOW_ERROR USING 'Error while '
'reading the returned transaction.'
'No values were returned.'
' '.
ENDIF.

ENDIF.

ENDFORM.                    " CHOOSE_NEW_TRANSACTION

*&---------------------------------------------------------------------*
*&      Form  finish_and_show_file
*&---------------------------------------------------------------------*
FORM FINISH_AND_SHOW_FILE USING P_STARTTIME LIKE SY-UZEIT.

DATA:
FILELEN TYPE I,
FILE_PREFIX TYPE STRING,
FILE_MIDDLE TYPE STRING,
FILE_SUFFIX TYPE STRING,
FIRST_LINE TYPE STRING,
IS_ZIP_SUCC.

* Add recording timestamp
PERFORM ADD_TIME_STAT_TO_XML USING P_STARTTIME.

* Add the measurement data to xml
PERFORM ADD_MEASUREMENT_TO_XML.

* Add XML suffix
PERFORM BUILD_XML_SUFFIX.

* Zip the file and read the zipped info ( only if zip is available )
* In case of recovery mode - check GZIP was not performed in current
* session and we need to recheck it ( without showing the error,
* because it was checked in the first session )
PERFORM CHECK_GZIP USING ' '.
IF NOT IS_ZIP_AVAILABLE IS INITIAL.
PERFORM ZIP_XML CHANGING IS_ZIP_SUCC.

IF IS_ZIP_SUCC IS INITIAL.
MESSAGE I001(00) WITH
'Data compression failed (RC : ' SY-SUBRC
'). Scenario will be generated without compression.'.
ENDIF.

ENDIF.

* Add HTML prefix and HTML suffix
PERFORM BUILD_HTML_HEADER USING IS_ZIP_SUCC.

* Add the zipped info
PERFORM WRITE_XML_TO_CLIENT USING IS_ZIP_SUCC 'X'.

* Add HTML suffix
PERFORM BUILD_HTML_SUFFIX.

* Flush the buffer into the client asc mode
PERFORM FLUSH_BUFFER USING 'X' 'X'.

* Call browser ( if this it not offline mode )
IF C_OFF IS INITIAL.
PERFORM CALL_BROWSER.
ELSE.
FILELEN = STRLEN( G_FILENAME ).
IF FILELEN > 120.
FILE_PREFIX = G_FILENAME(60).
FILE_MIDDLE = G_FILENAME+60(60).
FILE_SUFFIX = G_FILENAME+120.
ELSEIF FILELEN > 60.
FILE_PREFIX = G_FILENAME(60).
FILE_MIDDLE = G_FILENAME+60.
ELSE.
FILE_PREFIX = G_FILENAME.
ENDIF.

CONCATENATE ICON_MESSAGE_INFORMATION
'Recording saved to the following file '
INTO FIRST_LINE SEPARATED BY SPACE.

CALL FUNCTION 'POPUP_TO_INFORM'
EXPORTING
TITEL = 'Recording saved'
TXT1  = FIRST_LINE
TXT2  = FILE_PREFIX
TXT3  = FILE_MIDDLE
TXT4  = FILE_SUFFIX.

ENDIF.
ENDFORM.                    " finish_and_show_file

*&---------------------------------------------------------------------*
*&      Form  read_trace_file
*&---------------------------------------------------------------------*
FORM GET_TRACE_SIZE CHANGING FILE_SIZE TYPE I.

DATA: TRACE_FILENAME(20) TYPE C,
PWP_INDEX(5) TYPE C,
FULL_TRACE_FILENAME LIKE RLGRAP-FILENAME,
CURR_LINE TYPE STRING,
CURR_LINE_LEN TYPE I,
MSG TYPE STRING,
POS_AS_N(10) TYPE N,
FILE_OPENED TYPE C.
DATA: LV_WORKDIR   LIKE EPSF-EPSDIRNAM,
WORKDIR(120),
DEVFILE(20)  TYPE C,
LV_FILENAME  LIKE EPSF-EPSFILNAM.

* Get filename
WRITE CURR_WP_NO TO PWP_INDEX LEFT-JUSTIFIED.
PERFORM GET_FILENAME USING PWP_INDEX
CHANGING FULL_TRACE_FILENAME.

CONCATENATE
'Find number of bytes in trace file (before recording):'
FULL_TRACE_FILENAME INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

* Read the file
IF ( NOT FULL_TRACE_FILENAME IS INITIAL ).

PERFORM GET_SAP_WORKDIR_ON_SERVER CHANGING WORKDIR.
PERFORM SET_WP_FILE_NAME USING  PWP_INDEX
CHANGING DEVFILE.
LV_WORKDIR = WORKDIR.
LV_FILENAME = DEVFILE.

CALL FUNCTION 'EPS_GET_FILE_ATTRIBUTES'
EXPORTING
FILE_NAME                    = LV_FILENAME
DIR_NAME                     = LV_WORKDIR
IMPORTING
FILE_SIZE                    = FILE_SIZE
*     FILE_OWNER                   =
*     FILE_MODE                    =
*     FILE_TYPE                    =
*     file_mtime                   = p_trace_time
EXCEPTIONS
READ_DIRECTORY_FAILED        = 1
READ_ATTRIBUTES_FAILED       = 2
OTHERS                       = 3.

ELSE.
PERFORM SHOW_ERROR USING
'Trace filename was not found. ' ' ' ' ' ' '.
ENDIF.

CLEAR MSG.
POS_AS_N = FILE_SIZE.
SHIFT POS_AS_N LEFT DELETING LEADING '0'.
CONCATENATE 'Number of bytes in trace file (before recording):'
POS_AS_N INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

ENDFORM.                    " read_trace_file
*&---------------------------------------------------------------------*
*&      Form  APPEND_XML_TO_BUFFER
*&---------------------------------------------------------------------*
FORM APPEND_XML_TO_BUFFER USING XML_CONTENT_STR TYPE STRING.

* Make all the needed transformations fro adding the xml string to
* buffer - only in case that zipping is not used
*  PERFORM HANDLE_XML_ESCAPING CHANGING XML_CONTENT_STR.

* Now, append the result string to buffer
PERFORM APPEND_STRING_TO_BUFFER USING XML_CONTENT_STR ' ' ' '.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  APPEND_STRING_TO_BUFFER
*&---------------------------------------------------------------------*
FORM APPEND_STRING_TO_BUFFER USING STR TYPE STRING
IN_CLIENT
P_ADD_END_OF_LINE.
DATA: NO_OF_LINES TYPE I.

* First of all check if exceeded the maximum buffer size. If yes -
* move the data from buffer to file.
DESCRIBE TABLE G_BUFFER_ITAB LINES NO_OF_LINES.

IF NO_OF_LINES = C_MAX_BUFFER_SIZE.
IF NOT IN_CLIENT IS INITIAL.
PERFORM ADD_DATA_TO_FILE_IN_CLIENT  USING
G_BUFFER_ITAB
P_ADD_END_OF_LINE
G_FILENAME
'Error while downloading file to client.'
CHANGING
G_FILE_IS_APPEND_MODE_CLIENT.


IF G_WAS_FILE_CREATED IS INITIAL.
G_WAS_FILE_CREATED = 'X'.
ENDIF.

ELSE.
PERFORM ADD_DATA_TO_FILE_IN_SERVER USING G_BUFFER_ITAB.
ENDIF.
CLEAR G_BUFFER_ITAB[].
ENDIF.

APPEND STR TO G_BUFFER_ITAB.


ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  FLUSH_BUFFER
*&---------------------------------------------------------------------*
FORM FLUSH_BUFFER USING IN_CLIENT
P_ADD_END_OF_LINE.

DATA: MSG TYPE STRING,
LIN TYPE STRING.

* Write log
DESCRIBE TABLE G_BUFFER_ITAB LINES LIN.
IF IN_CLIENT = 'X'.
MSG = '(In client).'.
CONCATENATE 'Flushing buffer to file: '
G_FILENAME '.In client:' IN_CLIENT
'.Buffer Size (lines): ' LIN MSG INTO MSG SEPARATED BY SPACE.
ELSE.
MSG = '(In server).'.
CONCATENATE 'Flushing buffer to file: '
TEMP_XML_FILENAME '.In client:' IN_CLIENT
'.Buffer Size (lines): ' LIN MSG INTO MSG SEPARATED BY SPACE.
ENDIF.

PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

IF NOT G_BUFFER_ITAB[] IS INITIAL.
IF NOT IN_CLIENT IS INITIAL.
PERFORM ADD_DATA_TO_FILE_IN_CLIENT USING
G_BUFFER_ITAB
P_ADD_END_OF_LINE
G_FILENAME
'Error while downloading file to client.'
CHANGING
G_FILE_IS_APPEND_MODE_CLIENT.

IF G_WAS_FILE_CREATED IS INITIAL.
G_WAS_FILE_CREATED = 'X'.
ENDIF.

ELSE.
PERFORM ADD_DATA_TO_FILE_IN_SERVER USING G_BUFFER_ITAB.
ENDIF.
CLEAR G_BUFFER_ITAB[].
ENDIF.
ENDFORM.                    " FLUSH_BUFFER

*&---------------------------------------------------------------------*
*&      Form  SET_TRANS_INFO
*&---------------------------------------------------------------------*
FORM SET_TRANS_INFO.

DATA: FILENAME_FULL(1024) TYPE C,
FILENAME_C1(250),
FILENAME_C2(250),
FILENAME_LENGTH TYPE I,
IS_SPLIT.

* Since filename could be more than 250 characters ( and maximum length
* of field is 250 characters ), we assume that it is not longer than
* 500 characters and split it into two fields. The third field is
* boolean - was filename split.
FILENAME_LENGTH = STRLEN( G_FILENAME ).
IF FILENAME_LENGTH >= 250.
IS_SPLIT = 'X'.
FILENAME_FULL = G_FILENAME.
CALL FUNCTION 'STRING_SPLIT_AT_POSITION'
EXPORTING
STRING            = FILENAME_FULL
POS               = 250
IMPORTING
STRING1           = FILENAME_C1
STRING2           = FILENAME_C2
EXCEPTIONS
STRING1_TOO_SMALL = 1
STRING2_TOO_SMALL = 2
POS_NOT_VALID     = 3
OTHERS            = 4.

IF SY-SUBRC <> 0.
*    If splitting failed - abort
PERFORM SHOW_ERROR USING 'Splitting filename failed. '
'Error code: '
SY-SUBRC ' '.
ENDIF.

ELSE.

CLEAR: IS_SPLIT, FILENAME_C2.
FILENAME_C1 = G_FILENAME.

ENDIF.

* PANAYA_SR1 => Was transaction recording started?
* PANAYA_SR2 => Current transaction
* PANAYA_SR3 => First line of trace of current transaction
* PANAYA_SR4 => Start time of transaction
* PANAYA_SR5 => If filename split
* PANAYA_SR6 => First part of filename in case that the filename
*               is split. If not split - this is filename.
* PANAYA_SR7 => Second part of filename in case that it is split.
* PANAYA_SR8 => Transaction index
* PANAYA_SR9 => Online/Oflline mode
* PANAYA_SR10 => Offline directory name
* PANAYA_SR11 => Temp xml filename
SET PARAMETER ID: 'PANAYA_SR1' FIELD 'X',
'PANAYA_SR2' FIELD P_TCODE,
'PANAYA_SR3' FIELD G_FIRST_REL_POS,
'PANAYA_SR4' FIELD G_STARTTIME,
'PANAYA_SR5' FIELD IS_SPLIT,
'PANAYA_SR6' FIELD FILENAME_C1,
'PANAYA_SR7' FIELD FILENAME_C2,
'PANAYA_SR8' FIELD G_TRANS_INDEX,
'PANAYA_SR9' FIELD C_OFF,
'PANAYA_SR10' FIELD P_OFF,
'PANAYA_SR11' FIELD TEMP_XML_FILENAME.

ENDFORM.                    " SET_TRANS_INFO

*&---------------------------------------------------------------------*
*&      Form  RESET_TRANS_INFO
*&---------------------------------------------------------------------*
FORM RESET_TRANS_INFO.

SET PARAMETER ID: 'PANAYA_SR1' FIELD SPACE,
'PANAYA_SR2' FIELD SPACE,
'PANAYA_SR3' FIELD SPACE,
'PANAYA_SR4' FIELD SPACE,
'PANAYA_SR5' FIELD SPACE,
'PANAYA_SR6' FIELD SPACE,
'PANAYA_SR7' FIELD SPACE,
'PANAYA_SR8' FIELD SPACE,
'PANAYA_SR9' FIELD SPACE,
'PANAYA_SR10' FIELD SPACE,
'PANAYA_SR11' FIELD SPACE.

ENDFORM.                    " RESET_TRANS_INFO

*&---------------------------------------------------------------------*
*&      Form  FINISH_PREV_RECORDING
*&---------------------------------------------------------------------*
FORM FINISH_PREV_RECORDING.

DATA: ANSWER(1)  TYPE C,
PREV_TRANS_TERMINATED,
CURR_TRACE TYPE THFB_TRACE,
SUCC LIKE SY-SUBRC,
QUESTION TYPE STRING,
TXT1 TYPE STRING,
TXT2 TYPE STRING,
TXT3 TYPE STRING,
TXT4 TYPE STRING,
PREV_TRANS LIKE P_TCODE,
PREV_FILENAME1(250),
PREV_FILENAME2(250),
IS_FILENAME_SPLIT,
IS_TRANSACTION_CHOSEN(1) TYPE C,
MSG TYPE STRING.

* Check if this is the case of recording that appears after
* previous transaction that terminated because of
* 'leave to transaction'.
* Checks 2 things:
*  1. Check parameter id
*  2. Check if current session in with trace adn locked
GET PARAMETER ID 'PANAYA_SR1' FIELD PREV_TRANS_TERMINATED.

IF NOT PREV_TRANS_TERMINATED IS INITIAL.
PERFORM ADD_TO_LOG USING
'Previous transaction was terminated'
GC_LOG_WRITE.
ENDIF.

CALL FUNCTION 'TH_GET_OWN_WP_NO'
IMPORTING
SUBRC    = SUCC
WP_INDEX = CURR_WP_NO.

IF SY-SUBRC <> 0.
CLEAR: MSG.
MSG = SY-SUBRC .
CONCATENATE :'Error fetching current Work Process. RC:'
MSG
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH
'Error fetching current Work Process. Error code:'
' '
SUCC.
ENDIF.

PERFORM TH_GET_TRACE_SETTING USING CURR_WP_NO
CHANGING CURR_TRACE.

* If yes - handle it seperately
IF NOT PREV_TRANS_TERMINATED IS INITIAL
AND CURR_TRACE-LEVEL = '2'
AND CURR_TRACE-DIAG = 'X'.

*   Get data about previous recording: previous transaction,
*   and filename
GET PARAMETER ID: 'PANAYA_SR2' FIELD PREV_TRANS,
'PANAYA_SR3' FIELD G_FIRST_REL_POS,
'PANAYA_SR4' FIELD G_STARTTIME,
'PANAYA_SR5' FIELD IS_FILENAME_SPLIT,
'PANAYA_SR6' FIELD PREV_FILENAME1,
'PANAYA_SR7' FIELD PREV_FILENAME2,
'PANAYA_SR8' FIELD G_TRANS_INDEX,
'PANAYA_SR9' FIELD C_OFF,
'PANAYA_SR10' FIELD P_OFF,
'PANAYA_SR11' FIELD TEMP_XML_FILENAME.

*   Set append to file
G_FILE_IS_APPEND_MODE_SERVER = 'X'.

*   Continue only if the reading of parameter IDs finished successfully.
IF SY-SUBRC IS INITIAL.


*     Construct the filename: if it is split, concatenate two parts
*     into filename.
IF IS_FILENAME_SPLIT = 'X'.
CONCATENATE PREV_FILENAME1 PREV_FILENAME2 INTO G_FILENAME.
ELSE.
G_FILENAME = PREV_FILENAME1.
ENDIF.

*   Set log filename
CONCATENATE G_FILENAME '.log' INTO G_LOG_FILENAME.

*     Ask the user if he wants to send the recording to Panaya or
*     Discard it or Continue the recording?
CONCATENATE 'Recording session was terminated after transaction '
PREV_TRANS 'and can be recovered. You may continue this '
'recording now and add more transactions as needed '
INTO TXT1 SEPARATED BY SPACE.
CONCATENATE TXT1 '1. ' INTO  TXT2
SEPARATED BY '                         '.
CONCATENATE TXT2
'To record more transactions press `Continue rec`.'
INTO TXT2 SEPARATED BY SPACE.
CONCATENATE TXT2 '2.' INTO TXT3
SEPARATED BY
'                                           '.
CONCATENATE TXT3
'To finish the recording press `Finish rec`. '
INTO TXT3 SEPARATED BY SPACE.
CONCATENATE TXT3 '3. ' INTO TXT4 SEPARATED BY
' '.
CONCATENATE TXT4
'To discard recording press `Cancel`. '
INTO QUESTION SEPARATED BY SPACE.

*     Check if new transaction should be added
CALL FUNCTION 'POPUP_TO_CONFIRM'
EXPORTING
TEXT_QUESTION         = QUESTION
TEXT_BUTTON_1         = 'Continue rec'
TEXT_BUTTON_2         = 'Finish rec'
DISPLAY_CANCEL_BUTTON = 'X'
IMPORTING
ANSWER                = ANSWER.

*    If the user wants to finish or continue recording - add the last
*    transaction data to file
IF ANSWER = '1' OR ANSWER = '2'.

*      Fill the last transaction into the file
PERFORM ADD_TRANSACTION_TO_XML
TABLES   GT_BDCDATA GT_MSG
USING    PREV_TRANS 'X'
CHANGING G_XML_SIZE.

*     Reset the trace and restore global parameters
PERFORM RESET_DIAG_TRACE USING CURR_WP_NO.
PERFORM RESTORE_GLOBAL_PARAMS.

*      If the user wants to continue - add other transaction
IF ANSWER = '1'.

*        Set the trace parameters
PERFORM SET_DIAG_TRACE.

*        Choose new transaction
PERFORM CHOOSE_NEW_TRANSACTION CHANGING IS_TRANSACTION_CHOSEN.

IF IS_TRANSACTION_CHOSEN = 'X'.
*          Get back to main
PERFORM MAIN USING P_TCODE.
ELSE.
PERFORM POPUP_RECORDING_COMPLETED.
ENDIF.

*      If the user didn't want to continue recordings - just show
*      the result file
ELSEIF ANSWER = '2'.
*        Show the file
PERFORM FINISH_AND_SHOW_FILE USING G_STARTTIME.
ENDIF.

ELSEIF ANSWER = 'A'.

*     Delete the file that was created if the user chooses not to upload
*     it to Panaya
G_WAS_FILE_CREATED = 'X'.
PERFORM DELETE_XML.
MESSAGE S001(00) WITH 'Recording not sent to Panaya.'.

ENDIF.

*    Submit the recorder again once the user finished the recovery mode,
*    since many global variables were used during the recovery mode and
*    should be refreshed for a new recording
SUBMIT (SY-CPROG) VIA SELECTION-SCREEN.
ENDIF.
ENDIF.

ENDFORM.                    " FINISH_PREV_RECORDING

*&---------------------------------------------------------------------*
*&      Form  POPUP_RECORDING_COMPLETED
*&---------------------------------------------------------------------*
FORM POPUP_RECORDING_COMPLETED.

DATA: ANSWER(1)  TYPE C,
QUESTION TYPE STRING.

*  If user ask to work in offline mode - ask if the file should be
*  generated. OTherwise - ask if file should be upload to Panaya.
IF C_OFF IS INITIAL.
QUESTION = 'Recording completed. Upload to Panaya?'.
ELSE.
CONCATENATE 'Recording completed. Generate recording file '
G_FILENAME ' ? '
INTO QUESTION SEPARATED BY SPACE.
ENDIF.
CALL FUNCTION 'POPUP_TO_CONFIRM'
EXPORTING
TEXT_QUESTION         = QUESTION
TEXT_BUTTON_1         = 'Yes'
TEXT_BUTTON_2         = 'No'
DISPLAY_CANCEL_BUTTON = ' '
IMPORTING
ANSWER                = ANSWER.

*   Send the results only if 'Yes' was chosen
IF ANSWER = 1.

*     Finish creating the file ( all suffixes ) and call the browser to
*     show the HTML.
PERFORM FINISH_AND_SHOW_FILE USING G_STARTTIME.

ELSE.

*     Delete the file that was created if the user chose not to upload
*     it to Panaya
PERFORM DELETE_XML.
MESSAGE S001(00) WITH 'Recording not sent to Panaya.'.
ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  CONVERT_TRACE_LINE
*&---------------------------------------------------------------------*
FORM CONVERT_TRACE_LINE CHANGING P_LINE TYPE STRING.

DATA: LEN TYPE I.

LEN = STRLEN( P_LINE ).

*   Handle special prefixes
IF LEN > 0.
IF ( P_LINE(1) = 'D' OR
P_LINE(1) = 'M' OR
P_LINE(1) = '*' ).
P_LINE = P_LINE+1.
ENDIF.
ENDIF.
CONCATENATE P_LINE C_LINE_FEED INTO P_LINE.

ENDFORM.                    " CONVERT_TRACE_LINE

*&---------------------------------------------------------------------*
*&      Form  GET_SAP_WORKDIR_ON_SERVER
*&---------------------------------------------------------------------*
FORM GET_SAP_WORKDIR_ON_SERVER CHANGING P_WORKDIR.

CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'rdisp/workdir'
ID 'VALUE' FIELD P_WORKDIR.

ENDFORM.                    " GET_SAP_WORKDIR_ON_SERVER

*---------------------------------------------------------------------*
*       FORM GET_SAP_WORKDIR_ON_SERVER_SEP                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  P_WORKDIR                                                     *
*---------------------------------------------------------------------*
FORM GET_SAP_WORKDIR_ON_SERVER_SEP CHANGING P_WORKDIR.

DATA: PLATFORM TYPE STRING.

* Get server workdir
PERFORM GET_SAP_WORKDIR_ON_SERVER CHANGING P_WORKDIR.

* Get the separator based on platform
* Get platform
PERFORM FIND_PLATFORM CHANGING PLATFORM.

* In case of Unix system - call GZIP directly, without the
* system command
IF PLATFORM = 'Unix' OR PLATFORM = 'Linux' OR PLATFORM = 'SunOS'
OR PLATFORM = 'AIX' OR PLATFORM = 'HP-UX'.
CONCATENATE P_WORKDIR '/' INTO P_WORKDIR.
ELSE.
CONCATENATE P_WORKDIR '\' INTO P_WORKDIR.
ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  ZIP_XML
*&---------------------------------------------------------------------*
FORM ZIP_XML CHANGING IS_SUCC.

DATA: PLATFORM LIKE SY-OPSYS.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'ZIP' '' 'Start of zipping'.

PERFORM ADD_TO_LOG USING
'Zipping the xml file in server' GC_LOG_WRITE.

PERFORM FIND_PLATFORM CHANGING PLATFORM.

* In case of Unix system - call GZIP directly, without the
* system command
IF PLATFORM = 'Unix' OR PLATFORM = 'Linux' OR PLATFORM = 'SunOS'
OR PLATFORM = 'AIX' OR PLATFORM = 'HP-UX'.

PERFORM ZIP_XML_IN_UNIX CHANGING IS_SUCC.

* Use external command that should be defined
ELSE.

PERFORM ZIP_XML_IN_EXTERNAL_CMD CHANGING IS_SUCC.

ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'ZIP' '' 'End of zipping'.

ENDFORM.                    " ZIP_XML

*&---------------------------------------------------------------------*
*&      Form  ZIP_XML_IN_UNIX
*&---------------------------------------------------------------------*
FORM ZIP_XML_IN_UNIX CHANGING IS_SUCC.

DATA: CMD(254),
RESULT(255) OCCURS 100 WITH HEADER LINE,
LV_ZIPED_FILENAME(250).

CLEAR IS_SUCC.

* Create the zip statement
CONCATENATE 'gzip --best' TEMP_XML_FILENAME
INTO CMD
SEPARATED BY SPACE.

* Execute the zipping command
REFRESH RESULT.
CALL 'SYSTEM' ID 'COMMAND' FIELD CMD
ID 'TAB'     FIELD RESULT-*SYS*.

IF SY-SUBRC LE 0.
*   Check that the ziped file was created at the server
CONCATENATE TEMP_XML_FILENAME '.gz'
INTO LV_ZIPED_FILENAME .

OPEN DATASET LV_ZIPED_FILENAME FOR INPUT IN BINARY MODE.

IF SY-SUBRC <> 0.
IS_SUCC = SPACE.
ELSE.
IS_SUCC = 'X'.
CLOSE DATASET LV_ZIPED_FILENAME.
ENDIF.
ENDIF.

ENDFORM.                    " ZIP_XML_IN_UNIX

*&---------------------------------------------------------------------*
*&      Form  ZIP_XML_IN_EXTERNAL_CMD
*&---------------------------------------------------------------------*
FORM ZIP_XML_IN_EXTERNAL_CMD CHANGING IS_SUCC.

DATA: STATUS                 LIKE EXTCMDEXEX-STATUS,
EXIT_CODE              LIKE EXTCMDEXEX-EXITCODE,
PARAMETERS             LIKE SXPGCOLIST-PARAMETERS,
EXEC_PROTOCOL          TYPE BTCXPM OCCURS 0,
LV_SUBRC               TYPE STRING,
MSG                    TYPE STRING,
LV_ZIPED_FILENAME(250).

CLEAR IS_SUCC.
* Execute the zipping command
PARAMETERS = TEMP_XML_FILENAME.
CALL FUNCTION 'SXPG_COMMAND_EXECUTE'
EXPORTING
COMMANDNAME                   = GZIP_COMMAND
ADDITIONAL_PARAMETERS         = PARAMETERS
IMPORTING
STATUS                        = STATUS
EXITCODE                      = EXIT_CODE
TABLES
EXEC_PROTOCOL                 = EXEC_PROTOCOL
EXCEPTIONS
NO_PERMISSION                 = 1
COMMAND_NOT_FOUND             = 2
PARAMETERS_TOO_LONG           = 3
SECURITY_RISK                 = 4
WRONG_CHECK_CALL_INTERFACE    = 5
PROGRAM_START_ERROR           = 6
PROGRAM_TERMINATION_ERROR     = 7
X_ERROR                       = 8
PARAMETER_EXPECTED            = 9
TOO_MANY_PARAMETERS           = 10
ILLEGAL_COMMAND               = 11
WRONG_ASYNCHRONOUS_PARAMETERS = 12
CANT_ENQ_TBTCO_ENTRY          = 13
JOBCOUNT_GENERATION_ERROR     = 14
OTHERS                        = 15.

* If errors didn't happen and status is set to O, the
* compression was successfull
IF ( SY-SUBRC IS INITIAL ) AND ( STATUS = 'O' ).
*   Check that the ziped file was created at the server
CONCATENATE TEMP_XML_FILENAME '.gz'
INTO LV_ZIPED_FILENAME .

OPEN DATASET LV_ZIPED_FILENAME FOR INPUT IN BINARY MODE.

IF SY-SUBRC <> 0.
IS_SUCC = SPACE.
ELSE.
IS_SUCC = 'X'.
CLOSE DATASET LV_ZIPED_FILENAME.
ENDIF.
ELSE.
LV_SUBRC = SY-SUBRC.
CONCATENATE : 'Zipping command failed , RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  add_data_to_file_in_client
*&---------------------------------------------------------------------*
FORM ADD_DATA_TO_FILE_IN_CLIENT USING P_DATA_TAB TYPE STRING_TAB
P_ADD_END_OF_LINE
P_FILENAME TYPE STRING
P_ERROR_MSG TYPE STRING
CHANGING P_IS_APPEND_MODE.

DATA : MSG      TYPE STRING,
LV_SUBRC TYPE STRING.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'GUI_DOWNLOAD'
P_FILENAME 'Start of gui_download execution'.

* Download the file
IF NOT G_SHOW_TRANS_STATUS_APPEARS IS INITIAL.
CALL FUNCTION 'GUI_DOWNLOAD'
EXPORTING
FILENAME                = P_FILENAME
FILETYPE                = 'ASC'
APPEND                  = P_IS_APPEND_MODE
TRUNC_TRAILING_BLANKS   = 'X'
WRITE_LF                = P_ADD_END_OF_LINE
SHOW_TRANSFER_STATUS    = ABAP_FALSE
TABLES
DATA_TAB                = P_DATA_TAB
EXCEPTIONS
FILE_WRITE_ERROR        = 1
NO_BATCH                = 2
GUI_REFUSE_FILETRANSFER = 3
INVALID_TYPE            = 4
NO_AUTHORITY            = 5
UNKNOWN_ERROR           = 6
HEADER_NOT_ALLOWED      = 7
SEPARATOR_NOT_ALLOWED   = 8
FILESIZE_NOT_ALLOWED    = 9
HEADER_TOO_LONG         = 10
DP_ERROR_CREATE         = 11
DP_ERROR_SEND           = 12
DP_ERROR_WRITE          = 13
UNKNOWN_DP_ERROR        = 14
ACCESS_DENIED           = 15
DP_OUT_OF_MEMORY        = 16
DISK_FULL               = 17
DP_TIMEOUT              = 18
FILE_NOT_FOUND          = 19
DATAPROVIDER_EXCEPTION  = 20
CONTROL_FLUSH_ERROR     = 21
OTHERS                  = 22.
ELSE.
CALL FUNCTION 'GUI_DOWNLOAD'
EXPORTING
FILENAME                = P_FILENAME
FILETYPE                = 'ASC'
APPEND                  = P_IS_APPEND_MODE
TRUNC_TRAILING_BLANKS   = 'X'
WRITE_LF                = P_ADD_END_OF_LINE
TABLES
DATA_TAB                = P_DATA_TAB
EXCEPTIONS
FILE_WRITE_ERROR        = 1
NO_BATCH                = 2
GUI_REFUSE_FILETRANSFER = 3
INVALID_TYPE            = 4
NO_AUTHORITY            = 5
UNKNOWN_ERROR           = 6
HEADER_NOT_ALLOWED      = 7
SEPARATOR_NOT_ALLOWED   = 8
FILESIZE_NOT_ALLOWED    = 9
HEADER_TOO_LONG         = 10
DP_ERROR_CREATE         = 11
DP_ERROR_SEND           = 12
DP_ERROR_WRITE          = 13
UNKNOWN_DP_ERROR        = 14
ACCESS_DENIED           = 15
DP_OUT_OF_MEMORY        = 16
DISK_FULL               = 17
DP_TIMEOUT              = 18
FILE_NOT_FOUND          = 19
DATAPROVIDER_EXCEPTION  = 20
CONTROL_FLUSH_ERROR     = 21
OTHERS                  = 22.
ENDIF.

IF P_FILENAME <> G_LOG_FILENAME.
IF SY-SUBRC <> 0.

*     Dont add error message to log
LV_SUBRC = SY-SUBRC.
MSG = P_FILENAME.
CONCATENATE :
'GUI_DOWNLOAD ended with error RC:'
LV_SUBRC
'file:'
MSG
INTO MSG SEPARATED BY SPACE.

CASE LV_SUBRC.
WHEN 1."file_write_error
MESSAGE E001(00) WITH MSG
'Error code: ' LV_SUBRC ' - File write error'.
WHEN 5."No authority
MESSAGE E001(00) WITH MSG
'Error code: ' LV_SUBRC ' - No authority'.
WHEN 15."access_denied
MESSAGE E001(00) WITH MSG
'Error code: ' LV_SUBRC ' - Access denied'.
WHEN 17."disk_full
MESSAGE E001(00) WITH MSG
'Error code: ' LV_SUBRC ' - Disk full'.
WHEN OTHERS.
MESSAGE E001(00) WITH MSG
'Error code: ' LV_SUBRC.
ENDCASE.
ELSE.
MSG = P_FILENAME.
CONCATENATE :
'GUI_DOWNLOAD finished successfully to file:'
MSG
INTO MSG SEPARATED BY SPACE.

PERFORM ADD_TO_LOG USING
MSG GC_LOG_WRITE.
ENDIF.
ENDIF.

IF P_IS_APPEND_MODE IS INITIAL.
P_IS_APPEND_MODE = 'X'.
ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'GUI_DOWNLOAD'
P_FILENAME 'End of gui download execution'.
ENDFORM.                    "ADD_DATA_TO_FILE_IN_CLIENT
*&---------------------------------------------------------------------*
*&      Form  WRITE_XML_TO_CLIENT
*&---------------------------------------------------------------------*
FORM WRITE_XML_TO_CLIENT USING IS_ZIP_SUCC SHOULD_ADD_XML_ESC.

PERFORM ADD_TO_LOG USING
'Transfering the server file to client'
GC_LOG_WRITE.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE
'WRITE SERVER FILE TO CLIENT' ''
'Start write server file to client'.

* If zipping is available or we want to encode to base 64.
IF ( NOT IS_ZIP_AVAILABLE IS INITIAL AND
NOT IS_ZIP_SUCC IS INITIAL  ) OR
NOT SHOULD_ENCODE_BASE_64_DEBUG IS INITIAL.

*   Add zipped content to file
PERFORM ENCODE_BASE64_AND_ADD_TO_FILE USING IS_ZIP_SUCC.

* Otherwise - check if we want to use BASE4 encoding. If not -
* create unconverted file.
ELSEIF SHOULD_ENCODE_BASE_64_DEBUG IS INITIAL.

*   Work with the previous method - unconverted file.
PERFORM ADD_XML_TEXT_CONTENT_TO_FILE USING SHOULD_ADD_XML_ESC.

ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE
'WRITE SERVER FILE TO CLIENT' ''
'End write server file to client'.

* Add zp_Record success message
PERFORM ADD_TO_LOG USING
'ZP_RECORD END finished successfully'
GC_LOG_WRITE.

* Log flush executed in measurement flush
PERFORM ADD_MEASURES_TO_LOG.
ENDFORM.                    " WRITE_XML_TO_CLIENT

*&---------------------------------------------------------------------*
*&      Form  CHECK_GZIP
*&---------------------------------------------------------------------*
FORM CHECK_GZIP USING    SHOW_MSG.

DATA: PLATFORM LIKE SY-OPSYS.
DATA: STATUS                 LIKE EXTCMDEXEX-STATUS,
EXIT_CODE              LIKE EXTCMDEXEX-EXITCODE,
PARAMETERS             LIKE SXPGCOLIST-PARAMETERS,
EXEC_PROTOCOL          TYPE BTCXPM OCCURS 0,
FIRST_LINE TYPE STRING,
SECOND_LINE TYPE STRING,
THIRD_LINE TYPE STRING,
FOURTH_LINE TYPE STRING,
RC(2) TYPE C.

CLEAR IS_ZIP_AVAILABLE.

* Check the platform
PERFORM FIND_PLATFORM CHANGING PLATFORM.

* In Unix the gzip exists. Check only for other OS.
IF PLATFORM <> 'Unix' AND PLATFORM <> 'Linux' AND PLATFORM <> 'SunOS'
AND PLATFORM <> 'AIX' AND PLATFORM <> 'HP-UX'.

*   Check if the command can be executed
PARAMETERS = '1.txt'.
CALL FUNCTION 'SXPG_COMMAND_CHECK'
EXPORTING
COMMANDNAME                = GZIP_COMMAND
ADDITIONAL_PARAMETERS      = PARAMETERS
EXCEPTIONS
NO_PERMISSION              = 1
COMMAND_NOT_FOUND          = 2
PARAMETERS_TOO_LONG        = 3
SECURITY_RISK              = 4
WRONG_CHECK_CALL_INTERFACE = 5
X_ERROR                    = 6
TOO_MANY_PARAMETERS        = 7
PARAMETER_EXPECTED         = 8
ILLEGAL_COMMAND            = 9
COMMUNICATION_FAILURE      = 10
SYSTEM_FAILURE             = 11
OTHERS                     = 12.

IF SY-SUBRC <> 0.
IF SHOW_MSG = 'X'.
RC = SY-SUBRC.
*       Create first line of the message
FIRST_LINE =
'Compression software is required for making scenario generation work '.
CONCATENATE ICON_MESSAGE_INFORMATION
'Compression software is required for making scenario generation work '
INTO FIRST_LINE
SEPARATED BY SPACE.

*       Second line
SECOND_LINE =
'much faster. However, operating system command for compression is not'.

*       Show sy-subrc
CONCATENATE 'defined (RC : '
RC
'). Please follow the installation guide to define the command'
INTO THIRD_LINE
SEPARATED BY SPACE.

*       Create fourth line of the message
CONCATENATE GZIP_COMMAND ' for compression. '
'It is possible to continue without compression.'
INTO
FOURTH_LINE SEPARATED BY SPACE.

*       Show the message
CALL FUNCTION 'POPUP_TO_INFORM'
EXPORTING
TITEL = 'Compression command not defined'
TXT1  = FIRST_LINE
TXT2  = SECOND_LINE
TXT3  = THIRD_LINE
TXT4  = FOURTH_LINE.

ENDIF.
*   If the command succeeded - zip is available
ELSE.
IS_ZIP_AVAILABLE = 'X'.
ENDIF.
* In case of unix - the GZIP is available as a part of OS
ELSE.
IS_ZIP_AVAILABLE = 'X'.
ENDIF.
ENDFORM.                    " CHECK_GZIP

*&---------------------------------------------------------------------*
*&      Form  FIND_PLATFORM
*&---------------------------------------------------------------------*
FORM FIND_PLATFORM CHANGING P_PLATFORM.
P_PLATFORM =  SY-OPSYS.
ENDFORM.                    " FIND_PLATFORM

*&---------------------------------------------------------------------*
*&      Form  HANDLE_XML_ESCAPING
*&---------------------------------------------------------------------*
FORM HANDLE_XML_ESCAPING CHANGING XML_CONTENT_STR TYPE STRING.

*   Replace special xml chars
PERFORM REPLACE_WITH_SPACE USING '&amp;' '#$$cafe#$$babe#'
CHANGING XML_CONTENT_STR.
PERFORM REPLACE_WITH_SPACE USING '#$$cafe#$$babe#' '&amp;amp;'
CHANGING XML_CONTENT_STR.

PERFORM REPLACE_WITH_SPACE USING '&lt;' '&amp;lt;'
CHANGING XML_CONTENT_STR.

PERFORM REPLACE_WITH_SPACE USING '&gt;' '&amp;gt;'
CHANGING XML_CONTENT_STR.

PERFORM REPLACE_WITH_SPACE USING '&apos;' '&amp;apos;'
CHANGING XML_CONTENT_STR.

PERFORM REPLACE_WITH_SPACE USING '&quot;' '&amp;quot;'
CHANGING XML_CONTENT_STR.


*  * Make manual replaces of "

*   Replace of the opening quote
CALL FUNCTION 'STRING_REPLACE'
EXPORTING
PATTERN    = '="'
SUBSTITUTE = '=&quot;'
CHANGING
TEXT       = XML_CONTENT_STR.

*   Replace of the closing quote of the ?xml tag
CALL FUNCTION 'STRING_REPLACE'
EXPORTING
PATTERN    = '"?'
SUBSTITUTE = '&quot;?'
CHANGING
TEXT       = XML_CONTENT_STR.

*   This replace adds space after the closing quote
PERFORM REPLACE_WITH_SPACE USING '"' '&quot; '
CHANGING XML_CONTENT_STR.

*   Replace all possible missing spaces
PERFORM REPLACE_WITH_SPACE USING '<BDCDATA' '#$$cafe#$$babe#'
CHANGING XML_CONTENT_STR.
PERFORM REPLACE_WITH_SPACE USING '#$$cafe#$$babe#' '<BDCDATA '
CHANGING XML_CONTENT_STR.

PERFORM REPLACE_WITH_SPACE USING '<MSG' '#$$cafe#$$babe#'
CHANGING XML_CONTENT_STR.
PERFORM REPLACE_WITH_SPACE USING '#$$cafe#$$babe#' '<MSG '
CHANGING XML_CONTENT_STR.

ENDFORM.                    " HANDLE_XML_ESCAPING

*&---------------------------------------------------------------------*
*&      Form  EXTERNAL_START_REC
*&---------------------------------------------------------------------*
FORM EXTERNAL_START_REC.

DATA: L_PARAMS LIKE LINE OF G_IT_PARAMS_VALUES,
PARAM_NAME(13) TYPE C,
COUNTER(3) TYPE N,
L_OTHER_REC,
MSG TYPE STRING,
L_PREV_FILENAME(128),
L_OLD_TRACE_FILENAME TYPE RSMRGSTR-NAME.

* Check that the filename entered is valid ( try to create it )
* This is important for creating the log file
PERFORM CHECK_EXTERNAL_FILENAME.

* Clear append mode of log
CLEAR G_LOG_FILE_APPEND_MODE_CLIENT.

PERFORM GENERATE_UPARAMS_FILENAMES.

PERFORM ADD_TO_LOG USING
'**** Recording started in external start mode. ****' GC_FLUSH_LOG.

* Check that the gzip is installed properally. If not - add to log
PERFORM CHECK_GZIP USING ' '.
IF IS_ZIP_AVAILABLE IS INITIAL.
PERFORM ADD_TO_LOG USING
'Compression function not installed' GC_LOG_WRITE.
ENDIF.

* Check if other recording was already started in current session.
* Show an error and dont' continue.
GET PARAMETER ID 'PANAYA_SR25' FIELD L_OTHER_REC.
IF NOT L_OTHER_REC IS INITIAL.

*   Get the previous filename of global parameters
GET PARAMETER ID 'PANAYA_SR22' FIELD L_PREV_FILENAME.

*   Reset the log in order to start the recording
*   Reset trace
PERFORM RESET_DIAG_TRACE USING CURR_WP_NO.

*   Reset global parameters
PERFORM RESET_EXT_GLOBAL_PARAMETERS.

*   Restore global parameters
PERFORM RESTORE_GLOBAL_PARAMS.

*   Add to log and continue
CONCATENATE 'A recroding was already started and'
'did not end properally!'
'Previous recording results were deleted'
'and new recording was started'
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ENDIF.

* Release locked processes, if exist
PERFORM RELEASE_LOCKED_WPS.

* Set the trace parameters
PERFORM SET_DIAG_TRACE.

* Save the current state of the user parameters in a file for later use.
PERFORM SAVE_UPARAMS_TO_ITAB TABLES G_USERS_PARAMS
USING  P_PGRPID.
PERFORM ADD_TO_UPARAMS_FILE TABLES G_USERS_PARAMS
USING  G_RECORDING_PARAM_FILENAME.

* If the transaction was called in continue paused play mode
IF P_MODE EQ RESUME_PAUSE.
DATA: DELETE_FILE TYPE C VALUE 'X',
ONLY_RESTORE_CALLED VALUE ' '.
*   Restore user parameters from the pause file sent by the player
PERFORM RESTORE_UPARAMS USING G_RESUME_PAUSE_FILENAME
DELETE_FILE
GC_LOG_WRITE.
* If we are in Recorder mode
ELSEIF P_MODE EQ RECORDING.
*   DO NOTHING
ELSEIF P_MODE IS INITIAL.
*   Mode is initial when player begins. It supports scenarios which
*   don't have parameters to restore
*   Reset the SPA/GPA
PERFORM CLEAR_GLOBAL_PARAMS.
ENDIF.

* The F4 screens are recorded in the trace file only if they are not
* ActiveX screens.Therefore regardless to what the users have we always
* set this to no activex.
SET PARAMETER ID 'F4METHOD' FIELD 'NoActiveX'.

* Calculate where starts the relevant trace ( and save it using set
* parameter )
PERFORM CALC_RELEVANT_POS_IN_TRACE.

PERFORM GET_OLD_TRACE_FILENAME CHANGING L_OLD_TRACE_FILENAME.
PERFORM READ_TRACE_INFO USING L_OLD_TRACE_FILENAME
CHANGING G_OLD_TRACE_SIZE G_OLD_TRACE_TIME.

SET PARAMETER ID 'PANAYA_SR20' FIELD G_FIRST_REL_POS.

* Save the recording start time
SET PARAMETER ID 'PANAYA_SR21' FIELD G_STARTTIME.

* Save the local filename ( that is saved as scenario name )
SET PARAMETER ID 'PANAYA_SR22' FIELD P_SCENAR.

* Set parameter that recording has started
SET PARAMETER ID 'PANAYA_SR25' FIELD 'X'.

* Set parameter that log was written
SET PARAMETER ID 'PANAYA_SR26' FIELD G_LOG_FILE_APPEND_MODE_CLIENT.

* .old trace parameter file size
SET PARAMETER ID 'PANAYA_SR27' FIELD G_OLD_TRACE_SIZE.

* .old trace parameter last modified time (seconds from 1970)
SET PARAMETER ID 'PANAYA_SR28' FIELD G_OLD_TRACE_TIME.

CONCATENATE 'Write global param. SR20: ' G_FIRST_REL_POS INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
CONCATENATE 'Write global param. SR22: ' P_SCENAR INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

PERFORM LOG_SYSTEM_WP_PARAMETERS.

PERFORM ADD_WPS_STATUS_TO_LOG.

* Add current measures data to log file
* for the end mode data read
* flush the log!!!
PERFORM ADD_MEASURES_TO_LOG.

ENDFORM.                    " EXTERNAL_START_REC
*&---------------------------------------------------------------------*
*&      Form  EXTERNAL_END_REC
*&---------------------------------------------------------------------*
FORM EXTERNAL_END_REC.

DATA: IS_ZIP_SUCC,
WORKDIR(120),
L_FILENAME(128),
L_ENCODING TYPE STRING,
COUNTER(3) TYPE N,
MAX_PARAM_NO(3) TYPE N,
L_PARAMS LIKE LINE OF G_IT_PARAMS_VALUES,
PARAM_NAME(13) TYPE C,
L_REC_STARTED,
MSG TYPE STRING,
FILE_PATH TYPE TABLE OF STRING,
FILE_PATH_LENGTH TYPE I,
FILENAME TYPE STRING,
WP_NO_AT_START TYPE I,
C_WP_NO(5) TYPE C,
WP_NO_AT_END TYPE I,
LV_WP_CHANGED TYPE FLAG,
SUCC LIKE SY-SUBRC,
C_SUCC(10) TYPE C.

* Get the log file append mode
GET PARAMETER ID 'PANAYA_SR26' FIELD
G_LOG_FILE_APPEND_MODE_CLIENT.

* Get the filename
GET PARAMETER ID 'PANAYA_SR22' FIELD L_FILENAME.
G_FILENAME = L_FILENAME.

PERFORM GENERATE_UPARAMS_FILENAMES.

IF NOT G_LOG_FILENAME IS INITIAL.
*   The log filename is built in generate_uparams_filenames
PERFORM ADD_TO_LOG USING '' GC_LOG_WRITE.
PERFORM ADD_TO_LOG USING
'**** Recording started in external end mode. ****' GC_FLUSH_LOG.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE
'***STARTED END MODE***' '' '***STARTED END MODE***'.
ENDIF.

* Check that recording was started and continue only if it was
GET PARAMETER ID 'PANAYA_SR25' FIELD L_REC_STARTED.
IF NOT L_REC_STARTED IS INITIAL.

*   Get the current work process
CALL FUNCTION 'TH_GET_OWN_WP_NO'
IMPORTING
SUBRC    = SUCC
WP_INDEX = WP_NO_AT_END.

IF SY-SUBRC <> 0.
C_SUCC = SUCC.
CONCATENATE
'Error fetching current Work Process. Error code:'
C_SUCC INTO MSG SEPARATED BY SPACE.

PERFORM ADD_TO_LOG USING
MSG
GC_LOG_WRITE.

CLEAR MSG.
ENDIF.
*   Get the work process at start time
GET PARAMETER ID 'PANAYA_SR31' FIELD C_WP_NO.
WP_NO_AT_START = C_WP_NO.

*   Check that the work process hasn't changed from start time.
IF WP_NO_AT_END NE WP_NO_AT_START.
PERFORM ADD_TO_LOG USING
'WORK_PROCESS_CHANGED = TRUE'
GC_LOG_WRITE.

LV_WP_CHANGED = ABAP_TRUE.
ELSE.
PERFORM ADD_TO_LOG USING
'WORK_PROCESS_CHANGED = FALSE'
GC_LOG_WRITE.

LV_WP_CHANGED = ABAP_FALSE.
ENDIF.

*   Get from global memory the value of trace first pos
GET PARAMETER ID 'PANAYA_SR20' FIELD G_FIRST_REL_POS.

*   Get the recording start time
GET PARAMETER ID 'PANAYA_SR21' FIELD G_STARTTIME.

*   .old trace parameter file size
GET PARAMETER ID 'PANAYA_SR27' FIELD G_OLD_TRACE_SIZE.

*   .old trace parameter last modified time (seconds from 1970)
GET PARAMETER ID 'PANAYA_SR28' FIELD G_OLD_TRACE_TIME.

*   Get parameter of atra filename
GET PARAMETER ID 'PANAYA_SR30' FIELD ATRA_FILENAME.

IF P_MODE EQ PAUSE_PLAY.
*     In player mode, save the state at the end of the playback
*     incase this is a pause playback
PERFORM CREATE_PAUSE_UPARAMS_XML_FILE USING GC_LOG_WRITE.
ENDIF.
IF P_MODE NE RECORDING.
DATA: DELETE_FILE TYPE C VALUE 'X',
ONLY_RESTORE_CALLED VALUE ' '.

PERFORM ADD_TO_LOG USING
'Restoring current user parameters to their state before zp_record...'
GC_LOG_WRITE.

PERFORM RESTORE_UPARAMS USING G_RECORDING_PARAM_FILENAME
DELETE_FILE
GC_LOG_WRITE.
ENDIF.

PERFORM ADD_TO_LOG USING
'Read restore operations user parameters...' GC_LOG_WRITE.
*   Read the parameters state that was saved at the begining of the
*   recording inorder to pass them to the recorder/player
PERFORM READ_UPARAMS_FROM_DIRECTORY TABLES G_USERS_PARAMS
USING  G_RECORDING_PARAM_DIRECTORY
GC_LOG_WRITE.

CONCATENATE 'Read global param. SR20: ' G_FIRST_REL_POS INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
CONCATENATE 'Read global param. SR22: ' L_FILENAME INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

*   Reset global parameters
PERFORM RESET_EXT_GLOBAL_PARAMETERS.

*   Get the filename in server
PERFORM GET_SAP_WORKDIR_ON_SERVER_SEP CHANGING WORKDIR.

*   Concatenate the filename in client to the filename in server
*   ( including the .xml extention )
SPLIT L_FILENAME AT '\' INTO TABLE FILE_PATH.
DESCRIBE TABLE FILE_PATH LINES FILE_PATH_LENGTH.
READ TABLE FILE_PATH INDEX FILE_PATH_LENGTH INTO FILENAME.
CONCATENATE WORKDIR 'temp_panaya_xml_'
SY-SYSID  '_' SY-UNAME '_' FILENAME
INTO TEMP_XML_FILENAME.
CONCATENATE 'Filename in server: ' TEMP_XML_FILENAME INTO MSG.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

*   Build XML root
PERFORM BUILD_XML_HEADER.

*   Add the trace file data to a temp file at the server side
*   temp_xml_filename
*   The log data is addded at the end of the trace dat to the same
*   temp_xml_filename
*   Any other data written to the log afterwards will not appear in the
*   xml sent to Panaya !!!
PERFORM ADD_TRANSACTION_TO_XML
TABLES   GT_BDCDATA GT_MSG
USING    P_TCODE ' '
CHANGING G_XML_SIZE.

*   Reset trace
PERFORM RESET_DIAG_TRACE USING CURR_WP_NO.

IF NOT SHOULD_RUN_RUNTIME_TRACE IS INITIAL.
*     Add the RTT data
PERFORM ADD_RTT_DATA_FILE.
ENDIF.

PERFORM ADD_UPARAMS_TO_XML TABLES G_USERS_PARAMS.

*   Add recording timestamp
PERFORM ADD_TIME_STAT_TO_XML USING G_STARTTIME.

*   Add the measurement data to xml
PERFORM ADD_MEASUREMENT_TO_XML.

*   Add XML suffix
*   Last addition to XML flushes the buffer !!!
PERFORM BUILD_XML_SUFFIX.

*   Zip the file and read the zipped info. Here - don't show
*   error if zipping failed
PERFORM CHECK_GZIP USING ' '.
IF NOT IS_ZIP_AVAILABLE IS INITIAL.
PERFORM ZIP_XML CHANGING IS_ZIP_SUCC.
ENDIF.

*   If the zipping failed - add an message to the log file
IF IS_ZIP_SUCC IS INITIAL.
PERFORM ADD_TO_LOG USING
'Compression function installed, but did not work properally.'
GC_LOG_WRITE.
ENDIF.

*   Add first line - is Zipped and encoding
PERFORM ADD_IS_ZIPPED_AND_ENCODING USING IS_ZIP_SUCC.

*   Flush the temp server file temp_xml_filename
*   to client file . Also add the zipped info
PERFORM WRITE_XML_TO_CLIENT USING IS_ZIP_SUCC ' '.

*   The wp waas changed beteween start and end
*   fetch the dispatcher file from server - dev_disp
*   for additional enquiry
IF NOT LV_WP_CHANGED IS INITIAL.
PERFORM ADD_DEV_DISP_TO_LOG.
ENDIF.
ELSE.

PERFORM NO_END_TO_FAILURE_FILE.
ENDIF.

ENDFORM.                    " EXTERNAL_END_REC
*&---------------------------------------------------------------------*
*&      Form  ADD_IS_ZIPPED_AND_ENCODING
*&---------------------------------------------------------------------*
FORM ADD_IS_ZIPPED_AND_ENCODING USING IS_ZIP_SUCC.

DATA: L_ENCODING TYPE STRING,
STRING_REC TYPE STRING.

* Get the encoding
PERFORM GET_CURRENT_ENCODING CHANGING L_ENCODING.

* Create the string
CONCATENATE 'IsZipped=' IS_ZIP_SUCC '; IsBase64='
SHOULD_ENCODE_BASE_64_DEBUG '; Encoding=' L_ENCODING
INTO STRING_REC.

* Add the records to buffer ( with end line )
PERFORM APPEND_STRING_TO_BUFFER USING STRING_REC 'X' 'X'.

* Flush the buffer into the client - ascii mode
PERFORM FLUSH_BUFFER USING 'X' 'X'.

ENDFORM.                    " ADD_IS_ZIPPED_AND_ENCODING

*&---------------------------------------------------------------------*
*&      Form  HADNLE_EXTERNALLY_CALLED
*&---------------------------------------------------------------------*
FORM HADNLE_EXTERNALLY_CALLED.

CLEAR: CALLED_EXTERNALLY_START, CALLED_EXTERNALLY_END,
CALLED_EXTERNALLY_START_RTT.

G_FILENAME = P_SCENAR.
PERFORM GENERATE_UPARAMS_FILENAMES.

* Check if the transaction is predefined constant that flags that the
* recorder was started called externally. In this case update the
* Scenario Name field with te filename to which the xml is created.
IF P_TCODE = EXTERNALLY_CALLED_START.

*    Set the called externally start flag
CALLED_EXTERNALLY_START = 'X'.

*   Generate user formats file
PERFORM GENERATE_CLIENT_DATA_FILE.

* Check if the transaction is predefined constant that flags that the
* recorder was ended externally.
ELSEIF P_TCODE = EXTERNALLY_CALLED_END.

*    Set the called externally end flag
CALLED_EXTERNALLY_END = 'X'.

* Checking if the transaction is pridefined constatn that flags that the
* recorder should start the runtime trace
ELSEIF P_TCODE = EXTERNALLY_CALLED_START_RTT.
*   set the runtime trace start flag
CALLED_EXTERNALLY_START_RTT = 'X'.
ELSEIF P_TCODE = EXTERNALLY_CALLED_RESTORE.
CALLED_EXTERNALLY_RESTORE = 'X'.
ENDIF.

ENDFORM.                    " HADNLE_EXTERNALLY_CALLED

*&---------------------------------------------------------------------*
*&      Form  CHECK_EXTERNAL_FILENAME
*&---------------------------------------------------------------------*
FORM CHECK_EXTERNAL_FILENAME.

DATA: DATA_TAB TYPE STRING_TAB,
MSG TYPE STRING,
LV_SUBRC TYPE STRING,
APPEND.

PERFORM ADD_DATA_TO_FILE_IN_CLIENT USING
DATA_TAB
'X'
G_FILENAME
'Could not create file in client.'
CHANGING
APPEND.

* If reached here - the file as created successfully
DATA: RC TYPE I.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_DELETE
EXPORTING
FILENAME           = G_FILENAME
CHANGING
RC                 = RC
EXCEPTIONS
FILE_DELETE_FAILED = 1
CNTL_ERROR         = 2
ERROR_NO_GUI       = 3
FILE_NOT_FOUND     = 4
ACCESS_DENIED      = 5
UNKNOWN_ERROR      = 6
OTHERS             = 7.
IF SY-SUBRC <> 0.
LV_SUBRC = SY-SUBRC.
CONCATENATE: 'Could not delete the created file'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.

MESSAGE E001(00) WITH 'Could not delete the created file at :'
G_FILENAME 'RC:' LV_SUBRC.
ENDIF.

ENDFORM.                    " CHECK_EXTERNAL_FILENAME

*&---------------------------------------------------------------------*
*&      Form  RESET_EXT_GLOBAL_PARAMETER
*&---------------------------------------------------------------------*
FORM RESET_EXT_GLOBAL_PARAMETERS.

DATA: COUNTER(3) TYPE N,
MAX_PARAM_NO(3) TYPE N,
L_PARAMS LIKE LINE OF G_IT_PARAMS_VALUES,
PARAM_NAME(13) TYPE C,
TEXT TYPE STRING,
SY_SUBRC_CHAR(2) TYPE C.

*   Set parameter that recording has finished
SET PARAMETER ID 'PANAYA_SR25' FIELD SPACE.

SET PARAMETER ID 'PANAYA_SR20' FIELD SPACE.
SET PARAMETER ID 'PANAYA_SR21' FIELD SPACE.
SET PARAMETER ID 'PANAYA_SR22' FIELD SPACE.

ENDFORM.                    " RESET_EXT_GLOBAL_PARAMETER

*&---------------------------------------------------------------------*
*&      Form  ADD_TO_LOG
*&---------------------------------------------------------------------*
FORM ADD_TO_LOG USING
P_MSG            TYPE STRING
IV_DOWNLOAD_DATA TYPE FLAG.

DATA: MSG TYPE STRING.

* Build log first line
IF G_LOG_FILE_APPEND_MODE_CLIENT IS INITIAL.
APPEND '------------ Scenario Recorder Log -----------'
TO GT_LOG_DATA.
ENDIF.

* Build log line
CONCATENATE 'Date: ' SY-DATUM 'Time:' SY-UZEIT 'Message:' P_MSG
INTO MSG SEPARATED BY SPACE.
APPEND MSG TO GT_LOG_DATA.

* Save data to client
IF IV_DOWNLOAD_DATA <> ABAP_FALSE.
PERFORM ADD_DATA_TO_FILE_IN_CLIENT USING
GT_LOG_DATA
'X'
G_LOG_FILENAME
'Could not create log file in client.'
CHANGING
G_LOG_FILE_APPEND_MODE_CLIENT.

CLEAR : GT_LOG_DATA[].
ENDIF.
ENDFORM.                    " ADD_TO_LOG

*&---------------------------------------------------------------------*
*&      Form  add_log_to_xml
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ADD_LOG_TO_XML.

DATA : LOG_MESSAGE TYPE STRING,
LV_LOG_LINE TYPE STRING,
LV_SUBRC    TYPE STRING,
MSG         TYPE STRING.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'GUI_UPLOAD'
G_LOG_FILENAME 'Start of gui_upload execution'.

PERFORM APPEND_XML_TO_BUFFER USING '    <LOG>'.

* Flush log data to log file before xml log append
PERFORM ADD_TO_LOG USING '' GC_LOG_WRITE.

* Read log from file and add to XML
CALL FUNCTION 'GUI_UPLOAD'
EXPORTING
FILENAME                = G_LOG_FILENAME
TABLES
DATA_TAB                = G_XML_LOG_MESSAGES
EXCEPTIONS
FILE_OPEN_ERROR         = 1
FILE_READ_ERROR         = 2
NO_BATCH                = 3
GUI_REFUSE_FILETRANSFER = 4
INVALID_TYPE            = 5
NO_AUTHORITY            = 6
UNKNOWN_ERROR           = 7
BAD_DATA_FORMAT         = 8
HEADER_NOT_ALLOWED      = 9
SEPARATOR_NOT_ALLOWED   = 10
HEADER_TOO_LONG         = 11
UNKNOWN_DP_ERROR        = 12
ACCESS_DENIED           = 13
DP_OUT_OF_MEMORY        = 14
DISK_FULL               = 15
DP_TIMEOUT              = 16
OTHERS                  = 17.

IF SY-SUBRC = 0.
*   Get measures from log
PERFORM GET_MEASURES_FROM_LOG
TABLES G_XML_LOG_MESSAGES.

LOOP AT G_XML_LOG_MESSAGES INTO LV_LOG_LINE.

LOG_MESSAGE = '       <LOG '.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'INFO'
LV_LOG_LINE
CHANGING LOG_MESSAGE.

CONCATENATE  LOG_MESSAGE '/>' INTO LOG_MESSAGE.
PERFORM APPEND_XML_TO_BUFFER USING LOG_MESSAGE.

ENDLOOP.
ELSE.
LV_SUBRC = SY-SUBRC.
CONCATENATE : 'Failed to upload log file:'
G_LOG_FILENAME
'RC:' LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_FLUSH_LOG.
ENDIF.

PERFORM APPEND_XML_TO_BUFFER USING '    </LOG>'.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'GUI_UPLOAD'
G_LOG_FILENAME 'End of gui_upload execution'.

ENDFORM.                    " add_log_to_xml

*&---------------------------------------------------------------------*
*&      Form  CHECK_SHOW_TRAN_STAT
*&---------------------------------------------------------------------*
* We need not to show the transfer status in case it shows because
* external command where we do not want to see any messages. In ECC6
* SPS6 and lower - the parameter doesn't exist. In ECC6 when calling
* to Function Module with a non existing parameter -  a dump is shown.
* That's why we want to check it beforehand.
FORM CHECK_SHOW_TRAN_STAT CHANGING P_DOES_APPEAR.

DATA: FUPARAREF_REC TYPE FUPARAREF.

CLEAR P_DOES_APPEAR.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'FUPAPAREF'
'GUI_DOWNLOAD' 'Start reading fupaparef table'.

* Check if show transfer status parameter appears in GUI_DOWNLOAD
* function
SELECT SINGLE *
FROM FUPARAREF
INTO FUPARAREF_REC
WHERE FUNCNAME = 'GUI_DOWNLOAD'
AND R3STATE = 'A'
AND PARAMETER = 'SHOW_TRANSFER_STATUS'
AND PARAMTYPE = 'I'.

IF SY-SUBRC IS INITIAL.
P_DOES_APPEAR = 'X'.
ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'FUPAPAREF'
'GUI_DOWNLOAD' 'End reading fupaparef table'.

ENDFORM.                    " CHECK_SHOW_TRAN_STAT

*---------------------------------------------------------------------*
*       FORM GENERATE_FORMATS_FILE                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM GENERATE_CLIENT_DATA_FILE.

DATA: CLIENT_DATA_FILENAME TYPE STRING,
CLIENT_DATA_ITAB TYPE STRING_TAB,
CLIENT_DATA_LINE TYPE STRING,
TEMP_MODE,
WORKDIR TYPE STRING.

DATA: L_KRELEASE TYPE SYSAPRL,
L_KPATCH   TYPE SYCHAR05,
L_KCCOMPILATION(69) TYPE C,
L_KABAPLOAD(69) TYPE C,
L_KCAULOAD(69) TYPE C,
L_KMODE(69) TYPE C,
LV_DATASET_FAILED TYPE FLAG.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE
'***STARTED START MODE***' '' '***STARTED START MODE***'.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE '.data FILE' ''
'Start of .data file:user data,settings and user auth to .data file'.

CONCATENATE G_FILENAME '.data'
INTO CLIENT_DATA_FILENAME.

CONCATENATE 'UserDateFormat=' DATE_FORMAT INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'UserDecimalFormat=' DECIMAL_FORMAT INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'ScenarioRecorderVersion=' GENERAL_PART_VER
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'SAPVersion=' SY-SAPRL
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'CodeSAPVersion=' REL_SPECIFIC_VER
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

PERFORM CHECK_SERVER_PARAMETERS USING ABAP_FALSE
CHANGING CLIENT_DATA_ITAB.
PERFORM TRANSACTION_DEFINED     USING ABAP_FALSE
CHANGING CLIENT_DATA_ITAB.
PERFORM AUTHORITY_CHECK         USING ABAP_FALSE
CHANGING CLIENT_DATA_ITAB
LV_DATASET_FAILED.
PERFORM CHECK_GUI_AUTH          USING ABAP_FALSE
CHANGING CLIENT_DATA_ITAB.">4.7

* Check the user file access ability only if he has auth for it
IF LV_DATASET_FAILED IS INITIAL.
*   Check server files access - temp create + write + read +delete
PERFORM CHECK_SERVER_FILE_ACCESS CHANGING CLIENT_DATA_ITAB.
ENDIF.

PERFORM GET_KERNEL_DATA CHANGING L_KRELEASE
L_KPATCH
L_KCCOMPILATION
L_KABAPLOAD
L_KCAULOAD
L_KMODE.

CONCATENATE 'KernelRelease=' L_KRELEASE
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'Compilation=' L_KCCOMPILATION
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'KernelPatch=' L_KPATCH
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'AbapLoad=' L_KABAPLOAD
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'CUALoad=' L_KCAULOAD
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

CONCATENATE 'Mode=' L_KMODE
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CLIENT_DATA_ITAB.

PERFORM GET_SYSTEM_VERSION CHANGING CLIENT_DATA_ITAB.

PERFORM ADD_DATA_TO_FILE_IN_CLIENT  USING
CLIENT_DATA_ITAB
'X'
CLIENT_DATA_FILENAME
'Error while downloading format file to client.'
CHANGING
TEMP_MODE.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE '.data FILE' ''
'End of .data file data fill and download'.

ENDFORM.                    " create_formats_file
*&---------------------------------------------------------------------*
*&      Form  GET_KERNEL_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM GET_KERNEL_DATA  CHANGING P_KRELEASE
P_KPATCH
P_KCCOMPILATION
P_KABAPLOAD
P_KCAULOAD
P_KMODE.

TYPES: BEGIN OF T_KERNEL_VERSION,
KEY(21) TYPE C,
DATA(69) TYPE C,
END OF T_KERNEL_VERSION.

DATA: LT_KERNEL_VERSION TYPE TABLE OF T_KERNEL_VERSION
WITH HEADER LINE,
LS_KERNEL_VERSION TYPE T_KERNEL_VERSION.

CALL 'SAPCORE' ID 'ID' FIELD 'VERSION'
ID 'TABLE' FIELD LT_KERNEL_VERSION-*SYS*.

CLEAR LS_KERNEL_VERSION.
READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 12.
P_KRELEASE = LS_KERNEL_VERSION-DATA.

CLEAR LS_KERNEL_VERSION.
READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 15.
P_KPATCH = LS_KERNEL_VERSION-DATA.

CLEAR LS_KERNEL_VERSION.
READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 14.
P_KCCOMPILATION = LS_KERNEL_VERSION-DATA.

CLEAR LS_KERNEL_VERSION.
READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 20.
P_KABAPLOAD = LS_KERNEL_VERSION-DATA.

CLEAR LS_KERNEL_VERSION.
READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 21.
P_KCAULOAD = LS_KERNEL_VERSION-DATA.

CLEAR LS_KERNEL_VERSION.
READ TABLE LT_KERNEL_VERSION INTO LS_KERNEL_VERSION INDEX 22.
P_KMODE = LS_KERNEL_VERSION-DATA.

ENDFORM.                    " GET_KERNEL_DATA
*---------------------------------------------------------------------*
*       FORM check_server_parameters                                  *
*---------------------------------------------------------------------*
* Check server settings for recorder program if incorrect add to the
* log .data file
*---------------------------------------------------------------------*
*  -->  CT_CLIENT_DATA_ITAB                                           *
*---------------------------------------------------------------------*
FORM CHECK_SERVER_PARAMETERS
USING    IV_PERFORM_CHECKS   TYPE FLAG
CHANGING CT_CLIENT_DATA_ITAB TYPE STRING_TAB.

DATA :
CLIENT_DATA_LINE   TYPE STRING,
LV_PARAMETER_NAME  LIKE TPFET-PARNAME ,
LV_PARAMETER_VALUE LIKE TPFET-PVALUE.

* Check that the parameters needed for the recorder were set correctly
* sapgui/user_scripting
LV_PARAMETER_NAME = 'sapgui/user_scripting'.
CLEAR : LV_PARAMETER_VALUE , CLIENT_DATA_LINE.
CALL 'C_SAPGPARAM' ID 'NAME'  FIELD LV_PARAMETER_NAME
ID 'VALUE' FIELD LV_PARAMETER_VALUE.

IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE
'sapgui/user_scripting='
LV_PARAMETER_VALUE
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
IF LV_PARAMETER_VALUE <> 'TRUE'.
CONCATENATE 'System parameter'
LV_PARAMETER_NAME
'is not defined correctly'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

* sapgui/user_scripting_disable_recording
LV_PARAMETER_NAME = 'sapgui/user_scripting_disable_recording'.
CLEAR : LV_PARAMETER_VALUE , CLIENT_DATA_LINE.
CALL 'C_SAPGPARAM' ID 'NAME'  FIELD LV_PARAMETER_NAME
ID 'VALUE' FIELD LV_PARAMETER_VALUE.

IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE
'sapgui/user_scripting_disable_recording='
LV_PARAMETER_VALUE
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
IF LV_PARAMETER_VALUE <> 'FALSE'.
CONCATENATE 'System parameter'
LV_PARAMETER_NAME
'is not defined correctly'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

* sapgui/user_scripting_set_readonly
LV_PARAMETER_NAME = 'sapgui/user_scripting_set_readonly'.
CLEAR : LV_PARAMETER_VALUE , CLIENT_DATA_LINE.
CALL 'C_SAPGPARAM' ID 'NAME'  FIELD LV_PARAMETER_NAME
ID 'VALUE' FIELD LV_PARAMETER_VALUE.

IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE
'sapgui/user_scripting_set_readonly='
LV_PARAMETER_VALUE
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
IF LV_PARAMETER_VALUE <> 'FALSE'.
CONCATENATE 'System parameter'
LV_PARAMETER_NAME
'is not defined correctly'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

* rdisp/TRACE_LOGGING
LV_PARAMETER_NAME = 'rdisp/TRACE_LOGGING'.
CLEAR : LV_PARAMETER_VALUE , CLIENT_DATA_LINE.
CALL 'C_SAPGPARAM' ID 'NAME'  FIELD LV_PARAMETER_NAME
ID 'VALUE' FIELD LV_PARAMETER_VALUE.

IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE
'rdisp/TRACE_LOGGING='
LV_PARAMETER_VALUE
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
IF LV_PARAMETER_VALUE <> 'on, 99 m'.
CONCATENATE 'System parameter'
LV_PARAMETER_NAME
'is not defined correctly in RZ11 transaction'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

ENDFORM .
*&---------------------------------------------------------------------*
*&      Form  transaction_defined
*&---------------------------------------------------------------------*
*       Check ZP_RECORD transaction defined correctly
*----------------------------------------------------------------------*
*      <--P_CLIENT_DATA_ITAB  text
*----------------------------------------------------------------------*
FORM TRANSACTION_DEFINED
USING    IV_PERFORM_CHECKS   TYPE FLAG
CHANGING CT_CLIENT_DATA_ITAB TYPE STRING_TAB.
CONSTANTS : LC_REP_TRAN LIKE TSTC-CINFO VALUE '80',
LC_VAR_TRAN LIKE TSTC-CINFO VALUE '10'.
DATA : CLIENT_DATA_LINE TYPE STRING,
LV_CINFO         LIKE TSTC-CINFO.

SELECT SINGLE PGMNA CINFO
FROM TSTC
INTO (GV_PGMNA, LV_CINFO)
WHERE TCODE = 'ZP_RECORD'.

* Transaction exists
IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'RecorderTransactionDefined='
'FALSE'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Transaction ZP_RECORD is ' 'missing'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ELSE.
*   80  hex - report transaction
IF LV_CINFO O LC_REP_TRAN AND
LV_CINFO Z LC_VAR_TRAN.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'ReportTransaction='
'TRUE'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ELSE.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'ReportTransaction='
'FALSE'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
IF LV_CINFO O LC_VAR_TRAN.
CONCATENATE 'Transaction ZP_RECORD can not be defined'
'as variant transaction'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Transaction ZP_RECORD is not defined'
'as report transaction'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.
ENDIF.

*   Transaction program is the current program
IF GV_PGMNA <> SY-REPID        AND
IV_PERFORM_CHECKS <> ABAP_FALSE.

CLEAR : CLIENT_DATA_LINE.
CONCATENATE 'The main program of transaction ZP_RECORD'
'is not the current program'
SY-REPID
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

ENDFORM.                    " transaction_defined
*&---------------------------------------------------------------------*
*&      Form  authority_check
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->IV_PERFORM_CHECKS    text
*      -->CT_CLIENT_DATA_ITAB  text
*----------------------------------------------------------------------*
FORM AUTHORITY_CHECK
USING IV_PERFORM_CHECKS TYPE FLAG
CHANGING CT_CLIENT_DATA_ITAB TYPE STRING_TAB
EV_DATASET_FAILED TYPE FLAG.

DATA :
CLIENT_DATA_LINE LIKE LINE OF CT_CLIENT_DATA_ITAB,
LV_SECU          TYPE SECU.

* S_TCODE - object
CLEAR : CLIENT_DATA_LINE.
AUTHORITY-CHECK OBJECT 'S_TCODE'
ID 'TCD' FIELD 'ZP_RECORD'.
IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'AuthorizationFailed1='
'Object: S_TCODE,'
'Transacton code: ZP_RECORD'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_TCODE'
'Transacton code: ZP_RECORD'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

* S_ADMI_FCD - object
CLEAR : CLIENT_DATA_LINE.
AUTHORITY-CHECK OBJECT 'S_ADMI_FCD'
ID 'S_ADMI_FCD' FIELD 'PADM'.
IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'AuthorizationFailed2='
'Object: S_ADMI_FCD,'
'Admin function: PADM'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_ADMI_FCD'
'Admin function: PADM'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

* S_DATASET - object , checked for * and
* current zp_record report program
* only if both fail the authority check fail
CLEAR : CLIENT_DATA_LINE.
AUTHORITY-CHECK OBJECT 'S_DATASET'
ID 'PROGRAM'  FIELD '*'
ID 'ACTVT'    FIELD '*'
ID 'FILENAME' FIELD '*'.
IF SY-SUBRC <> 0.
AUTHORITY-CHECK OBJECT 'S_DATASET'
ID 'PROGRAM'  FIELD GV_PGMNA
ID 'ACTVT'    FIELD '*'
ID 'FILENAME' FIELD '*'.

IF SY-SUBRC <> 0.
*     The user doesnt have server file access auth
*     further validation checks on server access
*     will not be made
EV_DATASET_FAILED = ABAP_TRUE.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'AuthorizationFailed3='
'Object: S_DATASET'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_DATASET'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.
ENDIF.

* S_PROGRAM - object
* checked both for * program group and zp_record report auth group
* only if both are not set for the user the auth is failed

* Get zp_record report auth group
SELECT SINGLE SECU
FROM TRDIR
INTO LV_SECU
WHERE NAME = GV_PGMNA.

* BTCSUBMIT action is not set for * and for ZPNY
CLEAR : CLIENT_DATA_LINE .
AUTHORITY-CHECK OBJECT 'S_PROGRAM'
ID 'P_GROUP' FIELD '*'
ID 'P_ACTION' FIELD 'BTCSUBMIT'.

IF SY-SUBRC <> 0.
AUTHORITY-CHECK OBJECT 'S_PROGRAM'
ID 'P_GROUP' FIELD LV_SECU
ID 'P_ACTION' FIELD 'BTCSUBMIT'.

IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'AuthorizationFailed7='
'Object: S_PROGRAM,'
'Action: BTCSUBMIT'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_PROGRAM'
'Action: BTCSUBMIT'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.
ENDIF.

* SUBMIT action is not set for * and for ZPNY
CLEAR : CLIENT_DATA_LINE.
AUTHORITY-CHECK OBJECT 'S_PROGRAM'
ID 'P_GROUP' FIELD '*'
ID 'P_ACTION' FIELD 'SUBMIT'.

IF SY-SUBRC <> 0.
AUTHORITY-CHECK OBJECT 'S_PROGRAM'
ID 'P_GROUP' FIELD LV_SECU
ID 'P_ACTION' FIELD 'SUBMIT'.

IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'AuthorizationFailed8='
'Object: S_PROGRAM,'
'Action: SUBMIT'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_PROGRAM'
'Action: SUBMIT'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.
ENDIF.

* VARIANT action is not set for * and for ZPNY
CLEAR : CLIENT_DATA_LINE.
AUTHORITY-CHECK OBJECT 'S_PROGRAM'
ID 'P_GROUP' FIELD '*'
ID 'P_ACTION' FIELD 'VARIANT'.

IF SY-SUBRC <> 0.
AUTHORITY-CHECK OBJECT 'S_PROGRAM'
ID 'P_GROUP' FIELD LV_SECU
ID 'P_ACTION' FIELD 'VARIANT'.

IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'AuthorizationFailed9='
'Object: S_PROGRAM,'
'Action: VARIANT'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_PROGRAM'
'Action: VARIANT'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.
ENDIF.

* S_C_FUNCT - object
CLEAR : CLIENT_DATA_LINE.
AUTHORITY-CHECK OBJECT 'S_C_FUNCT'
ID 'PROGRAM'   FIELD GV_PGMNA
ID 'ACTVT'     FIELD '16'
ID 'CFUNCNAME' FIELD 'SYSTEM'.

IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = SPACE.
CONCATENATE 'AuthorizationFailed10='
'Object: S_C_FUNCT,'
'Program:'
GV_PGMNA
',Activity: 16,'
'C routine: SYSTEM'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_C_FUNCT'
'Program:'
GV_PGMNA
'Activity: 16'
'C routine: SYSTEM'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

ENDFORM." authority_check
*&---------------------------------------------------------------------*
*&      Form  validation_checks
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM VALIDATION_CHECKS.

DATA: LT_STRING_TAB TYPE STRING_TAB,
LS_STRING LIKE LINE OF LT_STRING_TAB,
LV_ERRORS TYPE I,
LV_DATASET_FAILED TYPE FLAG.

PERFORM TRANSACTION_DEFINED     USING ABAP_TRUE
CHANGING LT_STRING_TAB .
PERFORM CHECK_SERVER_PARAMETERS USING ABAP_TRUE
CHANGING LT_STRING_TAB .
PERFORM AUTHORITY_CHECK         USING ABAP_TRUE
CHANGING LT_STRING_TAB
LV_DATASET_FAILED.
PERFORM CHECK_GUI_AUTH          USING ABAP_TRUE
CHANGING LT_STRING_TAB .  " > 4.7
* Check that 'Low-Speed Connection' is not turned on
PERFORM CHECK_WAN_FLAG USING ABAP_FALSE
CHANGING LT_STRING_TAB .

DESCRIBE TABLE LT_STRING_TAB LINES LV_ERRORS.

IF LV_ERRORS > 0.

WRITE : / ICON_INCOMPLETE AS ICON ,
'SAP System not setup correctly for test recording and playback'.
NEW-LINE.
WRITE : '  ',
'Please consult the installation guide',
'to complete the following settings:'.
ULINE.

LOOP AT LT_STRING_TAB INTO LS_STRING.
WRITE : LS_STRING.
NEW-LINE.
ENDLOOP.
ELSE.
WRITE : / ICON_CHECKED AS ICON ,
'SAP System is setup correctly for test recording and playback'.
ULINE.
ENDIF.
CLEAR : LT_STRING_TAB[].
ENDFORM.                    " validation_checks
*&---------------------------------------------------------------------*
*&      Form  SAVE_UPARAMS_TO_ITAB
*&---------------------------------------------------------------------*
*       Saves the user parameters from the session to an iTab
*&---------------------------------------------------------------------*
FORM SAVE_UPARAMS_TO_ITAB TABLES P_USERS_PARAMS
USING P_GROUP_ID.


DATA: L_PARAM_VALUE TYPE PARAMS_PER_GROUP.
DATA: IT_PARAMS TYPE TABLE OF TPARA WITH HEADER LINE,
MSG TYPE STRING.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'SAVE USER PARAMETERS' ''
'start of read current user paarmeters, go over tpara'.

PERFORM ADD_TO_LOG USING 'Saving global parameters' GC_LOG_WRITE.

* Get the parameter ids
SELECT * FROM TPARA INTO TABLE IT_PARAMS.
* Save the parameters' values and clear them.
LOOP AT IT_PARAMS.
CLEAR L_PARAM_VALUE.
GET PARAMETER ID IT_PARAMS-PARAMID FIELD L_PARAM_VALUE-VALUE.
IF SY-SUBRC IS INITIAL.
*     save paramtests into global table.
L_PARAM_VALUE-GROUP_ID = P_GROUP_ID.
L_PARAM_VALUE-PID = IT_PARAMS-PARAMID.
APPEND L_PARAM_VALUE TO P_USERS_PARAMS.
ENDIF.
ENDLOOP.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'SAVE USER PARAMETERS' ''
'end of read current user parameters'.

ENDFORM.                    "SAVE_USER_PARAMETERS
*&---------------------------------------------------------------------*
*&      Form  ADD_UPARAMS_TO_XML
*&---------------------------------------------------------------------*
*       Add the user parameters section to the xml
*----------------------------------------------------------------------*
FORM ADD_UPARAMS_TO_XML TABLES P_USER_PARAMS TYPE PARAM_GROUP_TAB.

DATA:
L_XML_DATA_WA TYPE STRING,
XML_DATA_TAB TYPE TABLE OF STRING.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE
'GENERATE UPARAM XML' '' 'GENERATE UPARAM XML'.

* Create a string table containing the user parametesr xml section
PERFORM GENERATE_UPARAM_XML_SECTION TABLES XML_DATA_TAB
P_USER_PARAMS.
* Add user parameters section to the xml
LOOP AT XML_DATA_TAB INTO L_XML_DATA_WA.
PERFORM APPEND_XML_TO_BUFFER USING L_XML_DATA_WA.
ENDLOOP.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE
'GENERATE UPARAM XML' '' 'GENERATE UPARAM XML'.

ENDFORM.                    "ADD_UPARAMS_TO_XML

*&---------------------------------------------------------------------*
*&      Form  READ_UPARAMS_FROM_FILE
*&---------------------------------------------------------------------*
*       Read user parameters file into an iTab
*----------------------------------------------------------------------*
FORM READ_UPARAMS_FROM_FILE TABLES P_USER_PARAMETERS
USING P_FILENAME
P_DELETE_FILE
P_WRITE_TO_FILE.

DATA: S_FILENAME TYPE STRING,
T_USER_PARAMS_TAB TYPE TABLE OF STRING,
T_USER_PARAM_WA TYPE STRING,
CURR_USERS_PARAM TYPE PARAMS_PER_GROUP,
SY_SUBRC_CHAR(2) TYPE C,
RC               TYPE I,
TEXT             TYPE STRING.

S_FILENAME = P_FILENAME.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'GUI_UPLOAD'
S_FILENAME 'Start of gui_upload of user parameters data'.

CONCATENATE 'Read User Parameters from ' P_FILENAME INTO TEXT.
PERFORM ADD_TO_LOG USING TEXT P_WRITE_TO_FILE.

* Read the parameters that were passed by a file from the player
* into a global table, inorder to restore the state of the user
* parameters state at recording.
CALL FUNCTION 'GUI_UPLOAD'
EXPORTING
FILENAME                = S_FILENAME
TABLES
DATA_TAB                = T_USER_PARAMS_TAB
*           DATA_TAB                = G_CURR_USERS_PARAMS
EXCEPTIONS
FILE_OPEN_ERROR         = 1
FILE_READ_ERROR         = 2
NO_BATCH                = 3
GUI_REFUSE_FILETRANSFER = 4
INVALID_TYPE            = 5
NO_AUTHORITY            = 6
UNKNOWN_ERROR           = 7
BAD_DATA_FORMAT         = 8
HEADER_NOT_ALLOWED      = 9
SEPARATOR_NOT_ALLOWED   = 10
HEADER_TOO_LONG         = 11
UNKNOWN_DP_ERROR        = 12
ACCESS_DENIED           = 13
DP_OUT_OF_MEMORY        = 14
DISK_FULL               = 15
DP_TIMEOUT              = 16
OTHERS                  = 17.

SY_SUBRC_CHAR = SY-SUBRC.
PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'GUI_UPLOAD'
S_FILENAME 'End of gui_upload user parameters'.

* If error occured during the read of the file, we do not want to fail
* the process at this point because the recording can actually be
* completed. An error will be added to the log file
IF SY_SUBRC_CHAR <> 0.
CONCATENATE
'Reading the global parameters file from the player failed so they'
'will not '
'be updated properally. The recording will be completed '
'but we recommend to restart current session. '
'Filename: ' P_FILENAME '.Error code:'
SY_SUBRC_CHAR
INTO TEXT SEPARATED BY SPACE.

PERFORM ADD_TO_LOG USING TEXT GC_FLUSH_LOG.

ELSEIF P_DELETE_FILE = 'X'.
PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'DELETE FILE' S_FILENAME
'start delete parameters file'.

*   Delete the file after reading it.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>FILE_DELETE
EXPORTING
FILENAME           = S_FILENAME
CHANGING
RC                 = RC
EXCEPTIONS
FILE_DELETE_FAILED = 1
CNTL_ERROR         = 2
ERROR_NO_GUI       = 3
FILE_NOT_FOUND     = 4
ACCESS_DENIED      = 5
UNKNOWN_ERROR      = 6
OTHERS             = 7.

IF SY-SUBRC <> 0.
SY_SUBRC_CHAR = SY-SUBRC.
CONCATENATE
'Failed deleting parameters file. '
'Filename: ' S_FILENAME
'Error code:' SY_SUBRC_CHAR
INTO TEXT SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING TEXT P_WRITE_TO_FILE.
ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'DELETE FILE' S_FILENAME
'end delete parameters file'.
ENDIF.

LOOP AT T_USER_PARAMS_TAB INTO T_USER_PARAM_WA.
SPLIT T_USER_PARAM_WA AT G_DELIMITER
INTO CURR_USERS_PARAM-GROUP_ID
CURR_USERS_PARAM-PID
CURR_USERS_PARAM-VALUE.
IF CURR_USERS_PARAM-VALUE EQ G_DELIMITER.
CLEAR CURR_USERS_PARAM-VALUE.
ENDIF.
APPEND CURR_USERS_PARAM TO P_USER_PARAMETERS.
ENDLOOP.

ENDFORM.                    "READ_UPARAMS_FROM_FILE
*&---------------------------------------------------------------------*
*&      Form  SET_PLAYBACK_UPARAMS
*&---------------------------------------------------------------------*
*       Set User Parameters in SAP memory
*----------------------------------------------------------------------*
FORM SET_UPARAMS_IN_MEMORY TABLES P_USER_PARAMS
USING  P_WRITE_TO_FILE.

DATA: IS_USER_PARAM TYPE PARAMS_PER_GROUP,
LS_PARAM_VALUE TYPE PARAM_VALUE.
PERFORM ADD_TO_LOG USING 'Set user parameters in SAP memory'
P_WRITE_TO_FILE.
* Set the user parameters that were read from the player
LOOP AT P_USER_PARAMS INTO IS_USER_PARAM.
LS_PARAM_VALUE-ID = IS_USER_PARAM-PID.
LS_PARAM_VALUE-VALUE = IS_USER_PARAM-VALUE.
PERFORM SET_PARAMETER USING LS_PARAM_VALUE.
ENDLOOP.

* The F4 screens are recorded in the trace file only if they are not
* ActiveX screens.Therefore regardless to what the users have we always
* set this to no activex.
SET PARAMETER ID 'F4METHOD' FIELD 'NoActiveX'.
ENDFORM.                    "SET_PLAYBACK_UPARAMS
*&---------------------------------------------------------------------*
*&      Form  ADD_TO_UPARAMS_FILE
*&---------------------------------------------------------------------*
*       writes user parameters from an itab to a file
*----------------------------------------------------------------------*
*      -->P_USER_PARAMS  text
*      -->P_FILENAME     text
*----------------------------------------------------------------------*
FORM ADD_TO_UPARAMS_FILE TABLES P_USER_PARAMS
USING P_FILENAME.
DATA: DATA_TAB TYPE STRING_TAB,
DATA_WA TYPE STRING,
CURR_TIME TYPE STRING,
R_PARAMS_VALUES LIKE LINE OF G_USERS_PARAMS,
L_GLOB_PARAMS_FILE_APPEND_MODE.

* Go over the Global Parameters that were cleared and
* out them into the ITAB that will be downloaded to file
LOOP AT P_USER_PARAMS INTO R_PARAMS_VALUES.
CONCATENATE R_PARAMS_VALUES-GROUP_ID G_DELIMITER
R_PARAMS_VALUES-PID G_DELIMITER
R_PARAMS_VALUES-VALUE
INTO DATA_WA.
APPEND DATA_WA TO DATA_TAB.
ENDLOOP.

* Download file
PERFORM ADD_DATA_TO_FILE_IN_CLIENT USING
DATA_TAB
'X'

P_FILENAME"G_UPARAMS_PASS_VAL_FILENAME
'Could not create global parameters file in client.'
CHANGING
G_APPEND_USER_PARAMS.
ENDFORM.                    "ADD_TO_USER_PARAMS_FILE
*&---------------------------------------------------------------------*
*&      Form  clear_uparams_in_memory
*&---------------------------------------------------------------------*
*       Clears all the users parameters in the SAP memory
*----------------------------------------------------------------------*
FORM CLEAR_UPARAMS_IN_MEMORY USING P_WRITE_TO_FILE.
DATA: IS_PARAM_VALUE TYPE PARAM_VALUE.
DATA: IT_PARAMS TYPE TABLE OF TPARA WITH HEADER LINE,
MSG TYPE STRING.

PERFORM ADD_TO_LOG USING 'Clearing User Parameters' P_WRITE_TO_FILE.

* Get the parameter ids
SELECT * FROM TPARA INTO TABLE IT_PARAMS.
* Save the parameters' values and clear them.
LOOP AT IT_PARAMS.
CLEAR IS_PARAM_VALUE.
GET PARAMETER ID IT_PARAMS-PARAMID FIELD IS_PARAM_VALUE-VALUE.
IF SY-SUBRC IS INITIAL.
*     Clear parameters if needed
SET PARAMETER ID IT_PARAMS-PARAMID FIELD SPACE.
ENDIF.
ENDLOOP.
ENDFORM.                    "HANDLE_UPARAMS_BEFORE_CHANGE

*&---------------------------------------------------------------------*
*&      Form  SAVE_PAUSE_UPARAMS_TO_FILE
*&---------------------------------------------------------------------*
* Creates an xml file withe the user parameters
*----------------------------------------------------------------------*
FORM CREATE_PAUSE_UPARAMS_XML_FILE USING P_WRITE_TO_FILE.

DATA: L_IT_PARAMS_VALUES TYPE PARAM_GROUP_TAB.
DATA: XML_DATA_WA TYPE STRING,
XML_DATA_TAB TYPE STRING_TAB,
L_ENCODING TYPE STRING.
DATA: IS_PARAM_VALUE TYPE PARAMS_PER_GROUP.
DATA: IT_PARAMS TYPE TABLE OF TPARA WITH HEADER LINE,
MSG TYPE STRING.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'CREATE PAUSE USER PARAMETERS' ''
'Start of pause parms,read user params,go over tpara to file'.

PERFORM ADD_TO_LOG USING 'Saving global parameters when pausing'
P_WRITE_TO_FILE.

* Get the paramterers values
* ===========================
* Get the parameter ids
SELECT * FROM TPARA INTO TABLE IT_PARAMS.
* Save the parameters' values and clear them.
LOOP AT IT_PARAMS.
CLEAR IS_PARAM_VALUE.
GET PARAMETER ID IT_PARAMS-PARAMID FIELD IS_PARAM_VALUE-VALUE.
IF SY-SUBRC IS INITIAL.
IS_PARAM_VALUE-PID = IT_PARAMS-PARAMID.
APPEND IS_PARAM_VALUE TO L_IT_PARAMS_VALUES.
ENDIF.
ENDLOOP.


* Build the xml header
* ====================
* Get the encoding
PERFORM GET_CURRENT_ENCODING CHANGING L_ENCODING.

* Add the XML definitions
CONCATENATE '<?xml version="1.0" encoding="'
L_ENCODING
'"?>'
INTO XML_DATA_WA.
APPEND XML_DATA_WA TO XML_DATA_TAB.

XML_DATA_WA = '<ROOT>'.
APPEND XML_DATA_WA TO XML_DATA_TAB.

* Build the xml body
* ==================
PERFORM GENERATE_UPARAM_XML_SECTION TABLES XML_DATA_TAB
L_IT_PARAMS_VALUES.

XML_DATA_WA = '</ROOT>'.
APPEND XML_DATA_WA TO XML_DATA_TAB.

PERFORM ADD_TO_LOG USING 'Writing pause XML to client'
P_WRITE_TO_FILE.
* Download xml to file
* ====================
PERFORM ADD_DATA_TO_FILE_IN_CLIENT USING
XML_DATA_TAB
'X'
G_PAUSE_XML_FILENAME
'Could not create pause global parameters file in client.'
CHANGING
G_APPEND_USER_PARAMS.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'CREATE PAUSE USER PARAMETERS' ''
'end of create user pause parameters'.

ENDFORM.                    " save_pause_user_parameters

*&---------------------------------------------------------------------*
*&      Form  GENERATE_UPARMS_FILENAMES
*&---------------------------------------------------------------------*
* Create the general file names from the incoming file name
*----------------------------------------------------------------------*
FORM GENERATE_UPARAMS_FILENAMES.
* If the location is good - create the log and global parameters
* filenames
CONCATENATE G_FILENAME '.log' INTO G_LOG_FILENAME.

* G_RESUME_PAUSE_FILENAME - file received from the player when resuming
*     a playback after pasuing it. In use in start transaction & P mode.
CONCATENATE G_FILENAME '.paused_params' INTO G_RESUME_PAUSE_FILENAME.
* G_PAUSE_XML_FILENAME - file sent to the player when pause was pressed.
*     In use in end transaction & P mode.
CONCATENATE G_FILENAME '.paused.xml' INTO G_PAUSE_XML_FILENAME.
* DIRECTORY - used to hold user parameters data files that will be
*     collected and its data will be writen into the main xml file.
*     In use both in start & end transactions for all modes
CONCATENATE G_FILENAME '_params\' INTO G_RECORDING_PARAM_DIRECTORY.
* RECOTDING.PARAMS - is written to the directory on start transaction
*     and read back at the end when the hole directory files are read
CONCATENATE G_RECORDING_PARAM_DIRECTORY 'recording.params' INTO
G_RECORDING_PARAM_FILENAME.
ENDFORM.                        "GENERATE_UPARMS_FILENAMES

*&---------------------------------------------------------------------*
*&      Form  GENERATE_UPARAM_XML_SECTION
*&---------------------------------------------------------------------*
* This form prepares a string table with the user parameters xml section
*----------------------------------------------------------------------*
FORM GENERATE_UPARAM_XML_SECTION TABLES P_XML_DATA
P_PARAMS_TAB TYPE
PARAM_GROUP_TAB.
DATA: PARAM_WA TYPE PARAMS_PER_GROUP,
XML_DATA_WA TYPE STRING.

* Start the user parameters section in the xml.
APPEND '<UPARAMS>' TO P_XML_DATA.

* Run through the user parameters table received, and create an xml tag
* for each one.
LOOP AT P_PARAMS_TAB INTO PARAM_WA.
*   Start a new group section
AT NEW GROUP_ID.
CONCATENATE '<PARAMGRP ID="' PARAM_WA-GROUP_ID '">' INTO
XML_DATA_WA.
APPEND XML_DATA_WA TO P_XML_DATA.
CLEAR XML_DATA_WA.
ENDAT.
*   Create the parameter tag
XML_DATA_WA = '<PARAMETER '.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'PID' PARAM_WA-PID
CHANGING XML_DATA_WA.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG USING 'VALUE' PARAM_WA-VALUE
CHANGING XML_DATA_WA.
CONCATENATE XML_DATA_WA '/>' INTO XML_DATA_WA.

APPEND XML_DATA_WA TO P_XML_DATA.
*   Close the group id section
AT END OF GROUP_ID.
APPEND '</PARAMGRP>' TO P_XML_DATA.
ENDAT.
ENDLOOP.
* Close the user parameters section.
APPEND '</UPARAMS>' TO P_XML_DATA.
ENDFORM.                        "generate_uparam_xml_section

*&---------------------------------------------------------------------*
*&      Form  RESTORE_UPARAMS
*&---------------------------------------------------------------------*
* reads a file of user parameters and sets it in the SAP memory
*----------------------------------------------------------------------*
FORM RESTORE_UPARAMS USING P_FILENAME
P_DELETE_FILE
P_WRITE_TO_FILE.

DATA: L_CURR_USERS_PARAMS TYPE PARAM_GROUP_TAB WITH HEADER LINE.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'RESTORE USER PARAMETERS' ''
'start of restore user parameters from file'.

PERFORM CLEAR_UPARAMS_IN_MEMORY USING GC_LOG_WRITE.

* Read the parameters sent from file
PERFORM READ_UPARAMS_FROM_FILE  TABLES L_CURR_USERS_PARAMS
USING  P_FILENAME
P_DELETE_FILE
GC_LOG_WRITE.

* set the parameters read from the file
PERFORM SET_UPARAMS_IN_MEMORY TABLES L_CURR_USERS_PARAMS
USING  P_WRITE_TO_FILE.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'RESTORE USER PARAMETERS' ''
'end of restore user parameters'.

ENDFORM.                    "RESTORE_UPARAMS
*&---------------------------------------------------------------------*
*&      Form  READ_USED_UPARAMS_FROM_DIRECTORY
*&---------------------------------------------------------------------*
*       reads all files from a given directory into an itab and deletes
*       the files and the directory
*----------------------------------------------------------------------*
FORM READ_UPARAMS_FROM_DIRECTORY TABLES P_UPARAMS
USING  P_DIRECTORY
P_WRITE_TO_FILE.

DATA: L_CURR_USERS_PARAMS TYPE PARAM_GROUP_TAB WITH HEADER LINE,
SY_SUBRC_CHAR(2) TYPE C,
FILE_TAB         TYPE TABLE OF SDOKPATH,
DIR_TAB          TYPE TABLE OF SDOKPATH,
FILE             TYPE SDOKPATH,
FULL_PATH        TYPE STRING,
RC               TYPE I,
FILE_COUNT       TYPE I,
DELETE_FILE      TYPE C VALUE 'X',
TEXT             TYPE STRING.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'READ USER PARAMETERS FROM DIRECTORY' ''
'start read user parameters'.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'READ FILES FROM DIRECTORY' ''
'start read parameter files from directory'.

* Get all the files in the directory
CALL METHOD CL_GUI_FRONTEND_SERVICES=>DIRECTORY_LIST_FILES
EXPORTING
DIRECTORY                   = P_DIRECTORY
CHANGING
FILE_TABLE                  = FILE_TAB
COUNT                       = FILE_COUNT
EXCEPTIONS
CNTL_ERROR                  = 1
DIRECTORY_LIST_FILES_FAILED = 2
WRONG_PARAMETER             = 3
ERROR_NO_GUI                = 4
OTHERS                      = 5.

IF SY-SUBRC <> 0.
SY_SUBRC_CHAR = SY-SUBRC.
CONCATENATE 'Error while getting files from directory: ' P_DIRECTORY
' - Error code: ' SY_SUBRC_CHAR INTO TEXT.
PERFORM ADD_TO_LOG USING TEXT P_WRITE_TO_FILE.
ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'READ FILES FROM DIRECTORY' ''
'end read parameter files from directory'.

* Go over the files and read them
LOOP AT FILE_TAB INTO FILE.
CONCATENATE G_RECORDING_PARAM_DIRECTORY FILE INTO FULL_PATH.

CLEAR L_CURR_USERS_PARAMS[].

PERFORM READ_UPARAMS_FROM_FILE  TABLES L_CURR_USERS_PARAMS
USING FULL_PATH
DELETE_FILE
P_WRITE_TO_FILE.

APPEND LINES OF L_CURR_USERS_PARAMS TO P_UPARAMS.
ENDLOOP.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'DELETE DIRECTORY'
P_DIRECTORY
'start delete parameters directory'.

* Delete the directory
CALL METHOD CL_GUI_FRONTEND_SERVICES=>DIRECTORY_DELETE
EXPORTING
DIRECTORY               = P_DIRECTORY
CHANGING
RC                      = RC
EXCEPTIONS
DIRECTORY_DELETE_FAILED = 1
CNTL_ERROR              = 2
ERROR_NO_GUI            = 3
PATH_NOT_FOUND          = 4
DIRECTORY_ACCESS_DENIED = 5
UNKNOWN_ERROR           = 6
OTHERS                  = 7.

IF SY-SUBRC <> 0.
SY_SUBRC_CHAR = SY-SUBRC.
CONCATENATE 'Error while deleting directory: ' P_DIRECTORY
' - Error code: ' SY_SUBRC_CHAR INTO TEXT.
PERFORM ADD_TO_LOG USING TEXT P_WRITE_TO_FILE.
ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'DELETE DIRECTORY' ''
'end delete parameters directory'.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'READ USER PARAMETERS FROM DIRECTORY'
P_DIRECTORY
'end read user parameters'.

ENDFORM.                    "READ_USED_UPARAMS
*&---------------------------------------------------------------------*
*&      Form  fill_measurement
*&---------------------------------------------------------------------*
*       fill measurement log
*----------------------------------------------------------------------*
*      -->iv_start       flag
*      -->iv_end         flag
*      -->iv_operation   string
*      -->iv_varible     string
*----------------------------------------------------------------------*
FORM FILL_MEASUREMENT  USING IV_START TYPE FLAG
IV_END   TYPE FLAG
IV_OPERATION TYPE STRING
IV_VARIBLE TYPE STRING
IV_MESSAGE TYPE STRING.

DATA : LS_MEASUREMENT_LOG TYPE TY_MEASUREMENT_LOG,
LV_TIME            TYPE TIMESTAMP,
LV_CURRENT_MEASURE TYPE I,
LV_MEASURE         TYPE I,
LV_TABIX           TYPE SYTABIX.

GET TIME STAMP FIELD LV_TIME.
CONVERT TIME STAMP LV_TIME TIME ZONE SY-ZONLO
INTO TIME LS_MEASUREMENT_LOG-TIME.

IF IV_START <> SPACE.
LS_MEASUREMENT_LOG-MODE = 'START'.
ENDIF.
IF IV_END <> SPACE.
LS_MEASUREMENT_LOG-MODE = 'END'.
ENDIF.

GET RUN TIME FIELD LV_CURRENT_MEASURE.
LV_CURRENT_MEASURE = LV_CURRENT_MEASURE  / 1000.
LV_MEASURE = LV_CURRENT_MEASURE - GV_LAST_MEASURE.
GV_LAST_MEASURE = LV_CURRENT_MEASURE.

LS_MEASUREMENT_LOG-TIME_MILI = LV_MEASURE.
LS_MEASUREMENT_LOG-ACTION = IV_OPERATION.
LS_MEASUREMENT_LOG-VAR  = IV_VARIBLE.
LS_MEASUREMENT_LOG-DESCRIPTION = IV_MESSAGE.

APPEND LS_MEASUREMENT_LOG TO GT_MEASUREMENT_LOG.
ENDFORM.                    " fill_measurement
*&---------------------------------------------------------------------*
*&      Form  add_mesurement_to_xml
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ADD_MEASUREMENT_TO_XML .
DATA: LS_MEASUREMENT_LOG LIKE LINE OF GT_MEASUREMENT_LOG,
LV_MEASURE_TAG TYPE STRING.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'MEASUREMENT' ''
'End of Measurment,zipping and encoding not included'.

PERFORM APPEND_XML_TO_BUFFER USING '<MEASUREMENTS>'.
* Save measurement data to xml file
LOOP AT GT_MEASUREMENT_LOG INTO LS_MEASUREMENT_LOG.
LV_MEASURE_TAG = '  <MEASUREMENT '.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG
USING
'TIME' LS_MEASUREMENT_LOG-TIME
CHANGING
LV_MEASURE_TAG .

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG
USING
'ACTION' LS_MEASUREMENT_LOG-ACTION
CHANGING
LV_MEASURE_TAG .

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG
USING
'MODE' LS_MEASUREMENT_LOG-MODE
CHANGING
LV_MEASURE_TAG .

IF LS_MEASUREMENT_LOG-TIME_MILI <> SPACE.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG
USING
'TIME_MILI' LS_MEASUREMENT_LOG-TIME_MILI
CHANGING
LV_MEASURE_TAG .
ENDIF.

PERFORM APPEND_ATTRIBUTE_TO_XML_TAG
USING
'DESCRIPTION' LS_MEASUREMENT_LOG-DESCRIPTION
CHANGING
LV_MEASURE_TAG .

IF LS_MEASUREMENT_LOG-VAR <> SPACE.
PERFORM APPEND_ATTRIBUTE_TO_XML_TAG
USING 'VAR' LS_MEASUREMENT_LOG-VAR
CHANGING LV_MEASURE_TAG .
ENDIF.

CONCATENATE LV_MEASURE_TAG '/>' INTO LV_MEASURE_TAG.

PERFORM APPEND_XML_TO_BUFFER USING LV_MEASURE_TAG.

ENDLOOP.
PERFORM APPEND_XML_TO_BUFFER USING '</MEASUREMENTS>'.

CLEAR : GT_MEASUREMENT_LOG[].

ENDFORM.                    " add_mesurement_to_xml
*&---------------------------------------------------------------------*
*&      Form  add_measures_to_log
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ADD_MEASURES_TO_LOG .
DATA : LS_MEASUREMENT_LOG LIKE LINE OF GT_MEASUREMENT_LOG,
LV_MSG TYPE STRING.

* Add measurments data to log file for data transfer
* between zp_Record mode (different proccesses)
LOOP AT GT_MEASUREMENT_LOG INTO LS_MEASUREMENT_LOG.
CONCATENATE
'MEASUREMENT_LOG'
LS_MEASUREMENT_LOG-TIME
LS_MEASUREMENT_LOG-ACTION
LS_MEASUREMENT_LOG-MODE
LS_MEASUREMENT_LOG-TIME_MILI
LS_MEASUREMENT_LOG-DESCRIPTION
LS_MEASUREMENT_LOG-VAR
INTO
LV_MSG SEPARATED BY ':'.
APPEND LV_MSG TO GT_LOG_DATA.
ENDLOOP.

* Flush measures data to log
CONCATENATE
'Flush log'
' with measurements'
INTO LV_MSG.
PERFORM ADD_TO_LOG USING LV_MSG GC_FLUSH_LOG.

CLEAR : GT_LOG_DATA[].
ENDFORM.                    " add_measures_to_log
*&---------------------------------------------------------------------*
*&      Form  get_measures_from_log
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM GET_MEASURES_FROM_LOG
TABLES IT_LOG_DATA TYPE STRING_TAB.

DATA : LS_LOG_DATA LIKE LINE OF IT_LOG_DATA,
LS_MEASUREMENT_LOG TYPE TY_MEASUREMENT_LOG,
LT_END_MEASUREMENT_LOG TYPE STANDARD TABLE OF
TY_MEASUREMENT_LOG,
LV_STRING TYPE STRING.

* Use the log file stored at client side
* for previous measurement data extraction

* Save end measurements recorded in current execution
LT_END_MEASUREMENT_LOG[] = GT_MEASUREMENT_LOG[].
CLEAR : GT_MEASUREMENT_LOG[].

* Itterate over the previous log data,extract the previous measures
LOOP AT IT_LOG_DATA INTO LS_LOG_DATA.
IF LS_LOG_DATA CS 'MEASUREMENT_LOG'.
*     Remove measures data from log sent to Panaya
DELETE IT_LOG_DATA INDEX SY-TABIX.

LV_STRING = LS_LOG_DATA.
*     Append to the previous measurements,START / RESTORE,
*     to the measurements log
LV_STRING = LV_STRING+16.
SPLIT LV_STRING AT ':'
INTO  LS_MEASUREMENT_LOG-TIME
LS_MEASUREMENT_LOG-ACTION
LS_MEASUREMENT_LOG-MODE
LS_MEASUREMENT_LOG-TIME_MILI
LS_MEASUREMENT_LOG-DESCRIPTION
LS_MEASUREMENT_LOG-VAR.

APPEND LS_MEASUREMENT_LOG TO GT_MEASUREMENT_LOG.
ENDIF.
ENDLOOP.

* Append the end measurements to previously recorded measurements
* extracted from the log file , executions START / RESTORE
APPEND LINES OF LT_END_MEASUREMENT_LOG TO GT_MEASUREMENT_LOG.
ENDFORM.                    " get_measures_from_log
*&---------------------------------------------------------------------*
*&      Form  set_wp_file_name
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_P_PWP_INDEX  text
*      <--P_DEVFILE  text
*----------------------------------------------------------------------*
FORM SET_WP_FILE_NAME USING    IV_PWP_INDEX
CHANGING CV_DEVFILE.

CV_DEVFILE    = 'dev_w'.
CV_DEVFILE+5  = IV_PWP_INDEX.

CONDENSE CV_DEVFILE NO-GAPS.

ENDFORM.                    " set_wp_file_name
*&---------------------------------------------------------------------*
*&      Form  add_wps_status_to_log
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ADD_WPS_STATUS_TO_LOG.

DATA: WP_LIST        TYPE TABLE OF WPINFO WITH HEADER LINE,
CURR_TRACE     TYPE THFB_TRACE,
MSG            TYPE STRING,
LV_SUBRC       TYPE STRING,
LV_WPS_NUM       TYPE I,
LV_LOCKED_WPS(3) TYPE N,
LV_DIALOG_WPS(3) TYPE N,
LV_TRACE2_WPS(3) TYPE N.
DATA: LOCK_WP TYPE C,
LC_OPCODE TYPE X VALUE 28,
STATE TYPE I,
WP TYPE I,
STAMP(14),
WP_ID(2).

* Get current system wps
CALL FUNCTION 'TH_GET_WPINFO'
TABLES
WPLIST = WP_LIST.

IF SY-SUBRC IS INITIAL.

DESCRIBE TABLE WP_LIST LINES LV_WPS_NUM.

MSG = LV_WPS_NUM.
CONCATENATE 'Number of work process:'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

*   Go over all processes and check if trace is enabled
LOOP AT WP_LIST.
IF WP_LIST-WP_TYP = 'DIA'.
LV_DIALOG_WPS = LV_DIALOG_WPS + 1.

PERFORM TH_GET_TRACE_SETTING USING WP_LIST-WP_INDEX
CHANGING CURR_TRACE.

IF CURR_TRACE-LEVEL = '2'
AND CURR_TRACE-DIAG = 'X'.
LV_TRACE2_WPS = LV_TRACE2_WPS + 1.

IF WP_LIST-WP_WAITING = 'LOCK'.
LV_LOCKED_WPS = LV_LOCKED_WPS + 1.
ENDIF.
ENDIF.
ENDIF.

PERFORM WRITE_WP_TO_LOG USING WP_LIST.
ENDLOOP.

CLEAR : MSG.
MSG = LV_DIALOG_WPS.
CONCATENATE 'Number of dialog wps:'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CLEAR : MSG.
MSG = LV_TRACE2_WPS.
CONCATENATE 'Number of dialog wps with trace level 2:'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.

CLEAR : MSG.
MSG = LV_LOCKED_WPS.
CONCATENATE 'Number of locked dialog wps with trace level 2'
'(before process release):'
MSG INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ENDIF.

* Current WP lock state
*----------------------------------------------------------------------
* STATE : 0 Wp ist nicht gelockt
*         1 Wp ist gelockt
* WP    : eigene Workprozess-Id
* STAMP : Zeitstempel der in das entsprechende dev-File geschrieben wird
*----------------------------------------------------------------------
CALL 'ThUsrInfo' ID 'OPCODE'     FIELD LC_OPCODE
ID 'LOCK_STATE' FIELD STATE
ID 'WP_ID'      FIELD WP
ID 'STAMP'      FIELD STAMP.
WP_ID = WP.
IF STATE = 1.
LOCK_WP = 'X'.
ELSE.
LOCK_WP = SPACE.
ENDIF.

CLEAR: MSG.
CONCATENATE
'Current wp:' WP_ID
'lock state is:' LOCK_WP
INTO MSG SEPARATED BY SPACE.

PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
ENDFORM.                    " add_wps_status_to_log
*&---------------------------------------------------------------------*
*&      Form  write_wp_to_log
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_WP_LIST  text
*----------------------------------------------------------------------*
FORM WRITE_WP_TO_LOG USING IS_WP_LIST TYPE WPINFO.

FIELD-SYMBOLS : <LS_COMP> TYPE ABAP_COMPDESCR,
<LV_DATA> TYPE ANY.
DATA : LV_MSG TYPE STRING,
LV_VALUE TYPE STRING,
LO_STRUC_DESCR TYPE REF TO CL_ABAP_STRUCTDESCR.

LO_STRUC_DESCR ?=
CL_ABAP_TYPEDESCR=>DESCRIBE_BY_NAME( 'WPINFO' ).

LV_MSG = 'WP: '.
LOOP AT LO_STRUC_DESCR->COMPONENTS ASSIGNING <LS_COMP>.
ASSIGN COMPONENT <LS_COMP>-NAME
OF STRUCTURE IS_WP_LIST TO <LV_DATA>.

IF SY-SUBRC IS INITIAL.
IF NOT <LV_DATA> IS INITIAL.
LV_VALUE = <LV_DATA>.
CONCATENATE LV_MSG
<LS_COMP>-NAME
'='
LV_VALUE
'|'
INTO LV_MSG ."separated by space.
CLEAR : <LV_DATA>,LV_VALUE.
ENDIF.
ENDIF.
ENDLOOP.

PERFORM ADD_TO_LOG USING LV_MSG GC_LOG_WRITE.

ENDFORM.                    " write_wp_to_log
*&---------------------------------------------------------------------*
*&      Form  check_unicode_system
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM CHECK_UNICODE_SYSTEM.

DATA : LV_UCLEN TYPE UNICODELG.

CLEAR LV_UCLEN.
CALL 'CUR_LCL' ID 'UC_LN' FIELD LV_UCLEN.

IF LV_UCLEN > 1.
GV_UNICODE_SYSTEM = ABAP_TRUE.
PERFORM ADD_TO_LOG USING
'The system is unicode system' GC_LOG_WRITE.
ELSE.
PERFORM ADD_TO_LOG USING
'The system is a NON unicode system' GC_LOG_WRITE.
ENDIF.

ENDFORM.                    " check_unicode_system
*&---------------------------------------------------------------------*
*&      Form  check_server_file_access
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM CHECK_SERVER_FILE_ACCESS
CHANGING CT_CLIENT_DATA_ITAB TYPE STRING_TAB.
DATA : CLIENT_DATA_LINE LIKE LINE OF CT_CLIENT_DATA_ITAB.
DATA : LV_WORKDIR(120) TYPE C,
LV_TEMP_FILE    TYPE STRING,
LV_TEMP_DATA    TYPE STRING,
LV_MSG          TYPE STRING,
LV_FILE_OPENED  TYPE FLAG.

PERFORM GET_SAP_WORKDIR_ON_SERVER_SEP CHANGING LV_WORKDIR.

CONCATENATE LV_WORKDIR 'panayaTemp.txt' INTO LV_TEMP_FILE.

PERFORM OPEN_DATASET
USING LV_TEMP_FILE ABAP_FALSE.

IF NOT SY-SUBRC IS INITIAL.
CLEAR : LV_MSG.
LV_MSG = SY-SUBRC.
CONCATENATE
'ServerFileFailed1='
'open file in'
LV_WORKDIR
'failed with RC:'
LV_MSG
INTO
CLIENT_DATA_LINE
SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
LV_FILE_OPENED = ABAP_TRUE.
ENDIF.

CHECK NOT LV_FILE_OPENED IS INITIAL.

TRANSFER 'test' TO LV_TEMP_FILE.
IF NOT SY-SUBRC IS INITIAL.
CLEAR : LV_MSG.
LV_MSG = SY-SUBRC.
CONCATENATE
'ServerFileFailed2='
'write data to file in'
LV_WORKDIR
'failed with RC:'
LV_MSG
INTO
CLIENT_DATA_LINE
SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.

CLOSE DATASET LV_TEMP_FILE.
IF NOT SY-SUBRC IS INITIAL.
CLEAR : LV_MSG.
LV_MSG = SY-SUBRC.
CONCATENATE
'ServerFileFailed3='
'close file in'
LV_WORKDIR
'failed with RC:'
LV_MSG
INTO
CLIENT_DATA_LINE
SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CLEAR : LV_FILE_OPENED.
ENDIF.

CHECK LV_FILE_OPENED IS INITIAL.

PERFORM OPEN_DATASET
USING LV_TEMP_FILE ABAP_TRUE.
IF NOT SY-SUBRC IS INITIAL.
CLEAR : LV_MSG.
LV_MSG = SY-SUBRC.
CONCATENATE
'ServerFileFailed1='
'open file in'
LV_WORKDIR
'failed with RC:'
LV_MSG
INTO
CLIENT_DATA_LINE
SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
LV_FILE_OPENED = ABAP_TRUE.
ENDIF.

CHECK NOT LV_FILE_OPENED IS INITIAL.

READ DATASET LV_TEMP_FILE INTO LV_TEMP_DATA.
IF NOT SY-SUBRC IS INITIAL.
CLEAR : LV_MSG.
LV_MSG = SY-SUBRC.
CONCATENATE
'ServerFileFailed4='
'read file in'
LV_WORKDIR
'failed with RC:'
LV_MSG
INTO
CLIENT_DATA_LINE
SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.

CLOSE DATASET LV_TEMP_FILE.
IF NOT SY-SUBRC IS INITIAL.
CLEAR : LV_MSG.
LV_MSG = SY-SUBRC.
CONCATENATE
'ServerFileFailed3='
'close file in'
LV_WORKDIR
'failed with RC:'
LV_MSG
INTO
CLIENT_DATA_LINE
SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.

DELETE DATASET LV_TEMP_FILE.
IF NOT SY-SUBRC IS INITIAL.
CLEAR : LV_MSG.
LV_MSG = SY-SUBRC.
CONCATENATE
'ServerFileFailed5='
'delete file from'
LV_WORKDIR
'failed with RC:'
LV_MSG
INTO
CLIENT_DATA_LINE
SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.

ENDFORM.                    " check_server_file_access
*&---------------------------------------------------------------------*
*&      Form  no_end_to_failure_file
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM NO_END_TO_FAILURE_FILE.
DATA : MSG TYPE STRING .

*   zp_record end executed although we didnt verify that
*   zp_record start was executed
CONCATENATE 'Date: ' SY-DATUM
'Time:'  SY-UZEIT
'User:'  SY-UNAME
'Message:'
'ZP_RECORD END was not executed'
'ZP_RECORD STRAT execution not verified'
INTO MSG SEPARATED BY SPACE.
APPEND MSG TO GT_LOG_DATA.

IF G_LOG_FILENAME IS INITIAL.
DATA : LV_SAP_WORKDIR TYPE SDOK_CHTRD,
LV_ERROR_MESSAGE TYPE IWERRORMSG.
CALL FUNCTION 'IW_C_GET_SAPWORKDIR'
IMPORTING
SAPWORKDIR = LV_SAP_WORKDIR
ERROR_MSG  = LV_ERROR_MESSAGE.

CONCATENATE
LV_SAP_WORKDIR
'PanayaFailure.txt'
INTO
G_LOG_FILENAME.
ENDIF.

IF NOT G_SHOW_TRANS_STATUS_APPEARS IS INITIAL.
CALL FUNCTION 'GUI_DOWNLOAD'
EXPORTING
FILENAME                = G_LOG_FILENAME
FILETYPE                = 'ASC'
TRUNC_TRAILING_BLANKS   = 'X'
SHOW_TRANSFER_STATUS    = ABAP_FALSE
TABLES
DATA_TAB                = GT_LOG_DATA
EXCEPTIONS
FILE_WRITE_ERROR        = 1
NO_BATCH                = 2
GUI_REFUSE_FILETRANSFER = 3
INVALID_TYPE            = 4
NO_AUTHORITY            = 5
UNKNOWN_ERROR           = 6
HEADER_NOT_ALLOWED      = 7
SEPARATOR_NOT_ALLOWED   = 8
FILESIZE_NOT_ALLOWED    = 9
HEADER_TOO_LONG         = 10
DP_ERROR_CREATE         = 11
DP_ERROR_SEND           = 12
DP_ERROR_WRITE          = 13
UNKNOWN_DP_ERROR        = 14
ACCESS_DENIED           = 15
DP_OUT_OF_MEMORY        = 16
DISK_FULL               = 17
DP_TIMEOUT              = 18
FILE_NOT_FOUND          = 19
DATAPROVIDER_EXCEPTION  = 20
CONTROL_FLUSH_ERROR     = 21
OTHERS                  = 22.
ELSE.
CALL FUNCTION 'GUI_DOWNLOAD'
EXPORTING
FILENAME                = G_LOG_FILENAME
FILETYPE                = 'ASC'
TRUNC_TRAILING_BLANKS   = 'X'
TABLES
DATA_TAB                = GT_LOG_DATA
EXCEPTIONS
FILE_WRITE_ERROR        = 1
NO_BATCH                = 2
GUI_REFUSE_FILETRANSFER = 3
INVALID_TYPE            = 4
NO_AUTHORITY            = 5
UNKNOWN_ERROR           = 6
HEADER_NOT_ALLOWED      = 7
SEPARATOR_NOT_ALLOWED   = 8
FILESIZE_NOT_ALLOWED    = 9
HEADER_TOO_LONG         = 10
DP_ERROR_CREATE         = 11
DP_ERROR_SEND           = 12
DP_ERROR_WRITE          = 13
UNKNOWN_DP_ERROR        = 14
ACCESS_DENIED           = 15
DP_OUT_OF_MEMORY        = 16
DISK_FULL               = 17
DP_TIMEOUT              = 18
FILE_NOT_FOUND          = 19
DATAPROVIDER_EXCEPTION  = 20
CONTROL_FLUSH_ERROR     = 21
OTHERS                  = 22.
ENDIF.

IF SY-SUBRC <> 0.
MSG = SY-SUBRC.
MESSAGE E001(00) WITH
'Could not write failure log file at'
G_LOG_FILENAME
'finished with RC:'
MSG.
ENDIF.

ENDFORM.                    " no_end_to_failure_file
*&---------------------------------------------------------------------*
*&      Form  add_dev_disp_to_log
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM ADD_DEV_DISP_TO_LOG.

CONSTANTS : LC_BUFFER_SIZE TYPE I VALUE 10000.
DATA : LV_WORKDIR(120) TYPE C,
LV_DEV_DISP_FILE TYPE STRING,
LV_DATA TYPE STRING,
LT_DATA TYPE STANDARD TABLE OF STRING_REC,
LV_DATA_SIZE TYPE I.

PERFORM ADD_TO_LOG USING 'DEV_DISP' GC_FLUSH_LOG.

* Build dispatcher file path - workdir + dev_disp
PERFORM GET_SAP_WORKDIR_ON_SERVER_SEP CHANGING LV_WORKDIR.

CONCATENATE LV_WORKDIR 'dev_disp'
INTO LV_DEV_DISP_FILE.

* Read dev_disp file from server
PERFORM OPEN_DATASET
USING LV_DEV_DISP_FILE ABAP_TRUE.

DO.
READ DATASET LV_DEV_DISP_FILE INTO LV_DATA.
IF NOT SY-SUBRC IS INITIAL.
EXIT.
ENDIF.
APPEND LV_DATA TO LT_DATA.
DESCRIBE TABLE LT_DATA LINES LV_DATA_SIZE.
IF LV_DATA_SIZE > LC_BUFFER_SIZE.
*     Use the log file to add dev_disp data
CLEAR : GT_LOG_DATA[].
GT_LOG_DATA[] = LT_DATA[].
PERFORM ADD_TO_LOG USING 'DEV_DISP' GC_FLUSH_LOG.
CLEAR: LT_DATA[].
ENDIF.
ENDDO.

CLOSE DATASET LV_DEV_DISP_FILE.
* Add the last data
CLEAR : GT_LOG_DATA[].
GT_LOG_DATA[] = LT_DATA[].
PERFORM ADD_TO_LOG USING 'DEV_DISP' GC_FLUSH_LOG.
CLEAR: LT_DATA[].

ENDFORM.                    " add_dev_disp_to_log
*&---------------------------------------------------------------------*
*&      Form  log_system_wp_parameters
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM LOG_SYSTEM_WP_PARAMETERS.

PERFORM ADD_TO_LOG USING 'WP system parameters:' GC_LOG_WRITE.

PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/max_hold_time'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/max_wprun_time'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/restartable_wp'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wpdbug_max_no'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wppriv_max_no'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_abap_restart'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_auto_restart'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_ca_blk_no'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_no_btc'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_no_dia'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_no_enq'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_no_spo'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/wp_no_vb'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/max_priv_time'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/max_sleep'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/max_wprun_time'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'rdisp/restartable_wp'.
PERFORM ADD_PARAMETER_VALUE_TO_LOG USING 'ztta/parameter_area'.
ENDFORM.                    " log_system_wp_parameters
*&---------------------------------------------------------------------*
*&      Form  add_parameter_value_to_log
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LV_PARAMETER_NAME  text
*----------------------------------------------------------------------*
FORM ADD_PARAMETER_VALUE_TO_LOG
USING IV_PARAMETER_NAME TYPE PFEPVALUE.

DATA : LV_PARAMETER_VALUE TYPE PFEPVALUE,
LV_MSG             TYPE STRING.

* Get system parameter value
CALL 'C_SAPGPARAM' ID 'NAME'  FIELD IV_PARAMETER_NAME
ID 'VALUE' FIELD LV_PARAMETER_VALUE.
CONCATENATE
IV_PARAMETER_NAME
'='
LV_PARAMETER_VALUE
INTO LV_MSG.

PERFORM ADD_TO_LOG USING LV_MSG GC_LOG_WRITE.
ENDFORM.                    " add_parameter_value_to_log
*&---------------------------------------------------------------------*
*&      Form  get_filename
*&---------------------------------------------------------------------*
* This is copy of form GET_DEVFILE_NAME in program RSTRC000
FORM GET_FILENAME USING    P_PWP_INDEX
CHANGING P_FULL_TRACE_FILENAME.

DATA:  WORKDIR(120),
DEVFILE(20),
EXTENSION(10).

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE 'GET TRACE FILE NAME' ''
'Start get trace file name'.

PERFORM GET_SAP_WORKDIR_ON_SERVER CHANGING WORKDIR.

PERFORM SET_WP_FILE_NAME USING P_PWP_INDEX
CHANGING DEVFILE.

CALL 'BUILD_DS_SPEC' ID 'PATH'     FIELD WORKDIR
ID 'FILENAME' FIELD DEVFILE
ID 'OPSYS'    FIELD SY-OPSYS
ID 'RESULT'   FIELD P_FULL_TRACE_FILENAME.

OPEN DATASET P_FULL_TRACE_FILENAME IN TEXT MODE FOR INPUT ENCODING
DEFAULT.
IF SY-SUBRC <> 0.

CALL 'C_SAPGPARAM' ID 'NAME'  FIELD 'FT_LOG'
ID 'VALUE' FIELD EXTENSION.

DEVFILE+10 = EXTENSION.
CONDENSE DEVFILE NO-GAPS.
CALL 'BUILD_DS_SPEC' ID 'PATH'     FIELD WORKDIR
ID 'FILENAME' FIELD DEVFILE
ID 'OPSYS'    FIELD SY-OPSYS
ID 'RESULT'   FIELD P_FULL_TRACE_FILENAME.

OPEN DATASET P_FULL_TRACE_FILENAME IN TEXT MODE FOR INPUT ENCODING
DEFAULT.

IF SY-SUBRC <> 0.
PERFORM SHOW_ERROR USING
'Error while reading trace file. Filename '
P_FULL_TRACE_FILENAME
'Error : '
SY-SUBRC.
EXIT.
CLEAR P_FULL_TRACE_FILENAME.
EXIT.
ENDIF.
ENDIF.

CLOSE DATASET P_FULL_TRACE_FILENAME.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE 'GET TRACE FILE NAME' ''
'End get trace file name'.

ENDFORM.                    " get_filename

*&---------------------------------------------------------------------*
*&      Form  add_data_to_file_in_server
*&---------------------------------------------------------------------*
FORM ADD_DATA_TO_FILE_IN_SERVER USING P_DATA_TAB TYPE STRING_TAB.

DATA: P_DATA_REC LIKE LINE OF P_DATA_TAB,
L_RECSIZE TYPE I.

* Write the file on server
* Open file in UTF-8 encoding. We want to write the file in UTF-8 and
* set it as html and xml encoding.
IF G_FILE_IS_APPEND_MODE_SERVER IS INITIAL.
OPEN DATASET TEMP_XML_FILENAME FOR OUTPUT IN TEXT MODE ENCODING
UTF-8.
ELSE.
OPEN DATASET TEMP_XML_FILENAME FOR APPENDING IN TEXT MODE ENCODING
UTF-8.
ENDIF.

* Write the contents of the file
LOOP AT P_DATA_TAB INTO P_DATA_REC.
L_RECSIZE = STRLEN( P_DATA_REC ).
TRANSFER P_DATA_REC TO TEMP_XML_FILENAME LENGTH L_RECSIZE.
ENDLOOP.

* Close file
CLOSE DATASET TEMP_XML_FILENAME.

* The first time the file is opened as overwrite. Next
* time it will be opened in append mode.
IF G_FILE_IS_APPEND_MODE_SERVER IS INITIAL.
G_FILE_IS_APPEND_MODE_SERVER = 'X'.
ENDIF.

IF G_WAS_FILE_CREATED IS INITIAL.
G_WAS_FILE_CREATED = 'X'.
ENDIF.
ENDFORM.                    "ADD_DATA_TO_FILE_IN_SERVER

*&---------------------------------------------------------------------*
*&      Form  get_current_encoding
*&---------------------------------------------------------------------*
FORM GET_CURRENT_ENCODING CHANGING ENCOD TYPE STRING.
ENCOD = 'UTF-8'.
ENDFORM.                    "get_current_encoding

*&---------------------------------------------------------------------*
*&      Form  check_directory_exists
*&---------------------------------------------------------------------*
FORM CHECK_DIRECTORY_EXISTS.

*  Check that directory exists
DIRECTORY = P_OFF.
CALL METHOD CL_GUI_FRONTEND_SERVICES=>DIRECTORY_EXIST
EXPORTING
DIRECTORY            = DIRECTORY
RECEIVING
RESULT               = DIR_EXISTS
EXCEPTIONS
CNTL_ERROR           = 1
ERROR_NO_GUI         = 2
WRONG_PARAMETER      = 3
NOT_SUPPORTED_BY_GUI = 4
OTHERS               = 5.

IF SY-SUBRC <> 0.
MESSAGE E000(CONV) WITH 'Error when checking directory '
DIRECTORY ' exists. Error message: ' SY-SUBRC.
ELSE.
IF DIR_EXISTS = ABAP_FALSE.
MESSAGE E000(CONV) WITH 'The provided directory '
'does not exist. Please enter existing directory.'.

ENDIF.
ENDIF.

ENDFORM.                    "check_directory_exists

*&---------------------------------------------------------------------*
*&      Form  ADD_XML_TEXT_CONTENT_TO_FILE
*&---------------------------------------------------------------------*
FORM ADD_XML_TEXT_CONTENT_TO_FILE USING SHOULD_ADD_XML_ESC.

DATA: REC_C TYPE LINE OF STRING_TAB,
STRING_REC TYPE STRING,
LAST_LINE_LENGTH TYPE I.

*   Open the original text file in text mode in UTF-8 ( that's how
*   it was written to the server )
OPEN DATASET TEMP_XML_FILENAME IN TEXT MODE FOR INPUT ENCODING
UTF-8.

DO.

CLEAR REC_C.

*     Read line in length of the buffer
READ DATASET TEMP_XML_FILENAME INTO REC_C
LENGTH LAST_LINE_LENGTH.
IF SY-SUBRC <> 0.
EXIT.
ENDIF.

*     Convert to string ( fro passing to buffer )
STRING_REC = REC_C.

*     Add the xml escaping
IF SHOULD_ADD_XML_ESC = 'X'.
PERFORM HANDLE_XML_ESCAPING CHANGING STRING_REC.
ENDIF.

*     Add the records to buffer ( with end line )
PERFORM APPEND_STRING_TO_BUFFER USING STRING_REC 'X' 'X'.

ENDDO.

*   Add last line
IF LAST_LINE_LENGTH > 0.
PERFORM APPEND_STRING_TO_BUFFER USING STRING_REC 'X' 'X'.
ENDIF.

*   Close file
CLOSE DATASET TEMP_XML_FILENAME.

*   Flush the buffer into the client - ascii mode
PERFORM FLUSH_BUFFER USING 'X' 'X'.

*   After the transfer - delete the original file
DELETE DATASET TEMP_XML_FILENAME.

ENDFORM.                    " ADD_XML_TEXT_CONTENT_TO_FILE

*&---------------------------------------------------------------------*
*&      Form  ENCODE_BASE64_AND_ADD_TO_FILE
*&---------------------------------------------------------------------*
FORM ENCODE_BASE64_AND_ADD_TO_FILE USING IS_ZIP_SUCC.

DATA: BEGIN OF TAB_X OCCURS 0,
LINE(512) TYPE X,
END OF TAB_X.

DATA: BEGIN OF TAB_CONV_STR OCCURS 0,
LINE(512) TYPE C,
END OF TAB_CONV_STR.

DATA: FULL_FILENAME TYPE STRING,
STRING_REC TYPE STRING,
REC_X(512) TYPE X,
LINE_LENGTH TYPE I,
FULL_LAST_LINE_HEXA TYPE STRING,
HEX_LENGTH TYPE I,
OUTPUT_LENGTH TYPE I,
CONV_REC LIKE LINE OF TAB_CONV_STR,
NO_OF_LINES TYPE I,
CURR_LINE_LENGTH TYPE I,
MSG TYPE STRING,
LV_SUBRC TYPE STRING.

*   Read the zipped file in binary mode ( if zipping successeded.
*   Otherwise - use the regular file ).
IF NOT IS_ZIP_SUCC IS INITIAL.
CONCATENATE TEMP_XML_FILENAME '.gz'
INTO FULL_FILENAME.
ELSE.
FULL_FILENAME = TEMP_XML_FILENAME.
ENDIF.

* Open the zipped file
OPEN DATASET FULL_FILENAME FOR INPUT IN BINARY MODE.
IF NOT SY-SUBRC IS INITIAL.
LV_SUBRC = SY-SUBRC.
CONCATENATE : 'Error in reading xml file:'
FULL_FILENAME
'RC:'
LV_SUBRC
INTO MSG
SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING MSG GC_LOG_WRITE.
CLEAR: MSG.

MESSAGE E001(00) WITH 'Error in reading xml file: '
FULL_FILENAME '. Error code: ' LV_SUBRC.
ENDIF.

*   Read the file content into record. The record will be converted to
*   string with its hexa representation
DO.

CLEAR: REC_X, STRING_REC.

READ DATASET FULL_FILENAME INTO TAB_X
LENGTH LINE_LENGTH.

IF SY-SUBRC <> 0.
EXIT.
ENDIF.

*     Convert the X type to string with the hexa representation and add
*     it to buffer

************************************************
*     REGULAR - NO BASE 64
************************************************
*      STRING_REC = REC_X.
*
*     Add the string into buffer
*      PERFORM APPEND_STRING_TO_BUFFER USING STRING_REC 'X' ' '.
*
*    ENDDO.
************************************************

************************************************
*     BASE 64
************************************************
*     Add the x record into table of type x
APPEND TAB_X.
HEX_LENGTH = HEX_LENGTH + LINE_LENGTH.

ENDDO.

*   Add last line ( with repect to the length of last line )
IF LINE_LENGTH > 0.

************************************************
*     REGULAR - NO BASE 64
************************************************
*      FULL_LAST_LINE_HEXA = REC_X.
*      LINE_LENGTH = LINE_LENGTH * 2.
*      STRING_REC = FULL_LAST_LINE_HEXA(LAST_LINE_LENGTH).
*      PERFORM APPEND_STRING_TO_BUFFER USING STRING_REC 'X' ' '.
************************************************

************************************************
*     BASE 64
************************************************
HEX_LENGTH = HEX_LENGTH + LINE_LENGTH.
APPEND TAB_X.
************************************************

ENDIF.

************************************************
*     BASE 64
************************************************
PERFORM ADD_TO_LOG USING
'Encode the file to base 64'
GC_LOG_WRITE.

PERFORM FILL_MEASUREMENT USING
ABAP_TRUE ABAP_FALSE
'BASE64 ENCODE' '' 'Start base 64 encode'.
* Convert to 64 Base
CALL FUNCTION 'SSFC_BASE64_CODE'
EXPORTING
OSTR_INPUT_DATA_L            = HEX_LENGTH
IMPORTING
OSTR_DIGESTED_DATA_L         = OUTPUT_LENGTH
TABLES
OSTR_INPUT_DATA              = TAB_X
OSTR_DIGESTED_DATA           = TAB_CONV_STR
EXCEPTIONS
SSF_KRN_ERROR                = 1
SSF_KRN_NOOP                 = 2
SSF_KRN_NOMEMORY             = 3
SSF_KRN_OPINV                = 4
SSF_KRN_INPUT_DATA_ERROR     = 5
SSF_KRN_INVALID_PAR          = 6
SSF_KRN_INVALID_PARLEN       = 7
SSF_FB_INPUT_PARAMETER_ERROR = 8
OTHERS                       = 9.

IF SY-SUBRC <> 0.
CLEAR : MSG.
LV_SUBRC = SY-SUBRC.
CONCATENATE :
'Conversion to BASE64 failed. RC:'
LV_SUBRC
INTO MSG SEPARATED BY SPACE.
PERFORM ADD_TO_LOG USING
MSG
GC_LOG_WRITE.

MESSAGE E001(00) WITH 'Conversion to BASE64 failed. Return code:'
LV_SUBRC.
ELSE.

*   Add the converted data to buffer ( with respect to length of the
*   last line )
DESCRIBE TABLE TAB_CONV_STR LINES NO_OF_LINES.

*   Go over the result
LOOP AT TAB_CONV_STR INTO CONV_REC.

*     If this is last line - get only the remaining length
IF SY-TABIX = NO_OF_LINES.
STRING_REC = CONV_REC(OUTPUT_LENGTH).
ELSE.
STRING_REC = CONV_REC.
ENDIF.

PERFORM APPEND_STRING_TO_BUFFER USING STRING_REC 'X' ' '.

*     Calculate current field length and reduct the total length
*     accordingly ( for calculating the remaining length of last
*     line )
DESCRIBE FIELD CONV_REC LENGTH CURR_LINE_LENGTH
IN CHARACTER MODE.
OUTPUT_LENGTH = OUTPUT_LENGTH - CURR_LINE_LENGTH.

ENDLOOP.

ENDIF.

PERFORM FILL_MEASUREMENT USING
ABAP_FALSE ABAP_TRUE
'BASE64 ENCODE' '' 'End base 64 encode'.
************************************************
* Close file
CLOSE DATASET FULL_FILENAME.

* Flush the buffer into the client - binary mode
PERFORM FLUSH_BUFFER USING 'X' ' '.

* After the transfer - delete the original zip file
DELETE DATASET FULL_FILENAME.
ENDFORM.                    " ADD_XML_ZIPPED_CONTENT_TO_FILE

*&---------------------------------------------------------------------*
*&      Form  check_gui_auth
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->IV_PERFORM_CHECKS    text
*      -->CT_CLIENT_DATA_ITAB  text
*----------------------------------------------------------------------*
FORM CHECK_GUI_AUTH
USING    IV_PERFORM_CHECKS   TYPE FLAG
CHANGING CT_CLIENT_DATA_ITAB TYPE STRING_TAB.

DATA :
CLIENT_DATA_LINE    LIKE LINE OF CT_CLIENT_DATA_ITAB.

* S_GUI - object
AUTHORITY-CHECK OBJECT 'S_GUI'
ID 'ACTVT' FIELD '61'.
IF SY-SUBRC <> 0.
IF IV_PERFORM_CHECKS = ABAP_FALSE.
CONCATENATE 'AuthorizationFailed11='
'Object: S_GUI '
'Activity: 61'
INTO CLIENT_DATA_LINE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ELSE.
CONCATENATE 'Additional authorization object required:'
'Object: S_GUI'
'Activity: 61'
INTO CLIENT_DATA_LINE SEPARATED BY SPACE.
APPEND CLIENT_DATA_LINE TO CT_CLIENT_DATA_ITAB.
ENDIF.
ENDIF.

ENDFORM.                    "check_gui_auth
*&---------------------------------------------------------------------*
*&      Form  OPEN_FILE
*&---------------------------------------------------------------------*
FORM OPEN_FILE USING P_FULL_TRACE_FILENAME
P_START_POS
CHANGING P_FILE_OPENED TYPE C.

CLEAR P_FILE_OPENED.

IF NOT GV_UNICODE_SYSTEM IS INITIAL.
*   For unicode systems we can use binary read as the files
*   in the app server are written in UTF8
*   Open the file at start position read in zp_record start
*   according to trace initial file size
OPEN DATASET P_FULL_TRACE_FILENAME
IN BINARY MODE
FOR INPUT
AT POSITION P_START_POS.
ELSE.
*   In non unicode systems we have to read the data in textual mode
*   as we need to convert it to UTF8 when written to temp_xml file
*   Open the trace file in default encoding. We want to read the trace
*   file in the system encoding
OPEN DATASET P_FULL_TRACE_FILENAME
IN TEXT MODE ENCODING DEFAULT
FOR INPUT
AT POSITION P_START_POS.
ENDIF.

IF NOT SY-SUBRC IS INITIAL.
PERFORM SHOW_ERROR USING
'Error while opening trace file. Filename '
P_FULL_TRACE_FILENAME
'Error : '
SY-SUBRC.
EXIT.
ELSE.
P_FILE_OPENED = 'X'.
ENDIF.

ENDFORM.                    " OPEN_FILE
*---------------------------------------------------------------------*
*       FORM open_dataset_in_text_mode                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  IV_DATASET                                                    *
*---------------------------------------------------------------------*
FORM OPEN_DATASET
USING
IV_DATASET TYPE STRING
IV_INPUT TYPE FLAG.
DATA: LO_EX TYPE REF TO CX_ROOT.
IF NOT IV_INPUT IS INITIAL.
TRY.
OPEN DATASET IV_DATASET FOR INPUT
IN TEXT MODE ENCODING DEFAULT.
CATCH CX_ROOT INTO LO_EX.
SY-SUBRC = 8.
ENDTRY.
ELSE.
TRY.
OPEN DATASET IV_DATASET FOR OUTPUT
IN TEXT MODE ENCODING DEFAULT.
CATCH CX_ROOT INTO LO_EX.
SY-SUBRC = 8.
ENDTRY.
ENDIF.
ENDFORM.                    "open_dataset
*&---------------------------------------------------------------------*
*&      Form  get_system_version
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      <--P_CLIENT_DATA_ITAB  text
*----------------------------------------------------------------------*
FORM GET_SYSTEM_VERSION  CHANGING CT_CLIENT_DATA_ITAB
TYPE STRING_TAB.

DATA : LT_CVERS TYPE STANDARD TABLE OF CVERS.

SELECT *
FROM CVERS
INTO CORRESPONDING FIELDS OF TABLE LT_CVERS
WHERE COMPONENT IN ('SAP_APPL', 'SAP_HR', 'EA-HR').

PERFORM SET_PATCH TABLES  LT_CVERS
USING   'SAP_APPL'
CHANGING CT_CLIENT_DATA_ITAB
GV_SAP_APPL.

PERFORM SET_PATCH TABLES  LT_CVERS
USING   'SAP_HR'
CHANGING CT_CLIENT_DATA_ITAB
GV_SAP_HR.

PERFORM SET_PATCH TABLES  LT_CVERS
USING   'EA-HR'
CHANGING CT_CLIENT_DATA_ITAB
GV_EA_HR.
ENDFORM.                    " get_system_version
*&---------------------------------------------------------------------*
*&      Form  set_patch
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_LT_CVERS  text
*      -->P_0986   text
*      <--P_CT_CLIENT_DATA_ITAB  text
*----------------------------------------------------------------------*
FORM SET_PATCH  TABLES  IT_CVERS STRUCTURE CVERS
USING   IV_PATCH TYPE STRING
CHANGING CT_CLIENT_DATA_ITAB TYPE STRING_TAB
EV_PATCH TYPE STRING.

DATA : LS_CLIENT_DATA LIKE LINE OF CT_CLIENT_DATA_ITAB,
LS_CVERS LIKE LINE OF IT_CVERS,
LV_PATCH TYPE NUMC2,
LV_RELEASE TYPE NUMC3.

* Get the patch data set in correct format
CLEAR : LV_PATCH, LV_RELEASE, LS_CLIENT_DATA.
READ TABLE IT_CVERS
WITH KEY COMPONENT = IV_PATCH
INTO LS_CVERS.

IF SY-SUBRC = 0.
LV_PATCH = LS_CVERS-EXTRELEASE.
LV_RELEASE = LS_CVERS-RELEASE.

CONCATENATE LV_RELEASE LV_PATCH
INTO EV_PATCH.
ENDIF.

* Set patch data for .data file output
CONCATENATE IV_PATCH
'='
LV_RELEASE
LV_PATCH
INTO LS_CLIENT_DATA-LINE.
APPEND LS_CLIENT_DATA TO CT_CLIENT_DATA_ITAB.

ENDFORM.                    " set_patch
*&---------------------------------------------------------------------*
*&      Form  set_parameter
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->P_IS_PARAM_VALUE  text
*----------------------------------------------------------------------*
FORM SET_PARAMETER  USING IS_PARAM_VALUE TYPE PARAM_VALUE.

DATA: LV_STRING TYPE STRING,
LV_SIZE TYPE I.
DATA: LV_DATA TYPE REF TO DATA.
FIELD-SYMBOLS: <LV_ANY> TYPE ANY.

* Convert parameter value from max size string (250)
* to the truncated , removed spaces , size string
* in order not to overflow session memory
* with unnecessary allocation of spaces
LV_STRING = IS_PARAM_VALUE-VALUE.
LV_SIZE = STRLEN( LV_STRING ).
* if no size set initial char size = 1
IF LV_SIZE = 0.
LV_SIZE = 1.
ENDIF.
* Max parameter size is 250
* to prevent failures set to max size if > 250
IF LV_SIZE > 250.
LV_SIZE = 250.
ENDIF.
* Create a variable with truncated length of the parameter
* In 4.6c version ABAP creates variables by predefined type
* in other system versions ABAP allows to use variable length
CREATE DATA LV_DATA TYPE C LENGTH LV_SIZE.
* Set the parameter value
ASSIGN LV_DATA->* TO <LV_ANY>.
IF SY-SUBRC IS INITIAL.
*   Set parameter value in session memory
<LV_ANY> = LV_STRING.
SET PARAMETER ID IS_PARAM_VALUE-ID FIELD <LV_ANY>.
ENDIF.
ENDFORM.                    " set_parameter
*&---------------------------------------------------------------------*
*&      Form  START_RTT
*&---------------------------------------------------------------------*
FORM START_RTT.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  END_RTT
*&---------------------------------------------------------------------*
FORM END_RTT.

ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  START_RTT_FROM_ABAP4_CALL_TRAN
*&---------------------------------------------------------------------*
FORM START_RTT_FROM_ABAP4_CALL_TRAN.
ENDFORM.                     "START_RTT_FROM_ABAP4_CALL_TRAN

*&---------------------------------------------------------------------*
*&      Form  ADD_RTT_DATA_FILE
*&---------------------------------------------------------------------*
FORM ADD_RTT_DATA_FILE .
ENDFORM.                     "ADD_RTT_DATA_FILE
